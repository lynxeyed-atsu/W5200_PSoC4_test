L 1 ".\Generated_Source\PSoC4\UART_1_UART.c"
N/*******************************************************************************
N* File Name: UART_1_UART.c
N* Version 1.10
N*
N* Description:
N*  This file provides the source code to the API for the SCB Component in
N*  UART mode.
N*
N* Note:
N*
N*******************************************************************************
N* Copyright 2013, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#include "UART_1_PVT.h"
L 1 ".\Generated_Source\PSoC4\UART_1_PVT.h" 1
N/*******************************************************************************
N* File Name: .h
N* Version 1.10
N*
N* Description:
N*  This private file provides constants and parameter values for the
N*  SCB Component in I2C mode.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2013, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PVT_UART_1_H)
X#if !0L
N#define CY_SCB_PVT_UART_1_H
N
N#include "UART_1.h"
L 1 ".\Generated_Source\PSoC4\UART_1.h" 1
N/*******************************************************************************
N* File Name: UART_1.h
N* Version 1.10
N*
N* Description:
N*  This file provides constants and parameter values for the SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2013, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_UART_1_H)
X#if !0L
N#define CY_SCB_UART_1_H
N
N#include "cydevice_trm.h"
L 1 ".\Generated_Source\PSoC4\cydevice_trm.h" 1
N/*******************************************************************************
N* FILENAME: cydevice_trm.h
N* 
N* PSoC Creator 3.0
N*
N* DESCRIPTION:
N* This file provides all of the address values for the entire PSoC device.
N* This file is automatically generated by PSoC Creator.
N*
N********************************************************************************
N* Copyright 2008-2013, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N********************************************************************************/
N
N#if !defined(CYDEVICE_TRM_H)
X#if !0L
N#define CYDEVICE_TRM_H
N#define CYDEV_FLASH_BASE 0x00000000u
N#define CYDEV_FLASH_SIZE 0x00008000u
N#define CYREG_FLASH_DATA_MBASE 0x00000000u
N#define CYREG_FLASH_DATA_MSIZE 0x00008000u
N#define CYDEV_SFLASH_BASE 0x0ffff000u
N#define CYDEV_SFLASH_SIZE 0x00000200u
N#define CYREG_SFLASH_PROT_ROW00 0x0ffff000u
N#define CYREG_SFLASH_PROT_ROW01 0x0ffff001u
N#define CYREG_SFLASH_PROT_ROW02 0x0ffff002u
N#define CYREG_SFLASH_PROT_ROW03 0x0ffff003u
N#define CYREG_SFLASH_PROT_ROW04 0x0ffff004u
N#define CYREG_SFLASH_PROT_ROW05 0x0ffff005u
N#define CYREG_SFLASH_PROT_ROW06 0x0ffff006u
N#define CYREG_SFLASH_PROT_ROW07 0x0ffff007u
N#define CYREG_SFLASH_PROT_ROW08 0x0ffff008u
N#define CYREG_SFLASH_PROT_ROW09 0x0ffff009u
N#define CYREG_SFLASH_PROT_ROW10 0x0ffff00au
N#define CYREG_SFLASH_PROT_ROW11 0x0ffff00bu
N#define CYREG_SFLASH_PROT_ROW12 0x0ffff00cu
N#define CYREG_SFLASH_PROT_ROW13 0x0ffff00du
N#define CYREG_SFLASH_PROT_ROW14 0x0ffff00eu
N#define CYREG_SFLASH_PROT_ROW15 0x0ffff00fu
N#define CYREG_SFLASH_PROT_ROW16 0x0ffff010u
N#define CYREG_SFLASH_PROT_ROW17 0x0ffff011u
N#define CYREG_SFLASH_PROT_ROW18 0x0ffff012u
N#define CYREG_SFLASH_PROT_ROW19 0x0ffff013u
N#define CYREG_SFLASH_PROT_ROW20 0x0ffff014u
N#define CYREG_SFLASH_PROT_ROW21 0x0ffff015u
N#define CYREG_SFLASH_PROT_ROW22 0x0ffff016u
N#define CYREG_SFLASH_PROT_ROW23 0x0ffff017u
N#define CYREG_SFLASH_PROT_ROW24 0x0ffff018u
N#define CYREG_SFLASH_PROT_ROW25 0x0ffff019u
N#define CYREG_SFLASH_PROT_ROW26 0x0ffff01au
N#define CYREG_SFLASH_PROT_ROW27 0x0ffff01bu
N#define CYREG_SFLASH_PROT_ROW28 0x0ffff01cu
N#define CYREG_SFLASH_PROT_ROW29 0x0ffff01du
N#define CYREG_SFLASH_PROT_ROW30 0x0ffff01eu
N#define CYREG_SFLASH_PROT_ROW31 0x0ffff01fu
N#define CYREG_SFLASH_PROT_ROW32 0x0ffff020u
N#define CYREG_SFLASH_PROT_ROW33 0x0ffff021u
N#define CYREG_SFLASH_PROT_ROW34 0x0ffff022u
N#define CYREG_SFLASH_PROT_ROW35 0x0ffff023u
N#define CYREG_SFLASH_PROT_ROW36 0x0ffff024u
N#define CYREG_SFLASH_PROT_ROW37 0x0ffff025u
N#define CYREG_SFLASH_PROT_ROW38 0x0ffff026u
N#define CYREG_SFLASH_PROT_ROW39 0x0ffff027u
N#define CYREG_SFLASH_PROT_ROW40 0x0ffff028u
N#define CYREG_SFLASH_PROT_ROW41 0x0ffff029u
N#define CYREG_SFLASH_PROT_ROW42 0x0ffff02au
N#define CYREG_SFLASH_PROT_ROW43 0x0ffff02bu
N#define CYREG_SFLASH_PROT_ROW44 0x0ffff02cu
N#define CYREG_SFLASH_PROT_ROW45 0x0ffff02du
N#define CYREG_SFLASH_PROT_ROW46 0x0ffff02eu
N#define CYREG_SFLASH_PROT_ROW47 0x0ffff02fu
N#define CYREG_SFLASH_PROT_ROW48 0x0ffff030u
N#define CYREG_SFLASH_PROT_ROW49 0x0ffff031u
N#define CYREG_SFLASH_PROT_ROW50 0x0ffff032u
N#define CYREG_SFLASH_PROT_ROW51 0x0ffff033u
N#define CYREG_SFLASH_PROT_ROW52 0x0ffff034u
N#define CYREG_SFLASH_PROT_ROW53 0x0ffff035u
N#define CYREG_SFLASH_PROT_ROW54 0x0ffff036u
N#define CYREG_SFLASH_PROT_ROW55 0x0ffff037u
N#define CYREG_SFLASH_PROT_ROW56 0x0ffff038u
N#define CYREG_SFLASH_PROT_ROW57 0x0ffff039u
N#define CYREG_SFLASH_PROT_ROW58 0x0ffff03au
N#define CYREG_SFLASH_PROT_ROW59 0x0ffff03bu
N#define CYREG_SFLASH_PROT_ROW60 0x0ffff03cu
N#define CYREG_SFLASH_PROT_ROW61 0x0ffff03du
N#define CYREG_SFLASH_PROT_ROW62 0x0ffff03eu
N#define CYREG_SFLASH_PROT_ROW63 0x0ffff03fu
N#define CYREG_SFLASH_PROT_PROTECTION 0x0ffff07fu
N#define CYREG_SFLASH_AV_PAIRS_8B000 0x0ffff080u
N#define CYREG_SFLASH_AV_PAIRS_8B001 0x0ffff081u
N#define CYREG_SFLASH_AV_PAIRS_8B002 0x0ffff082u
N#define CYREG_SFLASH_AV_PAIRS_8B003 0x0ffff083u
N#define CYREG_SFLASH_AV_PAIRS_8B004 0x0ffff084u
N#define CYREG_SFLASH_AV_PAIRS_8B005 0x0ffff085u
N#define CYREG_SFLASH_AV_PAIRS_8B006 0x0ffff086u
N#define CYREG_SFLASH_AV_PAIRS_8B007 0x0ffff087u
N#define CYREG_SFLASH_AV_PAIRS_8B008 0x0ffff088u
N#define CYREG_SFLASH_AV_PAIRS_8B009 0x0ffff089u
N#define CYREG_SFLASH_AV_PAIRS_8B010 0x0ffff08au
N#define CYREG_SFLASH_AV_PAIRS_8B011 0x0ffff08bu
N#define CYREG_SFLASH_AV_PAIRS_8B012 0x0ffff08cu
N#define CYREG_SFLASH_AV_PAIRS_8B013 0x0ffff08du
N#define CYREG_SFLASH_AV_PAIRS_8B014 0x0ffff08eu
N#define CYREG_SFLASH_AV_PAIRS_8B015 0x0ffff08fu
N#define CYREG_SFLASH_AV_PAIRS_8B016 0x0ffff090u
N#define CYREG_SFLASH_AV_PAIRS_8B017 0x0ffff091u
N#define CYREG_SFLASH_AV_PAIRS_8B018 0x0ffff092u
N#define CYREG_SFLASH_AV_PAIRS_8B019 0x0ffff093u
N#define CYREG_SFLASH_AV_PAIRS_8B020 0x0ffff094u
N#define CYREG_SFLASH_AV_PAIRS_8B021 0x0ffff095u
N#define CYREG_SFLASH_AV_PAIRS_8B022 0x0ffff096u
N#define CYREG_SFLASH_AV_PAIRS_8B023 0x0ffff097u
N#define CYREG_SFLASH_AV_PAIRS_8B024 0x0ffff098u
N#define CYREG_SFLASH_AV_PAIRS_8B025 0x0ffff099u
N#define CYREG_SFLASH_AV_PAIRS_8B026 0x0ffff09au
N#define CYREG_SFLASH_AV_PAIRS_8B027 0x0ffff09bu
N#define CYREG_SFLASH_AV_PAIRS_8B028 0x0ffff09cu
N#define CYREG_SFLASH_AV_PAIRS_8B029 0x0ffff09du
N#define CYREG_SFLASH_AV_PAIRS_8B030 0x0ffff09eu
N#define CYREG_SFLASH_AV_PAIRS_8B031 0x0ffff09fu
N#define CYREG_SFLASH_AV_PAIRS_8B032 0x0ffff0a0u
N#define CYREG_SFLASH_AV_PAIRS_8B033 0x0ffff0a1u
N#define CYREG_SFLASH_AV_PAIRS_8B034 0x0ffff0a2u
N#define CYREG_SFLASH_AV_PAIRS_8B035 0x0ffff0a3u
N#define CYREG_SFLASH_AV_PAIRS_8B036 0x0ffff0a4u
N#define CYREG_SFLASH_AV_PAIRS_8B037 0x0ffff0a5u
N#define CYREG_SFLASH_AV_PAIRS_8B038 0x0ffff0a6u
N#define CYREG_SFLASH_AV_PAIRS_8B039 0x0ffff0a7u
N#define CYREG_SFLASH_AV_PAIRS_8B040 0x0ffff0a8u
N#define CYREG_SFLASH_AV_PAIRS_8B041 0x0ffff0a9u
N#define CYREG_SFLASH_AV_PAIRS_8B042 0x0ffff0aau
N#define CYREG_SFLASH_AV_PAIRS_8B043 0x0ffff0abu
N#define CYREG_SFLASH_AV_PAIRS_8B044 0x0ffff0acu
N#define CYREG_SFLASH_AV_PAIRS_8B045 0x0ffff0adu
N#define CYREG_SFLASH_AV_PAIRS_8B046 0x0ffff0aeu
N#define CYREG_SFLASH_AV_PAIRS_8B047 0x0ffff0afu
N#define CYREG_SFLASH_AV_PAIRS_8B048 0x0ffff0b0u
N#define CYREG_SFLASH_AV_PAIRS_8B049 0x0ffff0b1u
N#define CYREG_SFLASH_AV_PAIRS_8B050 0x0ffff0b2u
N#define CYREG_SFLASH_AV_PAIRS_8B051 0x0ffff0b3u
N#define CYREG_SFLASH_AV_PAIRS_8B052 0x0ffff0b4u
N#define CYREG_SFLASH_AV_PAIRS_8B053 0x0ffff0b5u
N#define CYREG_SFLASH_AV_PAIRS_8B054 0x0ffff0b6u
N#define CYREG_SFLASH_AV_PAIRS_8B055 0x0ffff0b7u
N#define CYREG_SFLASH_AV_PAIRS_8B056 0x0ffff0b8u
N#define CYREG_SFLASH_AV_PAIRS_8B057 0x0ffff0b9u
N#define CYREG_SFLASH_AV_PAIRS_8B058 0x0ffff0bau
N#define CYREG_SFLASH_AV_PAIRS_8B059 0x0ffff0bbu
N#define CYREG_SFLASH_AV_PAIRS_8B060 0x0ffff0bcu
N#define CYREG_SFLASH_AV_PAIRS_8B061 0x0ffff0bdu
N#define CYREG_SFLASH_AV_PAIRS_8B062 0x0ffff0beu
N#define CYREG_SFLASH_AV_PAIRS_8B063 0x0ffff0bfu
N#define CYREG_SFLASH_AV_PAIRS_8B064 0x0ffff0c0u
N#define CYREG_SFLASH_AV_PAIRS_8B065 0x0ffff0c1u
N#define CYREG_SFLASH_AV_PAIRS_8B066 0x0ffff0c2u
N#define CYREG_SFLASH_AV_PAIRS_8B067 0x0ffff0c3u
N#define CYREG_SFLASH_AV_PAIRS_8B068 0x0ffff0c4u
N#define CYREG_SFLASH_AV_PAIRS_8B069 0x0ffff0c5u
N#define CYREG_SFLASH_AV_PAIRS_8B070 0x0ffff0c6u
N#define CYREG_SFLASH_AV_PAIRS_8B071 0x0ffff0c7u
N#define CYREG_SFLASH_AV_PAIRS_8B072 0x0ffff0c8u
N#define CYREG_SFLASH_AV_PAIRS_8B073 0x0ffff0c9u
N#define CYREG_SFLASH_AV_PAIRS_8B074 0x0ffff0cau
N#define CYREG_SFLASH_AV_PAIRS_8B075 0x0ffff0cbu
N#define CYREG_SFLASH_AV_PAIRS_8B076 0x0ffff0ccu
N#define CYREG_SFLASH_AV_PAIRS_8B077 0x0ffff0cdu
N#define CYREG_SFLASH_AV_PAIRS_8B078 0x0ffff0ceu
N#define CYREG_SFLASH_AV_PAIRS_8B079 0x0ffff0cfu
N#define CYREG_SFLASH_AV_PAIRS_8B080 0x0ffff0d0u
N#define CYREG_SFLASH_AV_PAIRS_8B081 0x0ffff0d1u
N#define CYREG_SFLASH_AV_PAIRS_8B082 0x0ffff0d2u
N#define CYREG_SFLASH_AV_PAIRS_8B083 0x0ffff0d3u
N#define CYREG_SFLASH_AV_PAIRS_8B084 0x0ffff0d4u
N#define CYREG_SFLASH_AV_PAIRS_8B085 0x0ffff0d5u
N#define CYREG_SFLASH_AV_PAIRS_8B086 0x0ffff0d6u
N#define CYREG_SFLASH_AV_PAIRS_8B087 0x0ffff0d7u
N#define CYREG_SFLASH_AV_PAIRS_8B088 0x0ffff0d8u
N#define CYREG_SFLASH_AV_PAIRS_8B089 0x0ffff0d9u
N#define CYREG_SFLASH_AV_PAIRS_8B090 0x0ffff0dau
N#define CYREG_SFLASH_AV_PAIRS_8B091 0x0ffff0dbu
N#define CYREG_SFLASH_AV_PAIRS_8B092 0x0ffff0dcu
N#define CYREG_SFLASH_AV_PAIRS_8B093 0x0ffff0ddu
N#define CYREG_SFLASH_AV_PAIRS_8B094 0x0ffff0deu
N#define CYREG_SFLASH_AV_PAIRS_8B095 0x0ffff0dfu
N#define CYREG_SFLASH_AV_PAIRS_8B096 0x0ffff0e0u
N#define CYREG_SFLASH_AV_PAIRS_8B097 0x0ffff0e1u
N#define CYREG_SFLASH_AV_PAIRS_8B098 0x0ffff0e2u
N#define CYREG_SFLASH_AV_PAIRS_8B099 0x0ffff0e3u
N#define CYREG_SFLASH_AV_PAIRS_8B100 0x0ffff0e4u
N#define CYREG_SFLASH_AV_PAIRS_8B101 0x0ffff0e5u
N#define CYREG_SFLASH_AV_PAIRS_8B102 0x0ffff0e6u
N#define CYREG_SFLASH_AV_PAIRS_8B103 0x0ffff0e7u
N#define CYREG_SFLASH_AV_PAIRS_8B104 0x0ffff0e8u
N#define CYREG_SFLASH_AV_PAIRS_8B105 0x0ffff0e9u
N#define CYREG_SFLASH_AV_PAIRS_8B106 0x0ffff0eau
N#define CYREG_SFLASH_AV_PAIRS_8B107 0x0ffff0ebu
N#define CYREG_SFLASH_AV_PAIRS_8B108 0x0ffff0ecu
N#define CYREG_SFLASH_AV_PAIRS_8B109 0x0ffff0edu
N#define CYREG_SFLASH_AV_PAIRS_8B110 0x0ffff0eeu
N#define CYREG_SFLASH_AV_PAIRS_8B111 0x0ffff0efu
N#define CYREG_SFLASH_AV_PAIRS_8B112 0x0ffff0f0u
N#define CYREG_SFLASH_AV_PAIRS_8B113 0x0ffff0f1u
N#define CYREG_SFLASH_AV_PAIRS_8B114 0x0ffff0f2u
N#define CYREG_SFLASH_AV_PAIRS_8B115 0x0ffff0f3u
N#define CYREG_SFLASH_AV_PAIRS_8B116 0x0ffff0f4u
N#define CYREG_SFLASH_AV_PAIRS_8B117 0x0ffff0f5u
N#define CYREG_SFLASH_AV_PAIRS_8B118 0x0ffff0f6u
N#define CYREG_SFLASH_AV_PAIRS_8B119 0x0ffff0f7u
N#define CYREG_SFLASH_AV_PAIRS_8B120 0x0ffff0f8u
N#define CYREG_SFLASH_AV_PAIRS_8B121 0x0ffff0f9u
N#define CYREG_SFLASH_AV_PAIRS_8B122 0x0ffff0fau
N#define CYREG_SFLASH_AV_PAIRS_8B123 0x0ffff0fbu
N#define CYREG_SFLASH_AV_PAIRS_8B124 0x0ffff0fcu
N#define CYREG_SFLASH_AV_PAIRS_8B125 0x0ffff0fdu
N#define CYREG_SFLASH_AV_PAIRS_8B126 0x0ffff0feu
N#define CYREG_SFLASH_AV_PAIRS_8B127 0x0ffff0ffu
N#define CYREG_SFLASH_AV_PAIRS_32B00 0x0ffff100u
N#define CYREG_SFLASH_AV_PAIRS_32B01 0x0ffff104u
N#define CYREG_SFLASH_AV_PAIRS_32B02 0x0ffff108u
N#define CYREG_SFLASH_AV_PAIRS_32B03 0x0ffff10cu
N#define CYREG_SFLASH_AV_PAIRS_32B04 0x0ffff110u
N#define CYREG_SFLASH_AV_PAIRS_32B05 0x0ffff114u
N#define CYREG_SFLASH_AV_PAIRS_32B06 0x0ffff118u
N#define CYREG_SFLASH_AV_PAIRS_32B07 0x0ffff11cu
N#define CYREG_SFLASH_AV_PAIRS_32B08 0x0ffff120u
N#define CYREG_SFLASH_AV_PAIRS_32B09 0x0ffff124u
N#define CYREG_SFLASH_AV_PAIRS_32B10 0x0ffff128u
N#define CYREG_SFLASH_AV_PAIRS_32B11 0x0ffff12cu
N#define CYREG_SFLASH_AV_PAIRS_32B12 0x0ffff130u
N#define CYREG_SFLASH_AV_PAIRS_32B13 0x0ffff134u
N#define CYREG_SFLASH_AV_PAIRS_32B14 0x0ffff138u
N#define CYREG_SFLASH_AV_PAIRS_32B15 0x0ffff13cu
N#define CYREG_SFLASH_CPUSS_WOUNDING 0x0ffff140u
N#define CYREG_SFLASH_SILICON_ID 0x0ffff144u
N#define CYREG_SFLASH_CPUSS_PRIV_RAM 0x0ffff148u
N#define CYREG_SFLASH_CPUSS_PRIV_FLASH 0x0ffff14cu
N#define CYREG_SFLASH_HIB_KEY_DELAY 0x0ffff150u
N#define CYREG_SFLASH_DPSLP_KEY_DELAY 0x0ffff152u
N#define CYREG_SFLASH_SWD_CONFIG 0x0ffff154u
N#define CYREG_SFLASH_SWD_LISTEN 0x0ffff158u
N#define CYREG_SFLASH_FLASH_START 0x0ffff15cu
N#define CYREG_SFLASH_CSD_TRIM1_HVIDAC 0x0ffff160u
N#define CYREG_SFLASH_CSD_TRIM2_HVIDAC 0x0ffff161u
N#define CYREG_SFLASH_CSD_TRIM1_CSD 0x0ffff162u
N#define CYREG_SFLASH_CSD_TRIM2_CSD 0x0ffff163u
N#define CYREG_SFLASH_SAR_TEMP_MULTIPLIER 0x0ffff164u
N#define CYREG_SFLASH_SAR_TEMP_OFFSET 0x0ffff166u
N#define CYREG_SFLASH_SKIP_CHECKSUM 0x0ffff169u
N#define CYREG_SFLASH_PROT_VIRGINKEY0 0x0ffff170u
N#define CYREG_SFLASH_PROT_VIRGINKEY1 0x0ffff171u
N#define CYREG_SFLASH_PROT_VIRGINKEY2 0x0ffff172u
N#define CYREG_SFLASH_PROT_VIRGINKEY3 0x0ffff173u
N#define CYREG_SFLASH_PROT_VIRGINKEY4 0x0ffff174u
N#define CYREG_SFLASH_PROT_VIRGINKEY5 0x0ffff175u
N#define CYREG_SFLASH_PROT_VIRGINKEY6 0x0ffff176u
N#define CYREG_SFLASH_PROT_VIRGINKEY7 0x0ffff177u
N#define CYREG_SFLASH_DIE_LOT0 0x0ffff178u
N#define CYREG_SFLASH_DIE_LOT1 0x0ffff179u
N#define CYREG_SFLASH_DIE_LOT2 0x0ffff17au
N#define CYREG_SFLASH_DIE_WAFER 0x0ffff17bu
N#define CYREG_SFLASH_DIE_X 0x0ffff17cu
N#define CYREG_SFLASH_DIE_Y 0x0ffff17du
N#define CYREG_SFLASH_DIE_SORT 0x0ffff17eu
N#define CYREG_SFLASH_DIE_MINOR 0x0ffff17fu
N#define CYREG_SFLASH_PE_TE_DATA00 0x0ffff180u
N#define CYREG_SFLASH_PE_TE_DATA01 0x0ffff181u
N#define CYREG_SFLASH_PE_TE_DATA02 0x0ffff182u
N#define CYREG_SFLASH_PE_TE_DATA03 0x0ffff183u
N#define CYREG_SFLASH_PE_TE_DATA04 0x0ffff184u
N#define CYREG_SFLASH_PE_TE_DATA05 0x0ffff185u
N#define CYREG_SFLASH_PE_TE_DATA06 0x0ffff186u
N#define CYREG_SFLASH_PE_TE_DATA07 0x0ffff187u
N#define CYREG_SFLASH_PE_TE_DATA08 0x0ffff188u
N#define CYREG_SFLASH_PE_TE_DATA09 0x0ffff189u
N#define CYREG_SFLASH_PE_TE_DATA10 0x0ffff18au
N#define CYREG_SFLASH_PE_TE_DATA11 0x0ffff18bu
N#define CYREG_SFLASH_PE_TE_DATA12 0x0ffff18cu
N#define CYREG_SFLASH_PE_TE_DATA13 0x0ffff18du
N#define CYREG_SFLASH_PE_TE_DATA14 0x0ffff18eu
N#define CYREG_SFLASH_PE_TE_DATA15 0x0ffff18fu
N#define CYREG_SFLASH_PE_TE_DATA16 0x0ffff190u
N#define CYREG_SFLASH_PE_TE_DATA17 0x0ffff191u
N#define CYREG_SFLASH_PE_TE_DATA18 0x0ffff192u
N#define CYREG_SFLASH_PE_TE_DATA19 0x0ffff193u
N#define CYREG_SFLASH_PE_TE_DATA20 0x0ffff194u
N#define CYREG_SFLASH_PE_TE_DATA21 0x0ffff195u
N#define CYREG_SFLASH_PE_TE_DATA22 0x0ffff196u
N#define CYREG_SFLASH_PE_TE_DATA23 0x0ffff197u
N#define CYREG_SFLASH_PE_TE_DATA24 0x0ffff198u
N#define CYREG_SFLASH_PE_TE_DATA25 0x0ffff199u
N#define CYREG_SFLASH_PE_TE_DATA26 0x0ffff19au
N#define CYREG_SFLASH_PE_TE_DATA27 0x0ffff19bu
N#define CYREG_SFLASH_PE_TE_DATA28 0x0ffff19cu
N#define CYREG_SFLASH_PE_TE_DATA29 0x0ffff19du
N#define CYREG_SFLASH_PE_TE_DATA30 0x0ffff19eu
N#define CYREG_SFLASH_PE_TE_DATA31 0x0ffff19fu
N#define CYREG_SFLASH_PP 0x0ffff1a0u
N#define CYREG_SFLASH_E 0x0ffff1a4u
N#define CYREG_SFLASH_P 0x0ffff1a8u
N#define CYREG_SFLASH_EA_E 0x0ffff1acu
N#define CYREG_SFLASH_EA_P 0x0ffff1b0u
N#define CYREG_SFLASH_ES_E 0x0ffff1b4u
N#define CYREG_SFLASH_ES_P_EO 0x0ffff1b8u
N#define CYREG_SFLASH_E_VCTAT 0x0ffff1bcu
N#define CYREG_SFLASH_P_VCTAT 0x0ffff1bdu
N#define CYREG_SFLASH_MARGIN 0x0ffff1beu
N#define CYREG_SFLASH_SPCIF_TRIM1 0x0ffff1bfu
N#define CYREG_SFLASH_IMO_MAXF0 0x0ffff1c0u
N#define CYREG_SFLASH_IMO_ABS0 0x0ffff1c1u
N#define CYREG_SFLASH_IMO_TMPCO0 0x0ffff1c2u
N#define CYREG_SFLASH_IMO_MAXF1 0x0ffff1c3u
N#define CYREG_SFLASH_IMO_ABS1 0x0ffff1c4u
N#define CYREG_SFLASH_IMO_TMPCO1 0x0ffff1c5u
N#define CYREG_SFLASH_IMO_MAXF2 0x0ffff1c6u
N#define CYREG_SFLASH_IMO_ABS2 0x0ffff1c7u
N#define CYREG_SFLASH_IMO_TMPCO2 0x0ffff1c8u
N#define CYREG_SFLASH_IMO_MAXF3 0x0ffff1c9u
N#define CYREG_SFLASH_IMO_ABS3 0x0ffff1cau
N#define CYREG_SFLASH_IMO_TMPCO3 0x0ffff1cbu
N#define CYREG_SFLASH_IMO_ABS4 0x0ffff1ccu
N#define CYREG_SFLASH_IMO_TMPCO4 0x0ffff1cdu
N#define CYREG_SFLASH_IMO_TRIM00 0x0ffff1d0u
N#define CYREG_SFLASH_IMO_TRIM01 0x0ffff1d1u
N#define CYREG_SFLASH_IMO_TRIM02 0x0ffff1d2u
N#define CYREG_SFLASH_IMO_TRIM03 0x0ffff1d3u
N#define CYREG_SFLASH_IMO_TRIM04 0x0ffff1d4u
N#define CYREG_SFLASH_IMO_TRIM05 0x0ffff1d5u
N#define CYREG_SFLASH_IMO_TRIM06 0x0ffff1d6u
N#define CYREG_SFLASH_IMO_TRIM07 0x0ffff1d7u
N#define CYREG_SFLASH_IMO_TRIM08 0x0ffff1d8u
N#define CYREG_SFLASH_IMO_TRIM09 0x0ffff1d9u
N#define CYREG_SFLASH_IMO_TRIM10 0x0ffff1dau
N#define CYREG_SFLASH_IMO_TRIM11 0x0ffff1dbu
N#define CYREG_SFLASH_IMO_TRIM12 0x0ffff1dcu
N#define CYREG_SFLASH_IMO_TRIM13 0x0ffff1ddu
N#define CYREG_SFLASH_IMO_TRIM14 0x0ffff1deu
N#define CYREG_SFLASH_IMO_TRIM15 0x0ffff1dfu
N#define CYREG_SFLASH_IMO_TRIM16 0x0ffff1e0u
N#define CYREG_SFLASH_IMO_TRIM17 0x0ffff1e1u
N#define CYREG_SFLASH_IMO_TRIM18 0x0ffff1e2u
N#define CYREG_SFLASH_IMO_TRIM19 0x0ffff1e3u
N#define CYREG_SFLASH_IMO_TRIM20 0x0ffff1e4u
N#define CYREG_SFLASH_IMO_TRIM21 0x0ffff1e5u
N#define CYREG_SFLASH_IMO_TRIM22 0x0ffff1e6u
N#define CYREG_SFLASH_IMO_TRIM23 0x0ffff1e7u
N#define CYREG_SFLASH_IMO_TRIM24 0x0ffff1e8u
N#define CYREG_SFLASH_IMO_TRIM25 0x0ffff1e9u
N#define CYREG_SFLASH_IMO_TRIM26 0x0ffff1eau
N#define CYREG_SFLASH_IMO_TRIM27 0x0ffff1ebu
N#define CYREG_SFLASH_IMO_TRIM28 0x0ffff1ecu
N#define CYREG_SFLASH_IMO_TRIM29 0x0ffff1edu
N#define CYREG_SFLASH_IMO_TRIM30 0x0ffff1eeu
N#define CYREG_SFLASH_IMO_TRIM31 0x0ffff1efu
N#define CYREG_SFLASH_IMO_TRIM32 0x0ffff1f0u
N#define CYREG_SFLASH_IMO_TRIM33 0x0ffff1f1u
N#define CYREG_SFLASH_IMO_TRIM34 0x0ffff1f2u
N#define CYREG_SFLASH_IMO_TRIM35 0x0ffff1f3u
N#define CYREG_SFLASH_IMO_TRIM36 0x0ffff1f4u
N#define CYREG_SFLASH_IMO_TRIM37 0x0ffff1f5u
N#define CYREG_SFLASH_IMO_TRIM38 0x0ffff1f6u
N#define CYREG_SFLASH_IMO_TRIM39 0x0ffff1f7u
N#define CYREG_SFLASH_IMO_TRIM40 0x0ffff1f8u
N#define CYREG_SFLASH_IMO_TRIM41 0x0ffff1f9u
N#define CYREG_SFLASH_IMO_TRIM42 0x0ffff1fau
N#define CYREG_SFLASH_IMO_TRIM43 0x0ffff1fbu
N#define CYREG_SFLASH_IMO_TRIM44 0x0ffff1fcu
N#define CYREG_SFLASH_IMO_TRIM45 0x0ffff1fdu
N#define CYREG_SFLASH_CHECKSUM 0x0ffff1feu
N#define CYDEV_SROM_BASE 0x10000000u
N#define CYDEV_SROM_SIZE 0x00001000u
N#define CYREG_SROM_DATA_MBASE 0x10000000u
N#define CYREG_SROM_DATA_MSIZE 0x00001000u
N#define CYDEV_SRAM_BASE 0x20000000u
N#define CYDEV_SRAM_SIZE 0x00001000u
N#define CYREG_SRAM_DATA_MBASE 0x20000000u
N#define CYREG_SRAM_DATA_MSIZE 0x00001000u
N#define CYDEV_CPUSS_BASE 0x40000000u
N#define CYDEV_CPUSS_SIZE 0x00010000u
N#define CYREG_CPUSS_CONFIG 0x40000000u
N#define CYREG_CPUSS_SYSREQ 0x40000004u
N#define CYREG_CPUSS_SYSARG 0x40000008u
N#define CYREG_CPUSS_PROTECTION 0x4000000cu
N#define CYREG_CPUSS_PRIV_ROM 0x40000010u
N#define CYREG_CPUSS_PRIV_RAM 0x40000014u
N#define CYREG_CPUSS_PRIV_FLASH 0x40000018u
N#define CYREG_CPUSS_WOUNDING 0x4000001cu
N#define CYREG_CPUSS_INTR_SELECT 0x40000020u
N#define CYDEV_HSIOM_BASE 0x40010000u
N#define CYDEV_HSIOM_SIZE 0x00001000u
N#define CYREG_HSIOM_PORT_SEL0 0x40010000u
N#define CYREG_HSIOM_PORT_SEL1 0x40010004u
N#define CYREG_HSIOM_PORT_SEL2 0x40010008u
N#define CYREG_HSIOM_PORT_SEL3 0x4001000cu
N#define CYREG_HSIOM_PORT_SEL4 0x40010010u
N#define CYDEV_CLK_BASE 0x40020000u
N#define CYDEV_CLK_SIZE 0x00010000u
N#define CYREG_CLK_DIVIDER_A00 0x40020000u
N#define CYREG_CLK_DIVIDER_A01 0x40020004u
N#define CYREG_CLK_DIVIDER_A02 0x40020008u
N#define CYREG_CLK_DIVIDER_B00 0x40020040u
N#define CYREG_CLK_DIVIDER_B01 0x40020044u
N#define CYREG_CLK_DIVIDER_B02 0x40020048u
N#define CYREG_CLK_DIVIDER_C00 0x40020080u
N#define CYREG_CLK_DIVIDER_C01 0x40020084u
N#define CYREG_CLK_DIVIDER_C02 0x40020088u
N#define CYREG_CLK_DIVIDER_FRAC_A00 0x40020100u
N#define CYREG_CLK_DIVIDER_FRAC_B00 0x40020140u
N#define CYREG_CLK_DIVIDER_FRAC_C00 0x40020180u
N#define CYREG_CLK_SELECT00 0x40020200u
N#define CYREG_CLK_SELECT01 0x40020204u
N#define CYREG_CLK_SELECT02 0x40020208u
N#define CYREG_CLK_SELECT03 0x4002020cu
N#define CYREG_CLK_SELECT04 0x40020210u
N#define CYREG_CLK_SELECT05 0x40020214u
N#define CYREG_CLK_SELECT06 0x40020218u
N#define CYREG_CLK_SELECT07 0x4002021cu
N#define CYREG_CLK_SELECT08 0x40020220u
N#define CYREG_CLK_SELECT09 0x40020224u
N#define CYREG_CLK_SELECT10 0x40020228u
N#define CYREG_CLK_SELECT11 0x4002022cu
N#define CYREG_CLK_SELECT12 0x40020230u
N#define CYREG_CLK_SELECT13 0x40020234u
N#define CYREG_CLK_SELECT14 0x40020238u
N#define CYREG_CLK_SELECT15 0x4002023cu
N#define CYDEV_TST_BASE 0x40030000u
N#define CYDEV_TST_SIZE 0x00010000u
N#define CYREG_TST_MODE 0x40030014u
N#define CYDEV_PRT0_BASE 0x40040000u
N#define CYDEV_PRT0_SIZE 0x00000100u
N#define CYREG_PRT0_DR 0x40040000u
N#define CYREG_PRT0_PS 0x40040004u
N#define CYREG_PRT0_PC 0x40040008u
N#define CYREG_PRT0_INTCFG 0x4004000cu
N#define CYREG_PRT0_INTSTAT 0x40040010u
N#define CYREG_PRT0_PC2 0x40040018u
N#define CYDEV_PRT1_BASE 0x40040100u
N#define CYDEV_PRT1_SIZE 0x00000100u
N#define CYREG_PRT1_DR 0x40040100u
N#define CYREG_PRT1_PS 0x40040104u
N#define CYREG_PRT1_PC 0x40040108u
N#define CYREG_PRT1_INTCFG 0x4004010cu
N#define CYREG_PRT1_INTSTAT 0x40040110u
N#define CYREG_PRT1_PC2 0x40040118u
N#define CYDEV_PRT2_BASE 0x40040200u
N#define CYDEV_PRT2_SIZE 0x00000100u
N#define CYREG_PRT2_DR 0x40040200u
N#define CYREG_PRT2_PS 0x40040204u
N#define CYREG_PRT2_PC 0x40040208u
N#define CYREG_PRT2_INTCFG 0x4004020cu
N#define CYREG_PRT2_INTSTAT 0x40040210u
N#define CYREG_PRT2_PC2 0x40040218u
N#define CYDEV_PRT3_BASE 0x40040300u
N#define CYDEV_PRT3_SIZE 0x00000100u
N#define CYREG_PRT3_DR 0x40040300u
N#define CYREG_PRT3_PS 0x40040304u
N#define CYREG_PRT3_PC 0x40040308u
N#define CYREG_PRT3_INTCFG 0x4004030cu
N#define CYREG_PRT3_INTSTAT 0x40040310u
N#define CYREG_PRT3_PC2 0x40040318u
N#define CYDEV_PRT4_BASE 0x40040400u
N#define CYDEV_PRT4_SIZE 0x00000100u
N#define CYREG_PRT4_DR 0x40040400u
N#define CYREG_PRT4_PS 0x40040404u
N#define CYREG_PRT4_PC 0x40040408u
N#define CYREG_PRT4_INTCFG 0x4004040cu
N#define CYREG_PRT4_INTSTAT 0x40040410u
N#define CYREG_PRT4_PC2 0x40040418u
N#define CYDEV_TCPWM_BASE 0x40050000u
N#define CYDEV_TCPWM_SIZE 0x00001000u
N#define CYREG_TCPWM_CTRL 0x40050000u
N#define CYREG_TCPWM_CMD 0x40050008u
N#define CYREG_TCPWM_INTR_CAUSE 0x4005000cu
N#define CYDEV_TCPWM_CNT0_BASE 0x40050100u
N#define CYDEV_TCPWM_CNT0_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT0_CTRL 0x40050100u
N#define CYREG_TCPWM_CNT0_STATUS 0x40050104u
N#define CYREG_TCPWM_CNT0_COUNTER 0x40050108u
N#define CYREG_TCPWM_CNT0_CC 0x4005010cu
N#define CYREG_TCPWM_CNT0_CC_BUFF 0x40050110u
N#define CYREG_TCPWM_CNT0_PERIOD 0x40050114u
N#define CYREG_TCPWM_CNT0_PERIOD_BUFF 0x40050118u
N#define CYREG_TCPWM_CNT0_TR_CTRL0 0x40050120u
N#define CYREG_TCPWM_CNT0_TR_CTRL1 0x40050124u
N#define CYREG_TCPWM_CNT0_TR_CTRL2 0x40050128u
N#define CYREG_TCPWM_CNT0_INTR 0x40050130u
N#define CYREG_TCPWM_CNT0_INTR_SET 0x40050134u
N#define CYREG_TCPWM_CNT0_INTR_MASK 0x40050138u
N#define CYREG_TCPWM_CNT0_INTR_MASKED 0x4005013cu
N#define CYDEV_TCPWM_CNT1_BASE 0x40050140u
N#define CYDEV_TCPWM_CNT1_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT1_CTRL 0x40050140u
N#define CYREG_TCPWM_CNT1_STATUS 0x40050144u
N#define CYREG_TCPWM_CNT1_COUNTER 0x40050148u
N#define CYREG_TCPWM_CNT1_CC 0x4005014cu
N#define CYREG_TCPWM_CNT1_CC_BUFF 0x40050150u
N#define CYREG_TCPWM_CNT1_PERIOD 0x40050154u
N#define CYREG_TCPWM_CNT1_PERIOD_BUFF 0x40050158u
N#define CYREG_TCPWM_CNT1_TR_CTRL0 0x40050160u
N#define CYREG_TCPWM_CNT1_TR_CTRL1 0x40050164u
N#define CYREG_TCPWM_CNT1_TR_CTRL2 0x40050168u
N#define CYREG_TCPWM_CNT1_INTR 0x40050170u
N#define CYREG_TCPWM_CNT1_INTR_SET 0x40050174u
N#define CYREG_TCPWM_CNT1_INTR_MASK 0x40050178u
N#define CYREG_TCPWM_CNT1_INTR_MASKED 0x4005017cu
N#define CYDEV_TCPWM_CNT2_BASE 0x40050180u
N#define CYDEV_TCPWM_CNT2_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT2_CTRL 0x40050180u
N#define CYREG_TCPWM_CNT2_STATUS 0x40050184u
N#define CYREG_TCPWM_CNT2_COUNTER 0x40050188u
N#define CYREG_TCPWM_CNT2_CC 0x4005018cu
N#define CYREG_TCPWM_CNT2_CC_BUFF 0x40050190u
N#define CYREG_TCPWM_CNT2_PERIOD 0x40050194u
N#define CYREG_TCPWM_CNT2_PERIOD_BUFF 0x40050198u
N#define CYREG_TCPWM_CNT2_TR_CTRL0 0x400501a0u
N#define CYREG_TCPWM_CNT2_TR_CTRL1 0x400501a4u
N#define CYREG_TCPWM_CNT2_TR_CTRL2 0x400501a8u
N#define CYREG_TCPWM_CNT2_INTR 0x400501b0u
N#define CYREG_TCPWM_CNT2_INTR_SET 0x400501b4u
N#define CYREG_TCPWM_CNT2_INTR_MASK 0x400501b8u
N#define CYREG_TCPWM_CNT2_INTR_MASKED 0x400501bcu
N#define CYDEV_TCPWM_CNT3_BASE 0x400501c0u
N#define CYDEV_TCPWM_CNT3_SIZE 0x00000040u
N#define CYREG_TCPWM_CNT3_CTRL 0x400501c0u
N#define CYREG_TCPWM_CNT3_STATUS 0x400501c4u
N#define CYREG_TCPWM_CNT3_COUNTER 0x400501c8u
N#define CYREG_TCPWM_CNT3_CC 0x400501ccu
N#define CYREG_TCPWM_CNT3_CC_BUFF 0x400501d0u
N#define CYREG_TCPWM_CNT3_PERIOD 0x400501d4u
N#define CYREG_TCPWM_CNT3_PERIOD_BUFF 0x400501d8u
N#define CYREG_TCPWM_CNT3_TR_CTRL0 0x400501e0u
N#define CYREG_TCPWM_CNT3_TR_CTRL1 0x400501e4u
N#define CYREG_TCPWM_CNT3_TR_CTRL2 0x400501e8u
N#define CYREG_TCPWM_CNT3_INTR 0x400501f0u
N#define CYREG_TCPWM_CNT3_INTR_SET 0x400501f4u
N#define CYREG_TCPWM_CNT3_INTR_MASK 0x400501f8u
N#define CYREG_TCPWM_CNT3_INTR_MASKED 0x400501fcu
N#define CYDEV_SCB0_BASE 0x40060000u
N#define CYDEV_SCB0_SIZE 0x00010000u
N#define CYREG_SCB0_CTRL 0x40060000u
N#define CYREG_SCB0_STATUS 0x40060004u
N#define CYREG_SCB0_SPI_CTRL 0x40060020u
N#define CYREG_SCB0_SPI_STATUS 0x40060024u
N#define CYREG_SCB0_UART_CTRL 0x40060040u
N#define CYREG_SCB0_UART_TX_CTRL 0x40060044u
N#define CYREG_SCB0_UART_RX_CTRL 0x40060048u
N#define CYREG_SCB0_UART_RX_STATUS 0x4006004cu
N#define CYREG_SCB0_I2C_CTRL 0x40060060u
N#define CYREG_SCB0_I2C_STATUS 0x40060064u
N#define CYREG_SCB0_I2C_M_CMD 0x40060068u
N#define CYREG_SCB0_I2C_S_CMD 0x4006006cu
N#define CYREG_SCB0_I2C_CFG 0x40060070u
N#define CYREG_SCB0_BIST_CONTROL 0x40060100u
N#define CYREG_SCB0_BIST_DATA 0x40060104u
N#define CYREG_SCB0_TX_CTRL 0x40060200u
N#define CYREG_SCB0_TX_FIFO_CTRL 0x40060204u
N#define CYREG_SCB0_TX_FIFO_STATUS 0x40060208u
N#define CYREG_SCB0_TX_FIFO_WR 0x40060240u
N#define CYREG_SCB0_RX_CTRL 0x40060300u
N#define CYREG_SCB0_RX_FIFO_CTRL 0x40060304u
N#define CYREG_SCB0_RX_FIFO_STATUS 0x40060308u
N#define CYREG_SCB0_RX_MATCH 0x40060310u
N#define CYREG_SCB0_RX_FIFO_RD 0x40060340u
N#define CYREG_SCB0_RX_FIFO_RD_SILENT 0x40060344u
N#define CYREG_SCB0_EZ_DATA00 0x40060400u
N#define CYREG_SCB0_EZ_DATA01 0x40060404u
N#define CYREG_SCB0_EZ_DATA02 0x40060408u
N#define CYREG_SCB0_EZ_DATA03 0x4006040cu
N#define CYREG_SCB0_EZ_DATA04 0x40060410u
N#define CYREG_SCB0_EZ_DATA05 0x40060414u
N#define CYREG_SCB0_EZ_DATA06 0x40060418u
N#define CYREG_SCB0_EZ_DATA07 0x4006041cu
N#define CYREG_SCB0_EZ_DATA08 0x40060420u
N#define CYREG_SCB0_EZ_DATA09 0x40060424u
N#define CYREG_SCB0_EZ_DATA10 0x40060428u
N#define CYREG_SCB0_EZ_DATA11 0x4006042cu
N#define CYREG_SCB0_EZ_DATA12 0x40060430u
N#define CYREG_SCB0_EZ_DATA13 0x40060434u
N#define CYREG_SCB0_EZ_DATA14 0x40060438u
N#define CYREG_SCB0_EZ_DATA15 0x4006043cu
N#define CYREG_SCB0_EZ_DATA16 0x40060440u
N#define CYREG_SCB0_EZ_DATA17 0x40060444u
N#define CYREG_SCB0_EZ_DATA18 0x40060448u
N#define CYREG_SCB0_EZ_DATA19 0x4006044cu
N#define CYREG_SCB0_EZ_DATA20 0x40060450u
N#define CYREG_SCB0_EZ_DATA21 0x40060454u
N#define CYREG_SCB0_EZ_DATA22 0x40060458u
N#define CYREG_SCB0_EZ_DATA23 0x4006045cu
N#define CYREG_SCB0_EZ_DATA24 0x40060460u
N#define CYREG_SCB0_EZ_DATA25 0x40060464u
N#define CYREG_SCB0_EZ_DATA26 0x40060468u
N#define CYREG_SCB0_EZ_DATA27 0x4006046cu
N#define CYREG_SCB0_EZ_DATA28 0x40060470u
N#define CYREG_SCB0_EZ_DATA29 0x40060474u
N#define CYREG_SCB0_EZ_DATA30 0x40060478u
N#define CYREG_SCB0_EZ_DATA31 0x4006047cu
N#define CYREG_SCB0_INTR_CAUSE 0x40060e00u
N#define CYREG_SCB0_INTR_I2C_EC 0x40060e80u
N#define CYREG_SCB0_INTR_I2C_EC_MASK 0x40060e88u
N#define CYREG_SCB0_INTR_I2C_EC_MASKED 0x40060e8cu
N#define CYREG_SCB0_INTR_SPI_EC 0x40060ec0u
N#define CYREG_SCB0_INTR_SPI_EC_MASK 0x40060ec8u
N#define CYREG_SCB0_INTR_SPI_EC_MASKED 0x40060eccu
N#define CYREG_SCB0_INTR_M 0x40060f00u
N#define CYREG_SCB0_INTR_M_SET 0x40060f04u
N#define CYREG_SCB0_INTR_M_MASK 0x40060f08u
N#define CYREG_SCB0_INTR_M_MASKED 0x40060f0cu
N#define CYREG_SCB0_INTR_S 0x40060f40u
N#define CYREG_SCB0_INTR_S_SET 0x40060f44u
N#define CYREG_SCB0_INTR_S_MASK 0x40060f48u
N#define CYREG_SCB0_INTR_S_MASKED 0x40060f4cu
N#define CYREG_SCB0_INTR_TX 0x40060f80u
N#define CYREG_SCB0_INTR_TX_SET 0x40060f84u
N#define CYREG_SCB0_INTR_TX_MASK 0x40060f88u
N#define CYREG_SCB0_INTR_TX_MASKED 0x40060f8cu
N#define CYREG_SCB0_INTR_RX 0x40060fc0u
N#define CYREG_SCB0_INTR_RX_SET 0x40060fc4u
N#define CYREG_SCB0_INTR_RX_MASK 0x40060fc8u
N#define CYREG_SCB0_INTR_RX_MASKED 0x40060fccu
N#define CYDEV_SCB1_BASE 0x40070000u
N#define CYDEV_SCB1_SIZE 0x00010000u
N#define CYREG_SCB1_CTRL 0x40070000u
N#define CYREG_SCB1_STATUS 0x40070004u
N#define CYREG_SCB1_SPI_CTRL 0x40070020u
N#define CYREG_SCB1_SPI_STATUS 0x40070024u
N#define CYREG_SCB1_UART_CTRL 0x40070040u
N#define CYREG_SCB1_UART_TX_CTRL 0x40070044u
N#define CYREG_SCB1_UART_RX_CTRL 0x40070048u
N#define CYREG_SCB1_UART_RX_STATUS 0x4007004cu
N#define CYREG_SCB1_I2C_CTRL 0x40070060u
N#define CYREG_SCB1_I2C_STATUS 0x40070064u
N#define CYREG_SCB1_I2C_M_CMD 0x40070068u
N#define CYREG_SCB1_I2C_S_CMD 0x4007006cu
N#define CYREG_SCB1_I2C_CFG 0x40070070u
N#define CYREG_SCB1_BIST_CONTROL 0x40070100u
N#define CYREG_SCB1_BIST_DATA 0x40070104u
N#define CYREG_SCB1_TX_CTRL 0x40070200u
N#define CYREG_SCB1_TX_FIFO_CTRL 0x40070204u
N#define CYREG_SCB1_TX_FIFO_STATUS 0x40070208u
N#define CYREG_SCB1_TX_FIFO_WR 0x40070240u
N#define CYREG_SCB1_RX_CTRL 0x40070300u
N#define CYREG_SCB1_RX_FIFO_CTRL 0x40070304u
N#define CYREG_SCB1_RX_FIFO_STATUS 0x40070308u
N#define CYREG_SCB1_RX_MATCH 0x40070310u
N#define CYREG_SCB1_RX_FIFO_RD 0x40070340u
N#define CYREG_SCB1_RX_FIFO_RD_SILENT 0x40070344u
N#define CYREG_SCB1_EZ_DATA00 0x40070400u
N#define CYREG_SCB1_EZ_DATA01 0x40070404u
N#define CYREG_SCB1_EZ_DATA02 0x40070408u
N#define CYREG_SCB1_EZ_DATA03 0x4007040cu
N#define CYREG_SCB1_EZ_DATA04 0x40070410u
N#define CYREG_SCB1_EZ_DATA05 0x40070414u
N#define CYREG_SCB1_EZ_DATA06 0x40070418u
N#define CYREG_SCB1_EZ_DATA07 0x4007041cu
N#define CYREG_SCB1_EZ_DATA08 0x40070420u
N#define CYREG_SCB1_EZ_DATA09 0x40070424u
N#define CYREG_SCB1_EZ_DATA10 0x40070428u
N#define CYREG_SCB1_EZ_DATA11 0x4007042cu
N#define CYREG_SCB1_EZ_DATA12 0x40070430u
N#define CYREG_SCB1_EZ_DATA13 0x40070434u
N#define CYREG_SCB1_EZ_DATA14 0x40070438u
N#define CYREG_SCB1_EZ_DATA15 0x4007043cu
N#define CYREG_SCB1_EZ_DATA16 0x40070440u
N#define CYREG_SCB1_EZ_DATA17 0x40070444u
N#define CYREG_SCB1_EZ_DATA18 0x40070448u
N#define CYREG_SCB1_EZ_DATA19 0x4007044cu
N#define CYREG_SCB1_EZ_DATA20 0x40070450u
N#define CYREG_SCB1_EZ_DATA21 0x40070454u
N#define CYREG_SCB1_EZ_DATA22 0x40070458u
N#define CYREG_SCB1_EZ_DATA23 0x4007045cu
N#define CYREG_SCB1_EZ_DATA24 0x40070460u
N#define CYREG_SCB1_EZ_DATA25 0x40070464u
N#define CYREG_SCB1_EZ_DATA26 0x40070468u
N#define CYREG_SCB1_EZ_DATA27 0x4007046cu
N#define CYREG_SCB1_EZ_DATA28 0x40070470u
N#define CYREG_SCB1_EZ_DATA29 0x40070474u
N#define CYREG_SCB1_EZ_DATA30 0x40070478u
N#define CYREG_SCB1_EZ_DATA31 0x4007047cu
N#define CYREG_SCB1_INTR_CAUSE 0x40070e00u
N#define CYREG_SCB1_INTR_I2C_EC 0x40070e80u
N#define CYREG_SCB1_INTR_I2C_EC_MASK 0x40070e88u
N#define CYREG_SCB1_INTR_I2C_EC_MASKED 0x40070e8cu
N#define CYREG_SCB1_INTR_SPI_EC 0x40070ec0u
N#define CYREG_SCB1_INTR_SPI_EC_MASK 0x40070ec8u
N#define CYREG_SCB1_INTR_SPI_EC_MASKED 0x40070eccu
N#define CYREG_SCB1_INTR_M 0x40070f00u
N#define CYREG_SCB1_INTR_M_SET 0x40070f04u
N#define CYREG_SCB1_INTR_M_MASK 0x40070f08u
N#define CYREG_SCB1_INTR_M_MASKED 0x40070f0cu
N#define CYREG_SCB1_INTR_S 0x40070f40u
N#define CYREG_SCB1_INTR_S_SET 0x40070f44u
N#define CYREG_SCB1_INTR_S_MASK 0x40070f48u
N#define CYREG_SCB1_INTR_S_MASKED 0x40070f4cu
N#define CYREG_SCB1_INTR_TX 0x40070f80u
N#define CYREG_SCB1_INTR_TX_SET 0x40070f84u
N#define CYREG_SCB1_INTR_TX_MASK 0x40070f88u
N#define CYREG_SCB1_INTR_TX_MASKED 0x40070f8cu
N#define CYREG_SCB1_INTR_RX 0x40070fc0u
N#define CYREG_SCB1_INTR_RX_SET 0x40070fc4u
N#define CYREG_SCB1_INTR_RX_MASK 0x40070fc8u
N#define CYREG_SCB1_INTR_RX_MASKED 0x40070fccu
N#define CYDEV_CSD_BASE 0x40080000u
N#define CYDEV_CSD_SIZE 0x00010000u
N#define CYREG_CSD_ID 0x40080000u
N#define CYREG_CSD_CONFIG 0x40080004u
N#define CYREG_CSD_IDAC 0x40080008u
N#define CYREG_CSD_COUNTER 0x4008000cu
N#define CYREG_CSD_STATUS 0x40080010u
N#define CYREG_CSD_INTR 0x40080014u
N#define CYREG_CSD_INTR_SET 0x40080018u
N#define CYREG_CSD_TRIM1 0x4008ff00u
N#define CYREG_CSD_TRIM2 0x4008ff04u
N#define CYDEV_LCD_BASE 0x40090000u
N#define CYDEV_LCD_SIZE 0x00010000u
N#define CYREG_LCD_ID 0x40090000u
N#define CYREG_LCD_DIVIDER 0x40090004u
N#define CYREG_LCD_CONTROL 0x40090008u
N#define CYREG_LCD_DATA00 0x40090100u
N#define CYREG_LCD_DATA01 0x40090104u
N#define CYREG_LCD_DATA02 0x40090108u
N#define CYREG_LCD_DATA03 0x4009010cu
N#define CYREG_LCD_DATA04 0x40090110u
N#define CYDEV_LPCOMP_BASE 0x400a0000u
N#define CYDEV_LPCOMP_SIZE 0x00010000u
N#define CYREG_LPCOMP_ID 0x400a0000u
N#define CYREG_LPCOMP_CONFIG 0x400a0004u
N#define CYREG_LPCOMP_DFT 0x400a0008u
N#define CYREG_LPCOMP_INTR 0x400a000cu
N#define CYREG_LPCOMP_INTR_SET 0x400a0010u
N#define CYREG_LPCOMP_TRIM1 0x400aff00u
N#define CYREG_LPCOMP_TRIM2 0x400aff04u
N#define CYREG_LPCOMP_TRIM3 0x400aff08u
N#define CYREG_LPCOMP_TRIM4 0x400aff0cu
N#define CYDEV__BASE 0x400b0000u
N#define CYDEV__SIZE 0x00010000u
N#define CYREG_PWR_CONTROL 0x400b0000u
N#define CYREG_PWR_INTR 0x400b0004u
N#define CYREG_PWR_INTR_MASK 0x400b0008u
N#define CYREG_PWR_KEY_DELAY 0x400b000cu
N#define CYREG_PWR_PWRSYS_CONFIG 0x400b0010u
N#define CYREG_PWR_BG_CONFIG 0x400b0014u
N#define CYREG_PWR_VMON_CONFIG 0x400b0018u
N#define CYREG_PWR_DFT_SELECT 0x400b001cu
N#define CYREG_PWR_DDFT_SELECT 0x400b0020u
N#define CYREG_PWR_DFT_KEY 0x400b0024u
N#define CYREG_PWR_BOD_KEY 0x400b0028u
N#define CYREG_PWR_STOP 0x400b002cu
N#define CYREG_CLK_SELECT 0x400b0100u
N#define CYREG_CLK_ILO_CONFIG 0x400b0104u
N#define CYREG_CLK_IMO_CONFIG 0x400b0108u
N#define CYREG_CLK_IMO_SPREAD 0x400b010cu
N#define CYREG_CLK_DFT_SELECT 0x400b0110u
N#define CYREG_WDT_CTRLOW 0x400b0200u
N#define CYREG_WDT_CTRHIGH 0x400b0204u
N#define CYREG_WDT_MATCH 0x400b0208u
N#define CYREG_WDT_CONFIG 0x400b020cu
N#define CYREG_WDT_CONTROL 0x400b0210u
N#define CYREG_RES_CAUSE 0x400b0300u
N#define CYREG_PWR_PWRSYS_TRIM1 0x400bff00u
N#define CYREG_PWR_PWRSYS_TRIM2 0x400bff04u
N#define CYREG_PWR_PWRSYS_TRIM3 0x400bff08u
N#define CYREG_PWR_PWRSYS_TRIM4 0x400bff0cu
N#define CYREG_PWR_BG_TRIM1 0x400bff10u
N#define CYREG_PWR_BG_TRIM2 0x400bff14u
N#define CYREG_PWR_BG_TRIM3 0x400bff18u
N#define CYREG_PWR_BG_TRIM4 0x400bff1cu
N#define CYREG_PWR_BG_TRIM5 0x400bff20u
N#define CYREG_CLK_ILO_TRIM 0x400bff24u
N#define CYREG_CLK_IMO_TRIM1 0x400bff28u
N#define CYREG_CLK_IMO_TRIM2 0x400bff2cu
N#define CYREG_CLK_IMO_TRIM3 0x400bff30u
N#define CYREG_CLK_IMO_TRIM4 0x400bff34u
N#define CYREG_PWR_RSVD_TRIM 0x400bff38u
N#define CYDEV_SPCIF_BASE 0x400e0000u
N#define CYDEV_SPCIF_SIZE 0x00010000u
N#define CYREG_SPCIF_GEOMETRY 0x400e0000u
N#define CYREG_SPCIF_NVL_WR_DATA 0x400e001cu
N#define CYDEV_UDB_BASE 0x400f0000u
N#define CYDEV_UDB_SIZE 0x00010000u
N#define CYDEV_UDB_W8_BASE 0x400f0000u
N#define CYDEV_UDB_W8_SIZE 0x00001000u
N#define CYREG_UDB_W8_A0_00 0x400f0000u
N#define CYREG_UDB_W8_A0_01 0x400f0001u
N#define CYREG_UDB_W8_A0_02 0x400f0002u
N#define CYREG_UDB_W8_A0_03 0x400f0003u
N#define CYREG_UDB_W8_A1_00 0x400f0010u
N#define CYREG_UDB_W8_A1_01 0x400f0011u
N#define CYREG_UDB_W8_A1_02 0x400f0012u
N#define CYREG_UDB_W8_A1_03 0x400f0013u
N#define CYREG_UDB_W8_D0_00 0x400f0020u
N#define CYREG_UDB_W8_D0_01 0x400f0021u
N#define CYREG_UDB_W8_D0_02 0x400f0022u
N#define CYREG_UDB_W8_D0_03 0x400f0023u
N#define CYREG_UDB_W8_D1_00 0x400f0030u
N#define CYREG_UDB_W8_D1_01 0x400f0031u
N#define CYREG_UDB_W8_D1_02 0x400f0032u
N#define CYREG_UDB_W8_D1_03 0x400f0033u
N#define CYREG_UDB_W8_F0_00 0x400f0040u
N#define CYREG_UDB_W8_F0_01 0x400f0041u
N#define CYREG_UDB_W8_F0_02 0x400f0042u
N#define CYREG_UDB_W8_F0_03 0x400f0043u
N#define CYREG_UDB_W8_F1_00 0x400f0050u
N#define CYREG_UDB_W8_F1_01 0x400f0051u
N#define CYREG_UDB_W8_F1_02 0x400f0052u
N#define CYREG_UDB_W8_F1_03 0x400f0053u
N#define CYREG_UDB_W8_ST_00 0x400f0060u
N#define CYREG_UDB_W8_ST_01 0x400f0061u
N#define CYREG_UDB_W8_ST_02 0x400f0062u
N#define CYREG_UDB_W8_ST_03 0x400f0063u
N#define CYREG_UDB_W8_CTL_00 0x400f0070u
N#define CYREG_UDB_W8_CTL_01 0x400f0071u
N#define CYREG_UDB_W8_CTL_02 0x400f0072u
N#define CYREG_UDB_W8_CTL_03 0x400f0073u
N#define CYREG_UDB_W8_MSK_00 0x400f0080u
N#define CYREG_UDB_W8_MSK_01 0x400f0081u
N#define CYREG_UDB_W8_MSK_02 0x400f0082u
N#define CYREG_UDB_W8_MSK_03 0x400f0083u
N#define CYREG_UDB_W8_ACTL_00 0x400f0090u
N#define CYREG_UDB_W8_ACTL_01 0x400f0091u
N#define CYREG_UDB_W8_ACTL_02 0x400f0092u
N#define CYREG_UDB_W8_ACTL_03 0x400f0093u
N#define CYREG_UDB_W8_MC_00 0x400f00a0u
N#define CYREG_UDB_W8_MC_01 0x400f00a1u
N#define CYREG_UDB_W8_MC_02 0x400f00a2u
N#define CYREG_UDB_W8_MC_03 0x400f00a3u
N#define CYDEV_UDB_CAT16_BASE 0x400f1000u
N#define CYDEV_UDB_CAT16_SIZE 0x00001000u
N#define CYREG_UDB_CAT16_A_00 0x400f1000u
N#define CYREG_UDB_CAT16_A_01 0x400f1002u
N#define CYREG_UDB_CAT16_A_02 0x400f1004u
N#define CYREG_UDB_CAT16_A_03 0x400f1006u
N#define CYREG_UDB_CAT16_D_00 0x400f1040u
N#define CYREG_UDB_CAT16_D_01 0x400f1042u
N#define CYREG_UDB_CAT16_D_02 0x400f1044u
N#define CYREG_UDB_CAT16_D_03 0x400f1046u
N#define CYREG_UDB_CAT16_F_00 0x400f1080u
N#define CYREG_UDB_CAT16_F_01 0x400f1082u
N#define CYREG_UDB_CAT16_F_02 0x400f1084u
N#define CYREG_UDB_CAT16_F_03 0x400f1086u
N#define CYREG_UDB_CAT16_CTL_ST_00 0x400f10c0u
N#define CYREG_UDB_CAT16_CTL_ST_01 0x400f10c2u
N#define CYREG_UDB_CAT16_CTL_ST_02 0x400f10c4u
N#define CYREG_UDB_CAT16_CTL_ST_03 0x400f10c6u
N#define CYREG_UDB_CAT16_ACTL_MSK_00 0x400f1100u
N#define CYREG_UDB_CAT16_ACTL_MSK_01 0x400f1102u
N#define CYREG_UDB_CAT16_ACTL_MSK_02 0x400f1104u
N#define CYREG_UDB_CAT16_ACTL_MSK_03 0x400f1106u
N#define CYREG_UDB_CAT16_MC_00 0x400f1140u
N#define CYREG_UDB_CAT16_MC_01 0x400f1142u
N#define CYREG_UDB_CAT16_MC_02 0x400f1144u
N#define CYREG_UDB_CAT16_MC_03 0x400f1146u
N#define CYDEV_UDB_W16_BASE 0x400f1000u
N#define CYDEV_UDB_W16_SIZE 0x00001000u
N#define CYREG_UDB_W16_A0_00 0x400f1000u
N#define CYREG_UDB_W16_A0_01 0x400f1002u
N#define CYREG_UDB_W16_A0_02 0x400f1004u
N#define CYREG_UDB_W16_A1_00 0x400f1020u
N#define CYREG_UDB_W16_A1_01 0x400f1022u
N#define CYREG_UDB_W16_A1_02 0x400f1024u
N#define CYREG_UDB_W16_D0_00 0x400f1040u
N#define CYREG_UDB_W16_D0_01 0x400f1042u
N#define CYREG_UDB_W16_D0_02 0x400f1044u
N#define CYREG_UDB_W16_D1_00 0x400f1060u
N#define CYREG_UDB_W16_D1_01 0x400f1062u
N#define CYREG_UDB_W16_D1_02 0x400f1064u
N#define CYREG_UDB_W16_F0_00 0x400f1080u
N#define CYREG_UDB_W16_F0_01 0x400f1082u
N#define CYREG_UDB_W16_F0_02 0x400f1084u
N#define CYREG_UDB_W16_F1_00 0x400f10a0u
N#define CYREG_UDB_W16_F1_01 0x400f10a2u
N#define CYREG_UDB_W16_F1_02 0x400f10a4u
N#define CYREG_UDB_W16_ST_00 0x400f10c0u
N#define CYREG_UDB_W16_ST_01 0x400f10c2u
N#define CYREG_UDB_W16_ST_02 0x400f10c4u
N#define CYREG_UDB_W16_CTL_00 0x400f10e0u
N#define CYREG_UDB_W16_CTL_01 0x400f10e2u
N#define CYREG_UDB_W16_CTL_02 0x400f10e4u
N#define CYREG_UDB_W16_MSK_00 0x400f1100u
N#define CYREG_UDB_W16_MSK_01 0x400f1102u
N#define CYREG_UDB_W16_MSK_02 0x400f1104u
N#define CYREG_UDB_W16_ACTL_00 0x400f1120u
N#define CYREG_UDB_W16_ACTL_01 0x400f1122u
N#define CYREG_UDB_W16_ACTL_02 0x400f1124u
N#define CYREG_UDB_W16_MC_00 0x400f1140u
N#define CYREG_UDB_W16_MC_01 0x400f1142u
N#define CYREG_UDB_W16_MC_02 0x400f1144u
N#define CYDEV_UDB_W32_BASE 0x400f2000u
N#define CYDEV_UDB_W32_SIZE 0x00001000u
N#define CYREG_UDB_W32_A0_00 0x400f2000u
N#define CYREG_UDB_W32_A1_00 0x400f2040u
N#define CYREG_UDB_W32_D0_00 0x400f2080u
N#define CYREG_UDB_W32_D1_00 0x400f20c0u
N#define CYREG_UDB_W32_F0_00 0x400f2100u
N#define CYREG_UDB_W32_F1_00 0x400f2140u
N#define CYREG_UDB_W32_ST_00 0x400f2180u
N#define CYREG_UDB_W32_CTL_00 0x400f21c0u
N#define CYREG_UDB_W32_MSK_00 0x400f2200u
N#define CYREG_UDB_W32_ACTL_00 0x400f2240u
N#define CYREG_UDB_W32_MC_00 0x400f2280u
N#define CYDEV_UDB_P0_BASE 0x400f3000u
N#define CYDEV_UDB_P0_SIZE 0x00000200u
N#define CYDEV_UDB_P0_U0_BASE 0x400f3000u
N#define CYDEV_UDB_P0_U0_SIZE 0x00000080u
N#define CYREG_UDB_P0_U0_PLD_IT0 0x400f3000u
N#define CYREG_UDB_P0_U0_PLD_IT1 0x400f3004u
N#define CYREG_UDB_P0_U0_PLD_IT2 0x400f3008u
N#define CYREG_UDB_P0_U0_PLD_IT3 0x400f300cu
N#define CYREG_UDB_P0_U0_PLD_IT4 0x400f3010u
N#define CYREG_UDB_P0_U0_PLD_IT5 0x400f3014u
N#define CYREG_UDB_P0_U0_PLD_IT6 0x400f3018u
N#define CYREG_UDB_P0_U0_PLD_IT7 0x400f301cu
N#define CYREG_UDB_P0_U0_PLD_IT8 0x400f3020u
N#define CYREG_UDB_P0_U0_PLD_IT9 0x400f3024u
N#define CYREG_UDB_P0_U0_PLD_IT10 0x400f3028u
N#define CYREG_UDB_P0_U0_PLD_IT11 0x400f302cu
N#define CYREG_UDB_P0_U0_PLD_ORT0 0x400f3030u
N#define CYREG_UDB_P0_U0_PLD_ORT1 0x400f3032u
N#define CYREG_UDB_P0_U0_PLD_ORT2 0x400f3034u
N#define CYREG_UDB_P0_U0_PLD_ORT3 0x400f3036u
N#define CYREG_UDB_P0_U0_PLD_MC_CFG_CEN_CONST 0x400f3038u
N#define CYREG_UDB_P0_U0_PLD_MC_CFG_XORFB 0x400f303au
N#define CYREG_UDB_P0_U0_PLD_MC_SET_RESET 0x400f303cu
N#define CYREG_UDB_P0_U0_PLD_MC_CFG_BYPASS 0x400f303eu
N#define CYREG_UDB_P0_U0_CFG0 0x400f3040u
N#define CYREG_UDB_P0_U0_CFG1 0x400f3041u
N#define CYREG_UDB_P0_U0_CFG2 0x400f3042u
N#define CYREG_UDB_P0_U0_CFG3 0x400f3043u
N#define CYREG_UDB_P0_U0_CFG4 0x400f3044u
N#define CYREG_UDB_P0_U0_CFG5 0x400f3045u
N#define CYREG_UDB_P0_U0_CFG6 0x400f3046u
N#define CYREG_UDB_P0_U0_CFG7 0x400f3047u
N#define CYREG_UDB_P0_U0_CFG8 0x400f3048u
N#define CYREG_UDB_P0_U0_CFG9 0x400f3049u
N#define CYREG_UDB_P0_U0_CFG10 0x400f304au
N#define CYREG_UDB_P0_U0_CFG11 0x400f304bu
N#define CYREG_UDB_P0_U0_CFG12 0x400f304cu
N#define CYREG_UDB_P0_U0_CFG13 0x400f304du
N#define CYREG_UDB_P0_U0_CFG14 0x400f304eu
N#define CYREG_UDB_P0_U0_CFG15 0x400f304fu
N#define CYREG_UDB_P0_U0_CFG16 0x400f3050u
N#define CYREG_UDB_P0_U0_CFG17 0x400f3051u
N#define CYREG_UDB_P0_U0_CFG18 0x400f3052u
N#define CYREG_UDB_P0_U0_CFG19 0x400f3053u
N#define CYREG_UDB_P0_U0_CFG20 0x400f3054u
N#define CYREG_UDB_P0_U0_CFG21 0x400f3055u
N#define CYREG_UDB_P0_U0_CFG22 0x400f3056u
N#define CYREG_UDB_P0_U0_CFG23 0x400f3057u
N#define CYREG_UDB_P0_U0_CFG24 0x400f3058u
N#define CYREG_UDB_P0_U0_CFG25 0x400f3059u
N#define CYREG_UDB_P0_U0_CFG26 0x400f305au
N#define CYREG_UDB_P0_U0_CFG27 0x400f305bu
N#define CYREG_UDB_P0_U0_CFG28 0x400f305cu
N#define CYREG_UDB_P0_U0_CFG29 0x400f305du
N#define CYREG_UDB_P0_U0_CFG30 0x400f305eu
N#define CYREG_UDB_P0_U0_CFG31 0x400f305fu
N#define CYREG_UDB_P0_U0_DCFG0 0x400f3060u
N#define CYREG_UDB_P0_U0_DCFG1 0x400f3062u
N#define CYREG_UDB_P0_U0_DCFG2 0x400f3064u
N#define CYREG_UDB_P0_U0_DCFG3 0x400f3066u
N#define CYREG_UDB_P0_U0_DCFG4 0x400f3068u
N#define CYREG_UDB_P0_U0_DCFG5 0x400f306au
N#define CYREG_UDB_P0_U0_DCFG6 0x400f306cu
N#define CYREG_UDB_P0_U0_DCFG7 0x400f306eu
N#define CYDEV_UDB_P0_U1_BASE 0x400f3080u
N#define CYDEV_UDB_P0_U1_SIZE 0x00000080u
N#define CYREG_UDB_P0_U1_PLD_IT0 0x400f3080u
N#define CYREG_UDB_P0_U1_PLD_IT1 0x400f3084u
N#define CYREG_UDB_P0_U1_PLD_IT2 0x400f3088u
N#define CYREG_UDB_P0_U1_PLD_IT3 0x400f308cu
N#define CYREG_UDB_P0_U1_PLD_IT4 0x400f3090u
N#define CYREG_UDB_P0_U1_PLD_IT5 0x400f3094u
N#define CYREG_UDB_P0_U1_PLD_IT6 0x400f3098u
N#define CYREG_UDB_P0_U1_PLD_IT7 0x400f309cu
N#define CYREG_UDB_P0_U1_PLD_IT8 0x400f30a0u
N#define CYREG_UDB_P0_U1_PLD_IT9 0x400f30a4u
N#define CYREG_UDB_P0_U1_PLD_IT10 0x400f30a8u
N#define CYREG_UDB_P0_U1_PLD_IT11 0x400f30acu
N#define CYREG_UDB_P0_U1_PLD_ORT0 0x400f30b0u
N#define CYREG_UDB_P0_U1_PLD_ORT1 0x400f30b2u
N#define CYREG_UDB_P0_U1_PLD_ORT2 0x400f30b4u
N#define CYREG_UDB_P0_U1_PLD_ORT3 0x400f30b6u
N#define CYREG_UDB_P0_U1_PLD_MC_CFG_CEN_CONST 0x400f30b8u
N#define CYREG_UDB_P0_U1_PLD_MC_CFG_XORFB 0x400f30bau
N#define CYREG_UDB_P0_U1_PLD_MC_SET_RESET 0x400f30bcu
N#define CYREG_UDB_P0_U1_PLD_MC_CFG_BYPASS 0x400f30beu
N#define CYREG_UDB_P0_U1_CFG0 0x400f30c0u
N#define CYREG_UDB_P0_U1_CFG1 0x400f30c1u
N#define CYREG_UDB_P0_U1_CFG2 0x400f30c2u
N#define CYREG_UDB_P0_U1_CFG3 0x400f30c3u
N#define CYREG_UDB_P0_U1_CFG4 0x400f30c4u
N#define CYREG_UDB_P0_U1_CFG5 0x400f30c5u
N#define CYREG_UDB_P0_U1_CFG6 0x400f30c6u
N#define CYREG_UDB_P0_U1_CFG7 0x400f30c7u
N#define CYREG_UDB_P0_U1_CFG8 0x400f30c8u
N#define CYREG_UDB_P0_U1_CFG9 0x400f30c9u
N#define CYREG_UDB_P0_U1_CFG10 0x400f30cau
N#define CYREG_UDB_P0_U1_CFG11 0x400f30cbu
N#define CYREG_UDB_P0_U1_CFG12 0x400f30ccu
N#define CYREG_UDB_P0_U1_CFG13 0x400f30cdu
N#define CYREG_UDB_P0_U1_CFG14 0x400f30ceu
N#define CYREG_UDB_P0_U1_CFG15 0x400f30cfu
N#define CYREG_UDB_P0_U1_CFG16 0x400f30d0u
N#define CYREG_UDB_P0_U1_CFG17 0x400f30d1u
N#define CYREG_UDB_P0_U1_CFG18 0x400f30d2u
N#define CYREG_UDB_P0_U1_CFG19 0x400f30d3u
N#define CYREG_UDB_P0_U1_CFG20 0x400f30d4u
N#define CYREG_UDB_P0_U1_CFG21 0x400f30d5u
N#define CYREG_UDB_P0_U1_CFG22 0x400f30d6u
N#define CYREG_UDB_P0_U1_CFG23 0x400f30d7u
N#define CYREG_UDB_P0_U1_CFG24 0x400f30d8u
N#define CYREG_UDB_P0_U1_CFG25 0x400f30d9u
N#define CYREG_UDB_P0_U1_CFG26 0x400f30dau
N#define CYREG_UDB_P0_U1_CFG27 0x400f30dbu
N#define CYREG_UDB_P0_U1_CFG28 0x400f30dcu
N#define CYREG_UDB_P0_U1_CFG29 0x400f30ddu
N#define CYREG_UDB_P0_U1_CFG30 0x400f30deu
N#define CYREG_UDB_P0_U1_CFG31 0x400f30dfu
N#define CYREG_UDB_P0_U1_DCFG0 0x400f30e0u
N#define CYREG_UDB_P0_U1_DCFG1 0x400f30e2u
N#define CYREG_UDB_P0_U1_DCFG2 0x400f30e4u
N#define CYREG_UDB_P0_U1_DCFG3 0x400f30e6u
N#define CYREG_UDB_P0_U1_DCFG4 0x400f30e8u
N#define CYREG_UDB_P0_U1_DCFG5 0x400f30eau
N#define CYREG_UDB_P0_U1_DCFG6 0x400f30ecu
N#define CYREG_UDB_P0_U1_DCFG7 0x400f30eeu
N#define CYDEV_UDB_P0_ROUTE_BASE 0x400f3100u
N#define CYDEV_UDB_P0_ROUTE_SIZE 0x00000100u
N#define CYREG_UDB_P0_ROUTE_HC0 0x400f3100u
N#define CYREG_UDB_P0_ROUTE_HC1 0x400f3101u
N#define CYREG_UDB_P0_ROUTE_HC2 0x400f3102u
N#define CYREG_UDB_P0_ROUTE_HC3 0x400f3103u
N#define CYREG_UDB_P0_ROUTE_HC4 0x400f3104u
N#define CYREG_UDB_P0_ROUTE_HC5 0x400f3105u
N#define CYREG_UDB_P0_ROUTE_HC6 0x400f3106u
N#define CYREG_UDB_P0_ROUTE_HC7 0x400f3107u
N#define CYREG_UDB_P0_ROUTE_HC8 0x400f3108u
N#define CYREG_UDB_P0_ROUTE_HC9 0x400f3109u
N#define CYREG_UDB_P0_ROUTE_HC10 0x400f310au
N#define CYREG_UDB_P0_ROUTE_HC11 0x400f310bu
N#define CYREG_UDB_P0_ROUTE_HC12 0x400f310cu
N#define CYREG_UDB_P0_ROUTE_HC13 0x400f310du
N#define CYREG_UDB_P0_ROUTE_HC14 0x400f310eu
N#define CYREG_UDB_P0_ROUTE_HC15 0x400f310fu
N#define CYREG_UDB_P0_ROUTE_HC16 0x400f3110u
N#define CYREG_UDB_P0_ROUTE_HC17 0x400f3111u
N#define CYREG_UDB_P0_ROUTE_HC18 0x400f3112u
N#define CYREG_UDB_P0_ROUTE_HC19 0x400f3113u
N#define CYREG_UDB_P0_ROUTE_HC20 0x400f3114u
N#define CYREG_UDB_P0_ROUTE_HC21 0x400f3115u
N#define CYREG_UDB_P0_ROUTE_HC22 0x400f3116u
N#define CYREG_UDB_P0_ROUTE_HC23 0x400f3117u
N#define CYREG_UDB_P0_ROUTE_HC24 0x400f3118u
N#define CYREG_UDB_P0_ROUTE_HC25 0x400f3119u
N#define CYREG_UDB_P0_ROUTE_HC26 0x400f311au
N#define CYREG_UDB_P0_ROUTE_HC27 0x400f311bu
N#define CYREG_UDB_P0_ROUTE_HC28 0x400f311cu
N#define CYREG_UDB_P0_ROUTE_HC29 0x400f311du
N#define CYREG_UDB_P0_ROUTE_HC30 0x400f311eu
N#define CYREG_UDB_P0_ROUTE_HC31 0x400f311fu
N#define CYREG_UDB_P0_ROUTE_HC32 0x400f3120u
N#define CYREG_UDB_P0_ROUTE_HC33 0x400f3121u
N#define CYREG_UDB_P0_ROUTE_HC34 0x400f3122u
N#define CYREG_UDB_P0_ROUTE_HC35 0x400f3123u
N#define CYREG_UDB_P0_ROUTE_HC36 0x400f3124u
N#define CYREG_UDB_P0_ROUTE_HC37 0x400f3125u
N#define CYREG_UDB_P0_ROUTE_HC38 0x400f3126u
N#define CYREG_UDB_P0_ROUTE_HC39 0x400f3127u
N#define CYREG_UDB_P0_ROUTE_HC40 0x400f3128u
N#define CYREG_UDB_P0_ROUTE_HC41 0x400f3129u
N#define CYREG_UDB_P0_ROUTE_HC42 0x400f312au
N#define CYREG_UDB_P0_ROUTE_HC43 0x400f312bu
N#define CYREG_UDB_P0_ROUTE_HC44 0x400f312cu
N#define CYREG_UDB_P0_ROUTE_HC45 0x400f312du
N#define CYREG_UDB_P0_ROUTE_HC46 0x400f312eu
N#define CYREG_UDB_P0_ROUTE_HC47 0x400f312fu
N#define CYREG_UDB_P0_ROUTE_HC48 0x400f3130u
N#define CYREG_UDB_P0_ROUTE_HC49 0x400f3131u
N#define CYREG_UDB_P0_ROUTE_HC50 0x400f3132u
N#define CYREG_UDB_P0_ROUTE_HC51 0x400f3133u
N#define CYREG_UDB_P0_ROUTE_HC52 0x400f3134u
N#define CYREG_UDB_P0_ROUTE_HC53 0x400f3135u
N#define CYREG_UDB_P0_ROUTE_HC54 0x400f3136u
N#define CYREG_UDB_P0_ROUTE_HC55 0x400f3137u
N#define CYREG_UDB_P0_ROUTE_HC56 0x400f3138u
N#define CYREG_UDB_P0_ROUTE_HC57 0x400f3139u
N#define CYREG_UDB_P0_ROUTE_HC58 0x400f313au
N#define CYREG_UDB_P0_ROUTE_HC59 0x400f313bu
N#define CYREG_UDB_P0_ROUTE_HC60 0x400f313cu
N#define CYREG_UDB_P0_ROUTE_HC61 0x400f313du
N#define CYREG_UDB_P0_ROUTE_HC62 0x400f313eu
N#define CYREG_UDB_P0_ROUTE_HC63 0x400f313fu
N#define CYREG_UDB_P0_ROUTE_HC64 0x400f3140u
N#define CYREG_UDB_P0_ROUTE_HC65 0x400f3141u
N#define CYREG_UDB_P0_ROUTE_HC66 0x400f3142u
N#define CYREG_UDB_P0_ROUTE_HC67 0x400f3143u
N#define CYREG_UDB_P0_ROUTE_HC68 0x400f3144u
N#define CYREG_UDB_P0_ROUTE_HC69 0x400f3145u
N#define CYREG_UDB_P0_ROUTE_HC70 0x400f3146u
N#define CYREG_UDB_P0_ROUTE_HC71 0x400f3147u
N#define CYREG_UDB_P0_ROUTE_HC72 0x400f3148u
N#define CYREG_UDB_P0_ROUTE_HC73 0x400f3149u
N#define CYREG_UDB_P0_ROUTE_HC74 0x400f314au
N#define CYREG_UDB_P0_ROUTE_HC75 0x400f314bu
N#define CYREG_UDB_P0_ROUTE_HC76 0x400f314cu
N#define CYREG_UDB_P0_ROUTE_HC77 0x400f314du
N#define CYREG_UDB_P0_ROUTE_HC78 0x400f314eu
N#define CYREG_UDB_P0_ROUTE_HC79 0x400f314fu
N#define CYREG_UDB_P0_ROUTE_HC80 0x400f3150u
N#define CYREG_UDB_P0_ROUTE_HC81 0x400f3151u
N#define CYREG_UDB_P0_ROUTE_HC82 0x400f3152u
N#define CYREG_UDB_P0_ROUTE_HC83 0x400f3153u
N#define CYREG_UDB_P0_ROUTE_HC84 0x400f3154u
N#define CYREG_UDB_P0_ROUTE_HC85 0x400f3155u
N#define CYREG_UDB_P0_ROUTE_HC86 0x400f3156u
N#define CYREG_UDB_P0_ROUTE_HC87 0x400f3157u
N#define CYREG_UDB_P0_ROUTE_HC88 0x400f3158u
N#define CYREG_UDB_P0_ROUTE_HC89 0x400f3159u
N#define CYREG_UDB_P0_ROUTE_HC90 0x400f315au
N#define CYREG_UDB_P0_ROUTE_HC91 0x400f315bu
N#define CYREG_UDB_P0_ROUTE_HC92 0x400f315cu
N#define CYREG_UDB_P0_ROUTE_HC93 0x400f315du
N#define CYREG_UDB_P0_ROUTE_HC94 0x400f315eu
N#define CYREG_UDB_P0_ROUTE_HC95 0x400f315fu
N#define CYREG_UDB_P0_ROUTE_HC96 0x400f3160u
N#define CYREG_UDB_P0_ROUTE_HC97 0x400f3161u
N#define CYREG_UDB_P0_ROUTE_HC98 0x400f3162u
N#define CYREG_UDB_P0_ROUTE_HC99 0x400f3163u
N#define CYREG_UDB_P0_ROUTE_HC100 0x400f3164u
N#define CYREG_UDB_P0_ROUTE_HC101 0x400f3165u
N#define CYREG_UDB_P0_ROUTE_HC102 0x400f3166u
N#define CYREG_UDB_P0_ROUTE_HC103 0x400f3167u
N#define CYREG_UDB_P0_ROUTE_HC104 0x400f3168u
N#define CYREG_UDB_P0_ROUTE_HC105 0x400f3169u
N#define CYREG_UDB_P0_ROUTE_HC106 0x400f316au
N#define CYREG_UDB_P0_ROUTE_HC107 0x400f316bu
N#define CYREG_UDB_P0_ROUTE_HC108 0x400f316cu
N#define CYREG_UDB_P0_ROUTE_HC109 0x400f316du
N#define CYREG_UDB_P0_ROUTE_HC110 0x400f316eu
N#define CYREG_UDB_P0_ROUTE_HC111 0x400f316fu
N#define CYREG_UDB_P0_ROUTE_HC112 0x400f3170u
N#define CYREG_UDB_P0_ROUTE_HC113 0x400f3171u
N#define CYREG_UDB_P0_ROUTE_HC114 0x400f3172u
N#define CYREG_UDB_P0_ROUTE_HC115 0x400f3173u
N#define CYREG_UDB_P0_ROUTE_HC116 0x400f3174u
N#define CYREG_UDB_P0_ROUTE_HC117 0x400f3175u
N#define CYREG_UDB_P0_ROUTE_HC118 0x400f3176u
N#define CYREG_UDB_P0_ROUTE_HC119 0x400f3177u
N#define CYREG_UDB_P0_ROUTE_HC120 0x400f3178u
N#define CYREG_UDB_P0_ROUTE_HC121 0x400f3179u
N#define CYREG_UDB_P0_ROUTE_HC122 0x400f317au
N#define CYREG_UDB_P0_ROUTE_HC123 0x400f317bu
N#define CYREG_UDB_P0_ROUTE_HC124 0x400f317cu
N#define CYREG_UDB_P0_ROUTE_HC125 0x400f317du
N#define CYREG_UDB_P0_ROUTE_HC126 0x400f317eu
N#define CYREG_UDB_P0_ROUTE_HC127 0x400f317fu
N#define CYREG_UDB_P0_ROUTE_HV_L0 0x400f3180u
N#define CYREG_UDB_P0_ROUTE_HV_L1 0x400f3181u
N#define CYREG_UDB_P0_ROUTE_HV_L2 0x400f3182u
N#define CYREG_UDB_P0_ROUTE_HV_L3 0x400f3183u
N#define CYREG_UDB_P0_ROUTE_HV_L4 0x400f3184u
N#define CYREG_UDB_P0_ROUTE_HV_L5 0x400f3185u
N#define CYREG_UDB_P0_ROUTE_HV_L6 0x400f3186u
N#define CYREG_UDB_P0_ROUTE_HV_L7 0x400f3187u
N#define CYREG_UDB_P0_ROUTE_HV_L8 0x400f3188u
N#define CYREG_UDB_P0_ROUTE_HV_L9 0x400f3189u
N#define CYREG_UDB_P0_ROUTE_HV_L10 0x400f318au
N#define CYREG_UDB_P0_ROUTE_HV_L11 0x400f318bu
N#define CYREG_UDB_P0_ROUTE_HV_L12 0x400f318cu
N#define CYREG_UDB_P0_ROUTE_HV_L13 0x400f318du
N#define CYREG_UDB_P0_ROUTE_HV_L14 0x400f318eu
N#define CYREG_UDB_P0_ROUTE_HV_L15 0x400f318fu
N#define CYREG_UDB_P0_ROUTE_HS0 0x400f3190u
N#define CYREG_UDB_P0_ROUTE_HS1 0x400f3191u
N#define CYREG_UDB_P0_ROUTE_HS2 0x400f3192u
N#define CYREG_UDB_P0_ROUTE_HS3 0x400f3193u
N#define CYREG_UDB_P0_ROUTE_HS4 0x400f3194u
N#define CYREG_UDB_P0_ROUTE_HS5 0x400f3195u
N#define CYREG_UDB_P0_ROUTE_HS6 0x400f3196u
N#define CYREG_UDB_P0_ROUTE_HS7 0x400f3197u
N#define CYREG_UDB_P0_ROUTE_HS8 0x400f3198u
N#define CYREG_UDB_P0_ROUTE_HS9 0x400f3199u
N#define CYREG_UDB_P0_ROUTE_HS10 0x400f319au
N#define CYREG_UDB_P0_ROUTE_HS11 0x400f319bu
N#define CYREG_UDB_P0_ROUTE_HS12 0x400f319cu
N#define CYREG_UDB_P0_ROUTE_HS13 0x400f319du
N#define CYREG_UDB_P0_ROUTE_HS14 0x400f319eu
N#define CYREG_UDB_P0_ROUTE_HS15 0x400f319fu
N#define CYREG_UDB_P0_ROUTE_HS16 0x400f31a0u
N#define CYREG_UDB_P0_ROUTE_HS17 0x400f31a1u
N#define CYREG_UDB_P0_ROUTE_HS18 0x400f31a2u
N#define CYREG_UDB_P0_ROUTE_HS19 0x400f31a3u
N#define CYREG_UDB_P0_ROUTE_HS20 0x400f31a4u
N#define CYREG_UDB_P0_ROUTE_HS21 0x400f31a5u
N#define CYREG_UDB_P0_ROUTE_HS22 0x400f31a6u
N#define CYREG_UDB_P0_ROUTE_HS23 0x400f31a7u
N#define CYREG_UDB_P0_ROUTE_HV_R0 0x400f31a8u
N#define CYREG_UDB_P0_ROUTE_HV_R1 0x400f31a9u
N#define CYREG_UDB_P0_ROUTE_HV_R2 0x400f31aau
N#define CYREG_UDB_P0_ROUTE_HV_R3 0x400f31abu
N#define CYREG_UDB_P0_ROUTE_HV_R4 0x400f31acu
N#define CYREG_UDB_P0_ROUTE_HV_R5 0x400f31adu
N#define CYREG_UDB_P0_ROUTE_HV_R6 0x400f31aeu
N#define CYREG_UDB_P0_ROUTE_HV_R7 0x400f31afu
N#define CYREG_UDB_P0_ROUTE_HV_R8 0x400f31b0u
N#define CYREG_UDB_P0_ROUTE_HV_R9 0x400f31b1u
N#define CYREG_UDB_P0_ROUTE_HV_R10 0x400f31b2u
N#define CYREG_UDB_P0_ROUTE_HV_R11 0x400f31b3u
N#define CYREG_UDB_P0_ROUTE_HV_R12 0x400f31b4u
N#define CYREG_UDB_P0_ROUTE_HV_R13 0x400f31b5u
N#define CYREG_UDB_P0_ROUTE_HV_R14 0x400f31b6u
N#define CYREG_UDB_P0_ROUTE_HV_R15 0x400f31b7u
N#define CYREG_UDB_P0_ROUTE_PLD0IN0 0x400f31c0u
N#define CYREG_UDB_P0_ROUTE_PLD0IN1 0x400f31c2u
N#define CYREG_UDB_P0_ROUTE_PLD0IN2 0x400f31c4u
N#define CYREG_UDB_P0_ROUTE_PLD1IN0 0x400f31cau
N#define CYREG_UDB_P0_ROUTE_PLD1IN1 0x400f31ccu
N#define CYREG_UDB_P0_ROUTE_PLD1IN2 0x400f31ceu
N#define CYREG_UDB_P0_ROUTE_DPIN0 0x400f31d0u
N#define CYREG_UDB_P0_ROUTE_DPIN1 0x400f31d2u
N#define CYREG_UDB_P0_ROUTE_SCIN 0x400f31d6u
N#define CYREG_UDB_P0_ROUTE_SCIOIN 0x400f31d8u
N#define CYREG_UDB_P0_ROUTE_RCIN 0x400f31deu
N#define CYREG_UDB_P0_ROUTE_VS0 0x400f31e0u
N#define CYREG_UDB_P0_ROUTE_VS1 0x400f31e2u
N#define CYREG_UDB_P0_ROUTE_VS2 0x400f31e4u
N#define CYREG_UDB_P0_ROUTE_VS3 0x400f31e6u
N#define CYREG_UDB_P0_ROUTE_VS4 0x400f31e8u
N#define CYREG_UDB_P0_ROUTE_VS5 0x400f31eau
N#define CYREG_UDB_P0_ROUTE_VS6 0x400f31ecu
N#define CYREG_UDB_P0_ROUTE_VS7 0x400f31eeu
N#define CYDEV_UDB_P1_BASE 0x400f3200u
N#define CYDEV_UDB_P1_SIZE 0x00000200u
N#define CYDEV_UDB_P1_U0_BASE 0x400f3200u
N#define CYDEV_UDB_P1_U0_SIZE 0x00000080u
N#define CYREG_UDB_P1_U0_PLD_IT0 0x400f3200u
N#define CYREG_UDB_P1_U0_PLD_IT1 0x400f3204u
N#define CYREG_UDB_P1_U0_PLD_IT2 0x400f3208u
N#define CYREG_UDB_P1_U0_PLD_IT3 0x400f320cu
N#define CYREG_UDB_P1_U0_PLD_IT4 0x400f3210u
N#define CYREG_UDB_P1_U0_PLD_IT5 0x400f3214u
N#define CYREG_UDB_P1_U0_PLD_IT6 0x400f3218u
N#define CYREG_UDB_P1_U0_PLD_IT7 0x400f321cu
N#define CYREG_UDB_P1_U0_PLD_IT8 0x400f3220u
N#define CYREG_UDB_P1_U0_PLD_IT9 0x400f3224u
N#define CYREG_UDB_P1_U0_PLD_IT10 0x400f3228u
N#define CYREG_UDB_P1_U0_PLD_IT11 0x400f322cu
N#define CYREG_UDB_P1_U0_PLD_ORT0 0x400f3230u
N#define CYREG_UDB_P1_U0_PLD_ORT1 0x400f3232u
N#define CYREG_UDB_P1_U0_PLD_ORT2 0x400f3234u
N#define CYREG_UDB_P1_U0_PLD_ORT3 0x400f3236u
N#define CYREG_UDB_P1_U0_PLD_MC_CFG_CEN_CONST 0x400f3238u
N#define CYREG_UDB_P1_U0_PLD_MC_CFG_XORFB 0x400f323au
N#define CYREG_UDB_P1_U0_PLD_MC_SET_RESET 0x400f323cu
N#define CYREG_UDB_P1_U0_PLD_MC_CFG_BYPASS 0x400f323eu
N#define CYREG_UDB_P1_U0_CFG0 0x400f3240u
N#define CYREG_UDB_P1_U0_CFG1 0x400f3241u
N#define CYREG_UDB_P1_U0_CFG2 0x400f3242u
N#define CYREG_UDB_P1_U0_CFG3 0x400f3243u
N#define CYREG_UDB_P1_U0_CFG4 0x400f3244u
N#define CYREG_UDB_P1_U0_CFG5 0x400f3245u
N#define CYREG_UDB_P1_U0_CFG6 0x400f3246u
N#define CYREG_UDB_P1_U0_CFG7 0x400f3247u
N#define CYREG_UDB_P1_U0_CFG8 0x400f3248u
N#define CYREG_UDB_P1_U0_CFG9 0x400f3249u
N#define CYREG_UDB_P1_U0_CFG10 0x400f324au
N#define CYREG_UDB_P1_U0_CFG11 0x400f324bu
N#define CYREG_UDB_P1_U0_CFG12 0x400f324cu
N#define CYREG_UDB_P1_U0_CFG13 0x400f324du
N#define CYREG_UDB_P1_U0_CFG14 0x400f324eu
N#define CYREG_UDB_P1_U0_CFG15 0x400f324fu
N#define CYREG_UDB_P1_U0_CFG16 0x400f3250u
N#define CYREG_UDB_P1_U0_CFG17 0x400f3251u
N#define CYREG_UDB_P1_U0_CFG18 0x400f3252u
N#define CYREG_UDB_P1_U0_CFG19 0x400f3253u
N#define CYREG_UDB_P1_U0_CFG20 0x400f3254u
N#define CYREG_UDB_P1_U0_CFG21 0x400f3255u
N#define CYREG_UDB_P1_U0_CFG22 0x400f3256u
N#define CYREG_UDB_P1_U0_CFG23 0x400f3257u
N#define CYREG_UDB_P1_U0_CFG24 0x400f3258u
N#define CYREG_UDB_P1_U0_CFG25 0x400f3259u
N#define CYREG_UDB_P1_U0_CFG26 0x400f325au
N#define CYREG_UDB_P1_U0_CFG27 0x400f325bu
N#define CYREG_UDB_P1_U0_CFG28 0x400f325cu
N#define CYREG_UDB_P1_U0_CFG29 0x400f325du
N#define CYREG_UDB_P1_U0_CFG30 0x400f325eu
N#define CYREG_UDB_P1_U0_CFG31 0x400f325fu
N#define CYREG_UDB_P1_U0_DCFG0 0x400f3260u
N#define CYREG_UDB_P1_U0_DCFG1 0x400f3262u
N#define CYREG_UDB_P1_U0_DCFG2 0x400f3264u
N#define CYREG_UDB_P1_U0_DCFG3 0x400f3266u
N#define CYREG_UDB_P1_U0_DCFG4 0x400f3268u
N#define CYREG_UDB_P1_U0_DCFG5 0x400f326au
N#define CYREG_UDB_P1_U0_DCFG6 0x400f326cu
N#define CYREG_UDB_P1_U0_DCFG7 0x400f326eu
N#define CYDEV_UDB_P1_U1_BASE 0x400f3280u
N#define CYDEV_UDB_P1_U1_SIZE 0x00000080u
N#define CYREG_UDB_P1_U1_PLD_IT0 0x400f3280u
N#define CYREG_UDB_P1_U1_PLD_IT1 0x400f3284u
N#define CYREG_UDB_P1_U1_PLD_IT2 0x400f3288u
N#define CYREG_UDB_P1_U1_PLD_IT3 0x400f328cu
N#define CYREG_UDB_P1_U1_PLD_IT4 0x400f3290u
N#define CYREG_UDB_P1_U1_PLD_IT5 0x400f3294u
N#define CYREG_UDB_P1_U1_PLD_IT6 0x400f3298u
N#define CYREG_UDB_P1_U1_PLD_IT7 0x400f329cu
N#define CYREG_UDB_P1_U1_PLD_IT8 0x400f32a0u
N#define CYREG_UDB_P1_U1_PLD_IT9 0x400f32a4u
N#define CYREG_UDB_P1_U1_PLD_IT10 0x400f32a8u
N#define CYREG_UDB_P1_U1_PLD_IT11 0x400f32acu
N#define CYREG_UDB_P1_U1_PLD_ORT0 0x400f32b0u
N#define CYREG_UDB_P1_U1_PLD_ORT1 0x400f32b2u
N#define CYREG_UDB_P1_U1_PLD_ORT2 0x400f32b4u
N#define CYREG_UDB_P1_U1_PLD_ORT3 0x400f32b6u
N#define CYREG_UDB_P1_U1_PLD_MC_CFG_CEN_CONST 0x400f32b8u
N#define CYREG_UDB_P1_U1_PLD_MC_CFG_XORFB 0x400f32bau
N#define CYREG_UDB_P1_U1_PLD_MC_SET_RESET 0x400f32bcu
N#define CYREG_UDB_P1_U1_PLD_MC_CFG_BYPASS 0x400f32beu
N#define CYREG_UDB_P1_U1_CFG0 0x400f32c0u
N#define CYREG_UDB_P1_U1_CFG1 0x400f32c1u
N#define CYREG_UDB_P1_U1_CFG2 0x400f32c2u
N#define CYREG_UDB_P1_U1_CFG3 0x400f32c3u
N#define CYREG_UDB_P1_U1_CFG4 0x400f32c4u
N#define CYREG_UDB_P1_U1_CFG5 0x400f32c5u
N#define CYREG_UDB_P1_U1_CFG6 0x400f32c6u
N#define CYREG_UDB_P1_U1_CFG7 0x400f32c7u
N#define CYREG_UDB_P1_U1_CFG8 0x400f32c8u
N#define CYREG_UDB_P1_U1_CFG9 0x400f32c9u
N#define CYREG_UDB_P1_U1_CFG10 0x400f32cau
N#define CYREG_UDB_P1_U1_CFG11 0x400f32cbu
N#define CYREG_UDB_P1_U1_CFG12 0x400f32ccu
N#define CYREG_UDB_P1_U1_CFG13 0x400f32cdu
N#define CYREG_UDB_P1_U1_CFG14 0x400f32ceu
N#define CYREG_UDB_P1_U1_CFG15 0x400f32cfu
N#define CYREG_UDB_P1_U1_CFG16 0x400f32d0u
N#define CYREG_UDB_P1_U1_CFG17 0x400f32d1u
N#define CYREG_UDB_P1_U1_CFG18 0x400f32d2u
N#define CYREG_UDB_P1_U1_CFG19 0x400f32d3u
N#define CYREG_UDB_P1_U1_CFG20 0x400f32d4u
N#define CYREG_UDB_P1_U1_CFG21 0x400f32d5u
N#define CYREG_UDB_P1_U1_CFG22 0x400f32d6u
N#define CYREG_UDB_P1_U1_CFG23 0x400f32d7u
N#define CYREG_UDB_P1_U1_CFG24 0x400f32d8u
N#define CYREG_UDB_P1_U1_CFG25 0x400f32d9u
N#define CYREG_UDB_P1_U1_CFG26 0x400f32dau
N#define CYREG_UDB_P1_U1_CFG27 0x400f32dbu
N#define CYREG_UDB_P1_U1_CFG28 0x400f32dcu
N#define CYREG_UDB_P1_U1_CFG29 0x400f32ddu
N#define CYREG_UDB_P1_U1_CFG30 0x400f32deu
N#define CYREG_UDB_P1_U1_CFG31 0x400f32dfu
N#define CYREG_UDB_P1_U1_DCFG0 0x400f32e0u
N#define CYREG_UDB_P1_U1_DCFG1 0x400f32e2u
N#define CYREG_UDB_P1_U1_DCFG2 0x400f32e4u
N#define CYREG_UDB_P1_U1_DCFG3 0x400f32e6u
N#define CYREG_UDB_P1_U1_DCFG4 0x400f32e8u
N#define CYREG_UDB_P1_U1_DCFG5 0x400f32eau
N#define CYREG_UDB_P1_U1_DCFG6 0x400f32ecu
N#define CYREG_UDB_P1_U1_DCFG7 0x400f32eeu
N#define CYDEV_UDB_P1_ROUTE_BASE 0x400f3300u
N#define CYDEV_UDB_P1_ROUTE_SIZE 0x00000100u
N#define CYREG_UDB_P1_ROUTE_HC0 0x400f3300u
N#define CYREG_UDB_P1_ROUTE_HC1 0x400f3301u
N#define CYREG_UDB_P1_ROUTE_HC2 0x400f3302u
N#define CYREG_UDB_P1_ROUTE_HC3 0x400f3303u
N#define CYREG_UDB_P1_ROUTE_HC4 0x400f3304u
N#define CYREG_UDB_P1_ROUTE_HC5 0x400f3305u
N#define CYREG_UDB_P1_ROUTE_HC6 0x400f3306u
N#define CYREG_UDB_P1_ROUTE_HC7 0x400f3307u
N#define CYREG_UDB_P1_ROUTE_HC8 0x400f3308u
N#define CYREG_UDB_P1_ROUTE_HC9 0x400f3309u
N#define CYREG_UDB_P1_ROUTE_HC10 0x400f330au
N#define CYREG_UDB_P1_ROUTE_HC11 0x400f330bu
N#define CYREG_UDB_P1_ROUTE_HC12 0x400f330cu
N#define CYREG_UDB_P1_ROUTE_HC13 0x400f330du
N#define CYREG_UDB_P1_ROUTE_HC14 0x400f330eu
N#define CYREG_UDB_P1_ROUTE_HC15 0x400f330fu
N#define CYREG_UDB_P1_ROUTE_HC16 0x400f3310u
N#define CYREG_UDB_P1_ROUTE_HC17 0x400f3311u
N#define CYREG_UDB_P1_ROUTE_HC18 0x400f3312u
N#define CYREG_UDB_P1_ROUTE_HC19 0x400f3313u
N#define CYREG_UDB_P1_ROUTE_HC20 0x400f3314u
N#define CYREG_UDB_P1_ROUTE_HC21 0x400f3315u
N#define CYREG_UDB_P1_ROUTE_HC22 0x400f3316u
N#define CYREG_UDB_P1_ROUTE_HC23 0x400f3317u
N#define CYREG_UDB_P1_ROUTE_HC24 0x400f3318u
N#define CYREG_UDB_P1_ROUTE_HC25 0x400f3319u
N#define CYREG_UDB_P1_ROUTE_HC26 0x400f331au
N#define CYREG_UDB_P1_ROUTE_HC27 0x400f331bu
N#define CYREG_UDB_P1_ROUTE_HC28 0x400f331cu
N#define CYREG_UDB_P1_ROUTE_HC29 0x400f331du
N#define CYREG_UDB_P1_ROUTE_HC30 0x400f331eu
N#define CYREG_UDB_P1_ROUTE_HC31 0x400f331fu
N#define CYREG_UDB_P1_ROUTE_HC32 0x400f3320u
N#define CYREG_UDB_P1_ROUTE_HC33 0x400f3321u
N#define CYREG_UDB_P1_ROUTE_HC34 0x400f3322u
N#define CYREG_UDB_P1_ROUTE_HC35 0x400f3323u
N#define CYREG_UDB_P1_ROUTE_HC36 0x400f3324u
N#define CYREG_UDB_P1_ROUTE_HC37 0x400f3325u
N#define CYREG_UDB_P1_ROUTE_HC38 0x400f3326u
N#define CYREG_UDB_P1_ROUTE_HC39 0x400f3327u
N#define CYREG_UDB_P1_ROUTE_HC40 0x400f3328u
N#define CYREG_UDB_P1_ROUTE_HC41 0x400f3329u
N#define CYREG_UDB_P1_ROUTE_HC42 0x400f332au
N#define CYREG_UDB_P1_ROUTE_HC43 0x400f332bu
N#define CYREG_UDB_P1_ROUTE_HC44 0x400f332cu
N#define CYREG_UDB_P1_ROUTE_HC45 0x400f332du
N#define CYREG_UDB_P1_ROUTE_HC46 0x400f332eu
N#define CYREG_UDB_P1_ROUTE_HC47 0x400f332fu
N#define CYREG_UDB_P1_ROUTE_HC48 0x400f3330u
N#define CYREG_UDB_P1_ROUTE_HC49 0x400f3331u
N#define CYREG_UDB_P1_ROUTE_HC50 0x400f3332u
N#define CYREG_UDB_P1_ROUTE_HC51 0x400f3333u
N#define CYREG_UDB_P1_ROUTE_HC52 0x400f3334u
N#define CYREG_UDB_P1_ROUTE_HC53 0x400f3335u
N#define CYREG_UDB_P1_ROUTE_HC54 0x400f3336u
N#define CYREG_UDB_P1_ROUTE_HC55 0x400f3337u
N#define CYREG_UDB_P1_ROUTE_HC56 0x400f3338u
N#define CYREG_UDB_P1_ROUTE_HC57 0x400f3339u
N#define CYREG_UDB_P1_ROUTE_HC58 0x400f333au
N#define CYREG_UDB_P1_ROUTE_HC59 0x400f333bu
N#define CYREG_UDB_P1_ROUTE_HC60 0x400f333cu
N#define CYREG_UDB_P1_ROUTE_HC61 0x400f333du
N#define CYREG_UDB_P1_ROUTE_HC62 0x400f333eu
N#define CYREG_UDB_P1_ROUTE_HC63 0x400f333fu
N#define CYREG_UDB_P1_ROUTE_HC64 0x400f3340u
N#define CYREG_UDB_P1_ROUTE_HC65 0x400f3341u
N#define CYREG_UDB_P1_ROUTE_HC66 0x400f3342u
N#define CYREG_UDB_P1_ROUTE_HC67 0x400f3343u
N#define CYREG_UDB_P1_ROUTE_HC68 0x400f3344u
N#define CYREG_UDB_P1_ROUTE_HC69 0x400f3345u
N#define CYREG_UDB_P1_ROUTE_HC70 0x400f3346u
N#define CYREG_UDB_P1_ROUTE_HC71 0x400f3347u
N#define CYREG_UDB_P1_ROUTE_HC72 0x400f3348u
N#define CYREG_UDB_P1_ROUTE_HC73 0x400f3349u
N#define CYREG_UDB_P1_ROUTE_HC74 0x400f334au
N#define CYREG_UDB_P1_ROUTE_HC75 0x400f334bu
N#define CYREG_UDB_P1_ROUTE_HC76 0x400f334cu
N#define CYREG_UDB_P1_ROUTE_HC77 0x400f334du
N#define CYREG_UDB_P1_ROUTE_HC78 0x400f334eu
N#define CYREG_UDB_P1_ROUTE_HC79 0x400f334fu
N#define CYREG_UDB_P1_ROUTE_HC80 0x400f3350u
N#define CYREG_UDB_P1_ROUTE_HC81 0x400f3351u
N#define CYREG_UDB_P1_ROUTE_HC82 0x400f3352u
N#define CYREG_UDB_P1_ROUTE_HC83 0x400f3353u
N#define CYREG_UDB_P1_ROUTE_HC84 0x400f3354u
N#define CYREG_UDB_P1_ROUTE_HC85 0x400f3355u
N#define CYREG_UDB_P1_ROUTE_HC86 0x400f3356u
N#define CYREG_UDB_P1_ROUTE_HC87 0x400f3357u
N#define CYREG_UDB_P1_ROUTE_HC88 0x400f3358u
N#define CYREG_UDB_P1_ROUTE_HC89 0x400f3359u
N#define CYREG_UDB_P1_ROUTE_HC90 0x400f335au
N#define CYREG_UDB_P1_ROUTE_HC91 0x400f335bu
N#define CYREG_UDB_P1_ROUTE_HC92 0x400f335cu
N#define CYREG_UDB_P1_ROUTE_HC93 0x400f335du
N#define CYREG_UDB_P1_ROUTE_HC94 0x400f335eu
N#define CYREG_UDB_P1_ROUTE_HC95 0x400f335fu
N#define CYREG_UDB_P1_ROUTE_HC96 0x400f3360u
N#define CYREG_UDB_P1_ROUTE_HC97 0x400f3361u
N#define CYREG_UDB_P1_ROUTE_HC98 0x400f3362u
N#define CYREG_UDB_P1_ROUTE_HC99 0x400f3363u
N#define CYREG_UDB_P1_ROUTE_HC100 0x400f3364u
N#define CYREG_UDB_P1_ROUTE_HC101 0x400f3365u
N#define CYREG_UDB_P1_ROUTE_HC102 0x400f3366u
N#define CYREG_UDB_P1_ROUTE_HC103 0x400f3367u
N#define CYREG_UDB_P1_ROUTE_HC104 0x400f3368u
N#define CYREG_UDB_P1_ROUTE_HC105 0x400f3369u
N#define CYREG_UDB_P1_ROUTE_HC106 0x400f336au
N#define CYREG_UDB_P1_ROUTE_HC107 0x400f336bu
N#define CYREG_UDB_P1_ROUTE_HC108 0x400f336cu
N#define CYREG_UDB_P1_ROUTE_HC109 0x400f336du
N#define CYREG_UDB_P1_ROUTE_HC110 0x400f336eu
N#define CYREG_UDB_P1_ROUTE_HC111 0x400f336fu
N#define CYREG_UDB_P1_ROUTE_HC112 0x400f3370u
N#define CYREG_UDB_P1_ROUTE_HC113 0x400f3371u
N#define CYREG_UDB_P1_ROUTE_HC114 0x400f3372u
N#define CYREG_UDB_P1_ROUTE_HC115 0x400f3373u
N#define CYREG_UDB_P1_ROUTE_HC116 0x400f3374u
N#define CYREG_UDB_P1_ROUTE_HC117 0x400f3375u
N#define CYREG_UDB_P1_ROUTE_HC118 0x400f3376u
N#define CYREG_UDB_P1_ROUTE_HC119 0x400f3377u
N#define CYREG_UDB_P1_ROUTE_HC120 0x400f3378u
N#define CYREG_UDB_P1_ROUTE_HC121 0x400f3379u
N#define CYREG_UDB_P1_ROUTE_HC122 0x400f337au
N#define CYREG_UDB_P1_ROUTE_HC123 0x400f337bu
N#define CYREG_UDB_P1_ROUTE_HC124 0x400f337cu
N#define CYREG_UDB_P1_ROUTE_HC125 0x400f337du
N#define CYREG_UDB_P1_ROUTE_HC126 0x400f337eu
N#define CYREG_UDB_P1_ROUTE_HC127 0x400f337fu
N#define CYREG_UDB_P1_ROUTE_HV_L0 0x400f3380u
N#define CYREG_UDB_P1_ROUTE_HV_L1 0x400f3381u
N#define CYREG_UDB_P1_ROUTE_HV_L2 0x400f3382u
N#define CYREG_UDB_P1_ROUTE_HV_L3 0x400f3383u
N#define CYREG_UDB_P1_ROUTE_HV_L4 0x400f3384u
N#define CYREG_UDB_P1_ROUTE_HV_L5 0x400f3385u
N#define CYREG_UDB_P1_ROUTE_HV_L6 0x400f3386u
N#define CYREG_UDB_P1_ROUTE_HV_L7 0x400f3387u
N#define CYREG_UDB_P1_ROUTE_HV_L8 0x400f3388u
N#define CYREG_UDB_P1_ROUTE_HV_L9 0x400f3389u
N#define CYREG_UDB_P1_ROUTE_HV_L10 0x400f338au
N#define CYREG_UDB_P1_ROUTE_HV_L11 0x400f338bu
N#define CYREG_UDB_P1_ROUTE_HV_L12 0x400f338cu
N#define CYREG_UDB_P1_ROUTE_HV_L13 0x400f338du
N#define CYREG_UDB_P1_ROUTE_HV_L14 0x400f338eu
N#define CYREG_UDB_P1_ROUTE_HV_L15 0x400f338fu
N#define CYREG_UDB_P1_ROUTE_HS0 0x400f3390u
N#define CYREG_UDB_P1_ROUTE_HS1 0x400f3391u
N#define CYREG_UDB_P1_ROUTE_HS2 0x400f3392u
N#define CYREG_UDB_P1_ROUTE_HS3 0x400f3393u
N#define CYREG_UDB_P1_ROUTE_HS4 0x400f3394u
N#define CYREG_UDB_P1_ROUTE_HS5 0x400f3395u
N#define CYREG_UDB_P1_ROUTE_HS6 0x400f3396u
N#define CYREG_UDB_P1_ROUTE_HS7 0x400f3397u
N#define CYREG_UDB_P1_ROUTE_HS8 0x400f3398u
N#define CYREG_UDB_P1_ROUTE_HS9 0x400f3399u
N#define CYREG_UDB_P1_ROUTE_HS10 0x400f339au
N#define CYREG_UDB_P1_ROUTE_HS11 0x400f339bu
N#define CYREG_UDB_P1_ROUTE_HS12 0x400f339cu
N#define CYREG_UDB_P1_ROUTE_HS13 0x400f339du
N#define CYREG_UDB_P1_ROUTE_HS14 0x400f339eu
N#define CYREG_UDB_P1_ROUTE_HS15 0x400f339fu
N#define CYREG_UDB_P1_ROUTE_HS16 0x400f33a0u
N#define CYREG_UDB_P1_ROUTE_HS17 0x400f33a1u
N#define CYREG_UDB_P1_ROUTE_HS18 0x400f33a2u
N#define CYREG_UDB_P1_ROUTE_HS19 0x400f33a3u
N#define CYREG_UDB_P1_ROUTE_HS20 0x400f33a4u
N#define CYREG_UDB_P1_ROUTE_HS21 0x400f33a5u
N#define CYREG_UDB_P1_ROUTE_HS22 0x400f33a6u
N#define CYREG_UDB_P1_ROUTE_HS23 0x400f33a7u
N#define CYREG_UDB_P1_ROUTE_HV_R0 0x400f33a8u
N#define CYREG_UDB_P1_ROUTE_HV_R1 0x400f33a9u
N#define CYREG_UDB_P1_ROUTE_HV_R2 0x400f33aau
N#define CYREG_UDB_P1_ROUTE_HV_R3 0x400f33abu
N#define CYREG_UDB_P1_ROUTE_HV_R4 0x400f33acu
N#define CYREG_UDB_P1_ROUTE_HV_R5 0x400f33adu
N#define CYREG_UDB_P1_ROUTE_HV_R6 0x400f33aeu
N#define CYREG_UDB_P1_ROUTE_HV_R7 0x400f33afu
N#define CYREG_UDB_P1_ROUTE_HV_R8 0x400f33b0u
N#define CYREG_UDB_P1_ROUTE_HV_R9 0x400f33b1u
N#define CYREG_UDB_P1_ROUTE_HV_R10 0x400f33b2u
N#define CYREG_UDB_P1_ROUTE_HV_R11 0x400f33b3u
N#define CYREG_UDB_P1_ROUTE_HV_R12 0x400f33b4u
N#define CYREG_UDB_P1_ROUTE_HV_R13 0x400f33b5u
N#define CYREG_UDB_P1_ROUTE_HV_R14 0x400f33b6u
N#define CYREG_UDB_P1_ROUTE_HV_R15 0x400f33b7u
N#define CYREG_UDB_P1_ROUTE_PLD0IN0 0x400f33c0u
N#define CYREG_UDB_P1_ROUTE_PLD0IN1 0x400f33c2u
N#define CYREG_UDB_P1_ROUTE_PLD0IN2 0x400f33c4u
N#define CYREG_UDB_P1_ROUTE_PLD1IN0 0x400f33cau
N#define CYREG_UDB_P1_ROUTE_PLD1IN1 0x400f33ccu
N#define CYREG_UDB_P1_ROUTE_PLD1IN2 0x400f33ceu
N#define CYREG_UDB_P1_ROUTE_DPIN0 0x400f33d0u
N#define CYREG_UDB_P1_ROUTE_DPIN1 0x400f33d2u
N#define CYREG_UDB_P1_ROUTE_SCIN 0x400f33d6u
N#define CYREG_UDB_P1_ROUTE_SCIOIN 0x400f33d8u
N#define CYREG_UDB_P1_ROUTE_RCIN 0x400f33deu
N#define CYREG_UDB_P1_ROUTE_VS0 0x400f33e0u
N#define CYREG_UDB_P1_ROUTE_VS1 0x400f33e2u
N#define CYREG_UDB_P1_ROUTE_VS2 0x400f33e4u
N#define CYREG_UDB_P1_ROUTE_VS3 0x400f33e6u
N#define CYREG_UDB_P1_ROUTE_VS4 0x400f33e8u
N#define CYREG_UDB_P1_ROUTE_VS5 0x400f33eau
N#define CYREG_UDB_P1_ROUTE_VS6 0x400f33ecu
N#define CYREG_UDB_P1_ROUTE_VS7 0x400f33eeu
N#define CYDEV_UDB_DSI0_BASE 0x400f4000u
N#define CYDEV_UDB_DSI0_SIZE 0x00000100u
N#define CYREG_UDB_DSI0_HC0 0x400f4000u
N#define CYREG_UDB_DSI0_HC1 0x400f4001u
N#define CYREG_UDB_DSI0_HC2 0x400f4002u
N#define CYREG_UDB_DSI0_HC3 0x400f4003u
N#define CYREG_UDB_DSI0_HC4 0x400f4004u
N#define CYREG_UDB_DSI0_HC5 0x400f4005u
N#define CYREG_UDB_DSI0_HC6 0x400f4006u
N#define CYREG_UDB_DSI0_HC7 0x400f4007u
N#define CYREG_UDB_DSI0_HC8 0x400f4008u
N#define CYREG_UDB_DSI0_HC9 0x400f4009u
N#define CYREG_UDB_DSI0_HC10 0x400f400au
N#define CYREG_UDB_DSI0_HC11 0x400f400bu
N#define CYREG_UDB_DSI0_HC12 0x400f400cu
N#define CYREG_UDB_DSI0_HC13 0x400f400du
N#define CYREG_UDB_DSI0_HC14 0x400f400eu
N#define CYREG_UDB_DSI0_HC15 0x400f400fu
N#define CYREG_UDB_DSI0_HC16 0x400f4010u
N#define CYREG_UDB_DSI0_HC17 0x400f4011u
N#define CYREG_UDB_DSI0_HC18 0x400f4012u
N#define CYREG_UDB_DSI0_HC19 0x400f4013u
N#define CYREG_UDB_DSI0_HC20 0x400f4014u
N#define CYREG_UDB_DSI0_HC21 0x400f4015u
N#define CYREG_UDB_DSI0_HC22 0x400f4016u
N#define CYREG_UDB_DSI0_HC23 0x400f4017u
N#define CYREG_UDB_DSI0_HC24 0x400f4018u
N#define CYREG_UDB_DSI0_HC25 0x400f4019u
N#define CYREG_UDB_DSI0_HC26 0x400f401au
N#define CYREG_UDB_DSI0_HC27 0x400f401bu
N#define CYREG_UDB_DSI0_HC28 0x400f401cu
N#define CYREG_UDB_DSI0_HC29 0x400f401du
N#define CYREG_UDB_DSI0_HC30 0x400f401eu
N#define CYREG_UDB_DSI0_HC31 0x400f401fu
N#define CYREG_UDB_DSI0_HC32 0x400f4020u
N#define CYREG_UDB_DSI0_HC33 0x400f4021u
N#define CYREG_UDB_DSI0_HC34 0x400f4022u
N#define CYREG_UDB_DSI0_HC35 0x400f4023u
N#define CYREG_UDB_DSI0_HC36 0x400f4024u
N#define CYREG_UDB_DSI0_HC37 0x400f4025u
N#define CYREG_UDB_DSI0_HC38 0x400f4026u
N#define CYREG_UDB_DSI0_HC39 0x400f4027u
N#define CYREG_UDB_DSI0_HC40 0x400f4028u
N#define CYREG_UDB_DSI0_HC41 0x400f4029u
N#define CYREG_UDB_DSI0_HC42 0x400f402au
N#define CYREG_UDB_DSI0_HC43 0x400f402bu
N#define CYREG_UDB_DSI0_HC44 0x400f402cu
N#define CYREG_UDB_DSI0_HC45 0x400f402du
N#define CYREG_UDB_DSI0_HC46 0x400f402eu
N#define CYREG_UDB_DSI0_HC47 0x400f402fu
N#define CYREG_UDB_DSI0_HC48 0x400f4030u
N#define CYREG_UDB_DSI0_HC49 0x400f4031u
N#define CYREG_UDB_DSI0_HC50 0x400f4032u
N#define CYREG_UDB_DSI0_HC51 0x400f4033u
N#define CYREG_UDB_DSI0_HC52 0x400f4034u
N#define CYREG_UDB_DSI0_HC53 0x400f4035u
N#define CYREG_UDB_DSI0_HC54 0x400f4036u
N#define CYREG_UDB_DSI0_HC55 0x400f4037u
N#define CYREG_UDB_DSI0_HC56 0x400f4038u
N#define CYREG_UDB_DSI0_HC57 0x400f4039u
N#define CYREG_UDB_DSI0_HC58 0x400f403au
N#define CYREG_UDB_DSI0_HC59 0x400f403bu
N#define CYREG_UDB_DSI0_HC60 0x400f403cu
N#define CYREG_UDB_DSI0_HC61 0x400f403du
N#define CYREG_UDB_DSI0_HC62 0x400f403eu
N#define CYREG_UDB_DSI0_HC63 0x400f403fu
N#define CYREG_UDB_DSI0_HC64 0x400f4040u
N#define CYREG_UDB_DSI0_HC65 0x400f4041u
N#define CYREG_UDB_DSI0_HC66 0x400f4042u
N#define CYREG_UDB_DSI0_HC67 0x400f4043u
N#define CYREG_UDB_DSI0_HC68 0x400f4044u
N#define CYREG_UDB_DSI0_HC69 0x400f4045u
N#define CYREG_UDB_DSI0_HC70 0x400f4046u
N#define CYREG_UDB_DSI0_HC71 0x400f4047u
N#define CYREG_UDB_DSI0_HC72 0x400f4048u
N#define CYREG_UDB_DSI0_HC73 0x400f4049u
N#define CYREG_UDB_DSI0_HC74 0x400f404au
N#define CYREG_UDB_DSI0_HC75 0x400f404bu
N#define CYREG_UDB_DSI0_HC76 0x400f404cu
N#define CYREG_UDB_DSI0_HC77 0x400f404du
N#define CYREG_UDB_DSI0_HC78 0x400f404eu
N#define CYREG_UDB_DSI0_HC79 0x400f404fu
N#define CYREG_UDB_DSI0_HC80 0x400f4050u
N#define CYREG_UDB_DSI0_HC81 0x400f4051u
N#define CYREG_UDB_DSI0_HC82 0x400f4052u
N#define CYREG_UDB_DSI0_HC83 0x400f4053u
N#define CYREG_UDB_DSI0_HC84 0x400f4054u
N#define CYREG_UDB_DSI0_HC85 0x400f4055u
N#define CYREG_UDB_DSI0_HC86 0x400f4056u
N#define CYREG_UDB_DSI0_HC87 0x400f4057u
N#define CYREG_UDB_DSI0_HC88 0x400f4058u
N#define CYREG_UDB_DSI0_HC89 0x400f4059u
N#define CYREG_UDB_DSI0_HC90 0x400f405au
N#define CYREG_UDB_DSI0_HC91 0x400f405bu
N#define CYREG_UDB_DSI0_HC92 0x400f405cu
N#define CYREG_UDB_DSI0_HC93 0x400f405du
N#define CYREG_UDB_DSI0_HC94 0x400f405eu
N#define CYREG_UDB_DSI0_HC95 0x400f405fu
N#define CYREG_UDB_DSI0_HC96 0x400f4060u
N#define CYREG_UDB_DSI0_HC97 0x400f4061u
N#define CYREG_UDB_DSI0_HC98 0x400f4062u
N#define CYREG_UDB_DSI0_HC99 0x400f4063u
N#define CYREG_UDB_DSI0_HC100 0x400f4064u
N#define CYREG_UDB_DSI0_HC101 0x400f4065u
N#define CYREG_UDB_DSI0_HC102 0x400f4066u
N#define CYREG_UDB_DSI0_HC103 0x400f4067u
N#define CYREG_UDB_DSI0_HC104 0x400f4068u
N#define CYREG_UDB_DSI0_HC105 0x400f4069u
N#define CYREG_UDB_DSI0_HC106 0x400f406au
N#define CYREG_UDB_DSI0_HC107 0x400f406bu
N#define CYREG_UDB_DSI0_HC108 0x400f406cu
N#define CYREG_UDB_DSI0_HC109 0x400f406du
N#define CYREG_UDB_DSI0_HC110 0x400f406eu
N#define CYREG_UDB_DSI0_HC111 0x400f406fu
N#define CYREG_UDB_DSI0_HC112 0x400f4070u
N#define CYREG_UDB_DSI0_HC113 0x400f4071u
N#define CYREG_UDB_DSI0_HC114 0x400f4072u
N#define CYREG_UDB_DSI0_HC115 0x400f4073u
N#define CYREG_UDB_DSI0_HC116 0x400f4074u
N#define CYREG_UDB_DSI0_HC117 0x400f4075u
N#define CYREG_UDB_DSI0_HC118 0x400f4076u
N#define CYREG_UDB_DSI0_HC119 0x400f4077u
N#define CYREG_UDB_DSI0_HC120 0x400f4078u
N#define CYREG_UDB_DSI0_HC121 0x400f4079u
N#define CYREG_UDB_DSI0_HC122 0x400f407au
N#define CYREG_UDB_DSI0_HC123 0x400f407bu
N#define CYREG_UDB_DSI0_HC124 0x400f407cu
N#define CYREG_UDB_DSI0_HC125 0x400f407du
N#define CYREG_UDB_DSI0_HC126 0x400f407eu
N#define CYREG_UDB_DSI0_HC127 0x400f407fu
N#define CYREG_UDB_DSI0_HV_L0 0x400f4080u
N#define CYREG_UDB_DSI0_HV_L1 0x400f4081u
N#define CYREG_UDB_DSI0_HV_L2 0x400f4082u
N#define CYREG_UDB_DSI0_HV_L3 0x400f4083u
N#define CYREG_UDB_DSI0_HV_L4 0x400f4084u
N#define CYREG_UDB_DSI0_HV_L5 0x400f4085u
N#define CYREG_UDB_DSI0_HV_L6 0x400f4086u
N#define CYREG_UDB_DSI0_HV_L7 0x400f4087u
N#define CYREG_UDB_DSI0_HV_L8 0x400f4088u
N#define CYREG_UDB_DSI0_HV_L9 0x400f4089u
N#define CYREG_UDB_DSI0_HV_L10 0x400f408au
N#define CYREG_UDB_DSI0_HV_L11 0x400f408bu
N#define CYREG_UDB_DSI0_HV_L12 0x400f408cu
N#define CYREG_UDB_DSI0_HV_L13 0x400f408du
N#define CYREG_UDB_DSI0_HV_L14 0x400f408eu
N#define CYREG_UDB_DSI0_HV_L15 0x400f408fu
N#define CYREG_UDB_DSI0_HS0 0x400f4090u
N#define CYREG_UDB_DSI0_HS1 0x400f4091u
N#define CYREG_UDB_DSI0_HS2 0x400f4092u
N#define CYREG_UDB_DSI0_HS3 0x400f4093u
N#define CYREG_UDB_DSI0_HS4 0x400f4094u
N#define CYREG_UDB_DSI0_HS5 0x400f4095u
N#define CYREG_UDB_DSI0_HS6 0x400f4096u
N#define CYREG_UDB_DSI0_HS7 0x400f4097u
N#define CYREG_UDB_DSI0_HS8 0x400f4098u
N#define CYREG_UDB_DSI0_HS9 0x400f4099u
N#define CYREG_UDB_DSI0_HS10 0x400f409au
N#define CYREG_UDB_DSI0_HS11 0x400f409bu
N#define CYREG_UDB_DSI0_HS12 0x400f409cu
N#define CYREG_UDB_DSI0_HS13 0x400f409du
N#define CYREG_UDB_DSI0_HS14 0x400f409eu
N#define CYREG_UDB_DSI0_HS15 0x400f409fu
N#define CYREG_UDB_DSI0_HS16 0x400f40a0u
N#define CYREG_UDB_DSI0_HS17 0x400f40a1u
N#define CYREG_UDB_DSI0_HS18 0x400f40a2u
N#define CYREG_UDB_DSI0_HS19 0x400f40a3u
N#define CYREG_UDB_DSI0_HS20 0x400f40a4u
N#define CYREG_UDB_DSI0_HS21 0x400f40a5u
N#define CYREG_UDB_DSI0_HS22 0x400f40a6u
N#define CYREG_UDB_DSI0_HS23 0x400f40a7u
N#define CYREG_UDB_DSI0_HV_R0 0x400f40a8u
N#define CYREG_UDB_DSI0_HV_R1 0x400f40a9u
N#define CYREG_UDB_DSI0_HV_R2 0x400f40aau
N#define CYREG_UDB_DSI0_HV_R3 0x400f40abu
N#define CYREG_UDB_DSI0_HV_R4 0x400f40acu
N#define CYREG_UDB_DSI0_HV_R5 0x400f40adu
N#define CYREG_UDB_DSI0_HV_R6 0x400f40aeu
N#define CYREG_UDB_DSI0_HV_R7 0x400f40afu
N#define CYREG_UDB_DSI0_HV_R8 0x400f40b0u
N#define CYREG_UDB_DSI0_HV_R9 0x400f40b1u
N#define CYREG_UDB_DSI0_HV_R10 0x400f40b2u
N#define CYREG_UDB_DSI0_HV_R11 0x400f40b3u
N#define CYREG_UDB_DSI0_HV_R12 0x400f40b4u
N#define CYREG_UDB_DSI0_HV_R13 0x400f40b5u
N#define CYREG_UDB_DSI0_HV_R14 0x400f40b6u
N#define CYREG_UDB_DSI0_HV_R15 0x400f40b7u
N#define CYREG_UDB_DSI0_DSIINP0 0x400f40c0u
N#define CYREG_UDB_DSI0_DSIINP1 0x400f40c2u
N#define CYREG_UDB_DSI0_DSIINP2 0x400f40c4u
N#define CYREG_UDB_DSI0_DSIINP3 0x400f40c6u
N#define CYREG_UDB_DSI0_DSIINP4 0x400f40c8u
N#define CYREG_UDB_DSI0_DSIINP5 0x400f40cau
N#define CYREG_UDB_DSI0_DSIOUTP0 0x400f40ccu
N#define CYREG_UDB_DSI0_DSIOUTP1 0x400f40ceu
N#define CYREG_UDB_DSI0_DSIOUTP2 0x400f40d0u
N#define CYREG_UDB_DSI0_DSIOUTP3 0x400f40d2u
N#define CYREG_UDB_DSI0_DSIOUTT0 0x400f40d4u
N#define CYREG_UDB_DSI0_DSIOUTT1 0x400f40d6u
N#define CYREG_UDB_DSI0_DSIOUTT2 0x400f40d8u
N#define CYREG_UDB_DSI0_DSIOUTT3 0x400f40dau
N#define CYREG_UDB_DSI0_DSIOUTT4 0x400f40dcu
N#define CYREG_UDB_DSI0_DSIOUTT5 0x400f40deu
N#define CYREG_UDB_DSI0_VS0 0x400f40e0u
N#define CYREG_UDB_DSI0_VS1 0x400f40e2u
N#define CYREG_UDB_DSI0_VS2 0x400f40e4u
N#define CYREG_UDB_DSI0_VS3 0x400f40e6u
N#define CYREG_UDB_DSI0_VS4 0x400f40e8u
N#define CYREG_UDB_DSI0_VS5 0x400f40eau
N#define CYREG_UDB_DSI0_VS6 0x400f40ecu
N#define CYREG_UDB_DSI0_VS7 0x400f40eeu
N#define CYDEV_UDB_DSI1_BASE 0x400f4100u
N#define CYDEV_UDB_DSI1_SIZE 0x00000100u
N#define CYREG_UDB_DSI1_HC0 0x400f4100u
N#define CYREG_UDB_DSI1_HC1 0x400f4101u
N#define CYREG_UDB_DSI1_HC2 0x400f4102u
N#define CYREG_UDB_DSI1_HC3 0x400f4103u
N#define CYREG_UDB_DSI1_HC4 0x400f4104u
N#define CYREG_UDB_DSI1_HC5 0x400f4105u
N#define CYREG_UDB_DSI1_HC6 0x400f4106u
N#define CYREG_UDB_DSI1_HC7 0x400f4107u
N#define CYREG_UDB_DSI1_HC8 0x400f4108u
N#define CYREG_UDB_DSI1_HC9 0x400f4109u
N#define CYREG_UDB_DSI1_HC10 0x400f410au
N#define CYREG_UDB_DSI1_HC11 0x400f410bu
N#define CYREG_UDB_DSI1_HC12 0x400f410cu
N#define CYREG_UDB_DSI1_HC13 0x400f410du
N#define CYREG_UDB_DSI1_HC14 0x400f410eu
N#define CYREG_UDB_DSI1_HC15 0x400f410fu
N#define CYREG_UDB_DSI1_HC16 0x400f4110u
N#define CYREG_UDB_DSI1_HC17 0x400f4111u
N#define CYREG_UDB_DSI1_HC18 0x400f4112u
N#define CYREG_UDB_DSI1_HC19 0x400f4113u
N#define CYREG_UDB_DSI1_HC20 0x400f4114u
N#define CYREG_UDB_DSI1_HC21 0x400f4115u
N#define CYREG_UDB_DSI1_HC22 0x400f4116u
N#define CYREG_UDB_DSI1_HC23 0x400f4117u
N#define CYREG_UDB_DSI1_HC24 0x400f4118u
N#define CYREG_UDB_DSI1_HC25 0x400f4119u
N#define CYREG_UDB_DSI1_HC26 0x400f411au
N#define CYREG_UDB_DSI1_HC27 0x400f411bu
N#define CYREG_UDB_DSI1_HC28 0x400f411cu
N#define CYREG_UDB_DSI1_HC29 0x400f411du
N#define CYREG_UDB_DSI1_HC30 0x400f411eu
N#define CYREG_UDB_DSI1_HC31 0x400f411fu
N#define CYREG_UDB_DSI1_HC32 0x400f4120u
N#define CYREG_UDB_DSI1_HC33 0x400f4121u
N#define CYREG_UDB_DSI1_HC34 0x400f4122u
N#define CYREG_UDB_DSI1_HC35 0x400f4123u
N#define CYREG_UDB_DSI1_HC36 0x400f4124u
N#define CYREG_UDB_DSI1_HC37 0x400f4125u
N#define CYREG_UDB_DSI1_HC38 0x400f4126u
N#define CYREG_UDB_DSI1_HC39 0x400f4127u
N#define CYREG_UDB_DSI1_HC40 0x400f4128u
N#define CYREG_UDB_DSI1_HC41 0x400f4129u
N#define CYREG_UDB_DSI1_HC42 0x400f412au
N#define CYREG_UDB_DSI1_HC43 0x400f412bu
N#define CYREG_UDB_DSI1_HC44 0x400f412cu
N#define CYREG_UDB_DSI1_HC45 0x400f412du
N#define CYREG_UDB_DSI1_HC46 0x400f412eu
N#define CYREG_UDB_DSI1_HC47 0x400f412fu
N#define CYREG_UDB_DSI1_HC48 0x400f4130u
N#define CYREG_UDB_DSI1_HC49 0x400f4131u
N#define CYREG_UDB_DSI1_HC50 0x400f4132u
N#define CYREG_UDB_DSI1_HC51 0x400f4133u
N#define CYREG_UDB_DSI1_HC52 0x400f4134u
N#define CYREG_UDB_DSI1_HC53 0x400f4135u
N#define CYREG_UDB_DSI1_HC54 0x400f4136u
N#define CYREG_UDB_DSI1_HC55 0x400f4137u
N#define CYREG_UDB_DSI1_HC56 0x400f4138u
N#define CYREG_UDB_DSI1_HC57 0x400f4139u
N#define CYREG_UDB_DSI1_HC58 0x400f413au
N#define CYREG_UDB_DSI1_HC59 0x400f413bu
N#define CYREG_UDB_DSI1_HC60 0x400f413cu
N#define CYREG_UDB_DSI1_HC61 0x400f413du
N#define CYREG_UDB_DSI1_HC62 0x400f413eu
N#define CYREG_UDB_DSI1_HC63 0x400f413fu
N#define CYREG_UDB_DSI1_HC64 0x400f4140u
N#define CYREG_UDB_DSI1_HC65 0x400f4141u
N#define CYREG_UDB_DSI1_HC66 0x400f4142u
N#define CYREG_UDB_DSI1_HC67 0x400f4143u
N#define CYREG_UDB_DSI1_HC68 0x400f4144u
N#define CYREG_UDB_DSI1_HC69 0x400f4145u
N#define CYREG_UDB_DSI1_HC70 0x400f4146u
N#define CYREG_UDB_DSI1_HC71 0x400f4147u
N#define CYREG_UDB_DSI1_HC72 0x400f4148u
N#define CYREG_UDB_DSI1_HC73 0x400f4149u
N#define CYREG_UDB_DSI1_HC74 0x400f414au
N#define CYREG_UDB_DSI1_HC75 0x400f414bu
N#define CYREG_UDB_DSI1_HC76 0x400f414cu
N#define CYREG_UDB_DSI1_HC77 0x400f414du
N#define CYREG_UDB_DSI1_HC78 0x400f414eu
N#define CYREG_UDB_DSI1_HC79 0x400f414fu
N#define CYREG_UDB_DSI1_HC80 0x400f4150u
N#define CYREG_UDB_DSI1_HC81 0x400f4151u
N#define CYREG_UDB_DSI1_HC82 0x400f4152u
N#define CYREG_UDB_DSI1_HC83 0x400f4153u
N#define CYREG_UDB_DSI1_HC84 0x400f4154u
N#define CYREG_UDB_DSI1_HC85 0x400f4155u
N#define CYREG_UDB_DSI1_HC86 0x400f4156u
N#define CYREG_UDB_DSI1_HC87 0x400f4157u
N#define CYREG_UDB_DSI1_HC88 0x400f4158u
N#define CYREG_UDB_DSI1_HC89 0x400f4159u
N#define CYREG_UDB_DSI1_HC90 0x400f415au
N#define CYREG_UDB_DSI1_HC91 0x400f415bu
N#define CYREG_UDB_DSI1_HC92 0x400f415cu
N#define CYREG_UDB_DSI1_HC93 0x400f415du
N#define CYREG_UDB_DSI1_HC94 0x400f415eu
N#define CYREG_UDB_DSI1_HC95 0x400f415fu
N#define CYREG_UDB_DSI1_HC96 0x400f4160u
N#define CYREG_UDB_DSI1_HC97 0x400f4161u
N#define CYREG_UDB_DSI1_HC98 0x400f4162u
N#define CYREG_UDB_DSI1_HC99 0x400f4163u
N#define CYREG_UDB_DSI1_HC100 0x400f4164u
N#define CYREG_UDB_DSI1_HC101 0x400f4165u
N#define CYREG_UDB_DSI1_HC102 0x400f4166u
N#define CYREG_UDB_DSI1_HC103 0x400f4167u
N#define CYREG_UDB_DSI1_HC104 0x400f4168u
N#define CYREG_UDB_DSI1_HC105 0x400f4169u
N#define CYREG_UDB_DSI1_HC106 0x400f416au
N#define CYREG_UDB_DSI1_HC107 0x400f416bu
N#define CYREG_UDB_DSI1_HC108 0x400f416cu
N#define CYREG_UDB_DSI1_HC109 0x400f416du
N#define CYREG_UDB_DSI1_HC110 0x400f416eu
N#define CYREG_UDB_DSI1_HC111 0x400f416fu
N#define CYREG_UDB_DSI1_HC112 0x400f4170u
N#define CYREG_UDB_DSI1_HC113 0x400f4171u
N#define CYREG_UDB_DSI1_HC114 0x400f4172u
N#define CYREG_UDB_DSI1_HC115 0x400f4173u
N#define CYREG_UDB_DSI1_HC116 0x400f4174u
N#define CYREG_UDB_DSI1_HC117 0x400f4175u
N#define CYREG_UDB_DSI1_HC118 0x400f4176u
N#define CYREG_UDB_DSI1_HC119 0x400f4177u
N#define CYREG_UDB_DSI1_HC120 0x400f4178u
N#define CYREG_UDB_DSI1_HC121 0x400f4179u
N#define CYREG_UDB_DSI1_HC122 0x400f417au
N#define CYREG_UDB_DSI1_HC123 0x400f417bu
N#define CYREG_UDB_DSI1_HC124 0x400f417cu
N#define CYREG_UDB_DSI1_HC125 0x400f417du
N#define CYREG_UDB_DSI1_HC126 0x400f417eu
N#define CYREG_UDB_DSI1_HC127 0x400f417fu
N#define CYREG_UDB_DSI1_HV_L0 0x400f4180u
N#define CYREG_UDB_DSI1_HV_L1 0x400f4181u
N#define CYREG_UDB_DSI1_HV_L2 0x400f4182u
N#define CYREG_UDB_DSI1_HV_L3 0x400f4183u
N#define CYREG_UDB_DSI1_HV_L4 0x400f4184u
N#define CYREG_UDB_DSI1_HV_L5 0x400f4185u
N#define CYREG_UDB_DSI1_HV_L6 0x400f4186u
N#define CYREG_UDB_DSI1_HV_L7 0x400f4187u
N#define CYREG_UDB_DSI1_HV_L8 0x400f4188u
N#define CYREG_UDB_DSI1_HV_L9 0x400f4189u
N#define CYREG_UDB_DSI1_HV_L10 0x400f418au
N#define CYREG_UDB_DSI1_HV_L11 0x400f418bu
N#define CYREG_UDB_DSI1_HV_L12 0x400f418cu
N#define CYREG_UDB_DSI1_HV_L13 0x400f418du
N#define CYREG_UDB_DSI1_HV_L14 0x400f418eu
N#define CYREG_UDB_DSI1_HV_L15 0x400f418fu
N#define CYREG_UDB_DSI1_HS0 0x400f4190u
N#define CYREG_UDB_DSI1_HS1 0x400f4191u
N#define CYREG_UDB_DSI1_HS2 0x400f4192u
N#define CYREG_UDB_DSI1_HS3 0x400f4193u
N#define CYREG_UDB_DSI1_HS4 0x400f4194u
N#define CYREG_UDB_DSI1_HS5 0x400f4195u
N#define CYREG_UDB_DSI1_HS6 0x400f4196u
N#define CYREG_UDB_DSI1_HS7 0x400f4197u
N#define CYREG_UDB_DSI1_HS8 0x400f4198u
N#define CYREG_UDB_DSI1_HS9 0x400f4199u
N#define CYREG_UDB_DSI1_HS10 0x400f419au
N#define CYREG_UDB_DSI1_HS11 0x400f419bu
N#define CYREG_UDB_DSI1_HS12 0x400f419cu
N#define CYREG_UDB_DSI1_HS13 0x400f419du
N#define CYREG_UDB_DSI1_HS14 0x400f419eu
N#define CYREG_UDB_DSI1_HS15 0x400f419fu
N#define CYREG_UDB_DSI1_HS16 0x400f41a0u
N#define CYREG_UDB_DSI1_HS17 0x400f41a1u
N#define CYREG_UDB_DSI1_HS18 0x400f41a2u
N#define CYREG_UDB_DSI1_HS19 0x400f41a3u
N#define CYREG_UDB_DSI1_HS20 0x400f41a4u
N#define CYREG_UDB_DSI1_HS21 0x400f41a5u
N#define CYREG_UDB_DSI1_HS22 0x400f41a6u
N#define CYREG_UDB_DSI1_HS23 0x400f41a7u
N#define CYREG_UDB_DSI1_HV_R0 0x400f41a8u
N#define CYREG_UDB_DSI1_HV_R1 0x400f41a9u
N#define CYREG_UDB_DSI1_HV_R2 0x400f41aau
N#define CYREG_UDB_DSI1_HV_R3 0x400f41abu
N#define CYREG_UDB_DSI1_HV_R4 0x400f41acu
N#define CYREG_UDB_DSI1_HV_R5 0x400f41adu
N#define CYREG_UDB_DSI1_HV_R6 0x400f41aeu
N#define CYREG_UDB_DSI1_HV_R7 0x400f41afu
N#define CYREG_UDB_DSI1_HV_R8 0x400f41b0u
N#define CYREG_UDB_DSI1_HV_R9 0x400f41b1u
N#define CYREG_UDB_DSI1_HV_R10 0x400f41b2u
N#define CYREG_UDB_DSI1_HV_R11 0x400f41b3u
N#define CYREG_UDB_DSI1_HV_R12 0x400f41b4u
N#define CYREG_UDB_DSI1_HV_R13 0x400f41b5u
N#define CYREG_UDB_DSI1_HV_R14 0x400f41b6u
N#define CYREG_UDB_DSI1_HV_R15 0x400f41b7u
N#define CYREG_UDB_DSI1_DSIINP0 0x400f41c0u
N#define CYREG_UDB_DSI1_DSIINP1 0x400f41c2u
N#define CYREG_UDB_DSI1_DSIINP2 0x400f41c4u
N#define CYREG_UDB_DSI1_DSIINP3 0x400f41c6u
N#define CYREG_UDB_DSI1_DSIINP4 0x400f41c8u
N#define CYREG_UDB_DSI1_DSIINP5 0x400f41cau
N#define CYREG_UDB_DSI1_DSIOUTP0 0x400f41ccu
N#define CYREG_UDB_DSI1_DSIOUTP1 0x400f41ceu
N#define CYREG_UDB_DSI1_DSIOUTP2 0x400f41d0u
N#define CYREG_UDB_DSI1_DSIOUTP3 0x400f41d2u
N#define CYREG_UDB_DSI1_DSIOUTT0 0x400f41d4u
N#define CYREG_UDB_DSI1_DSIOUTT1 0x400f41d6u
N#define CYREG_UDB_DSI1_DSIOUTT2 0x400f41d8u
N#define CYREG_UDB_DSI1_DSIOUTT3 0x400f41dau
N#define CYREG_UDB_DSI1_DSIOUTT4 0x400f41dcu
N#define CYREG_UDB_DSI1_DSIOUTT5 0x400f41deu
N#define CYREG_UDB_DSI1_VS0 0x400f41e0u
N#define CYREG_UDB_DSI1_VS1 0x400f41e2u
N#define CYREG_UDB_DSI1_VS2 0x400f41e4u
N#define CYREG_UDB_DSI1_VS3 0x400f41e6u
N#define CYREG_UDB_DSI1_VS4 0x400f41e8u
N#define CYREG_UDB_DSI1_VS5 0x400f41eau
N#define CYREG_UDB_DSI1_VS6 0x400f41ecu
N#define CYREG_UDB_DSI1_VS7 0x400f41eeu
N#define CYDEV_UDB_DSI2_BASE 0x400f4200u
N#define CYDEV_UDB_DSI2_SIZE 0x00000100u
N#define CYREG_UDB_DSI2_HC0 0x400f4200u
N#define CYREG_UDB_DSI2_HC1 0x400f4201u
N#define CYREG_UDB_DSI2_HC2 0x400f4202u
N#define CYREG_UDB_DSI2_HC3 0x400f4203u
N#define CYREG_UDB_DSI2_HC4 0x400f4204u
N#define CYREG_UDB_DSI2_HC5 0x400f4205u
N#define CYREG_UDB_DSI2_HC6 0x400f4206u
N#define CYREG_UDB_DSI2_HC7 0x400f4207u
N#define CYREG_UDB_DSI2_HC8 0x400f4208u
N#define CYREG_UDB_DSI2_HC9 0x400f4209u
N#define CYREG_UDB_DSI2_HC10 0x400f420au
N#define CYREG_UDB_DSI2_HC11 0x400f420bu
N#define CYREG_UDB_DSI2_HC12 0x400f420cu
N#define CYREG_UDB_DSI2_HC13 0x400f420du
N#define CYREG_UDB_DSI2_HC14 0x400f420eu
N#define CYREG_UDB_DSI2_HC15 0x400f420fu
N#define CYREG_UDB_DSI2_HC16 0x400f4210u
N#define CYREG_UDB_DSI2_HC17 0x400f4211u
N#define CYREG_UDB_DSI2_HC18 0x400f4212u
N#define CYREG_UDB_DSI2_HC19 0x400f4213u
N#define CYREG_UDB_DSI2_HC20 0x400f4214u
N#define CYREG_UDB_DSI2_HC21 0x400f4215u
N#define CYREG_UDB_DSI2_HC22 0x400f4216u
N#define CYREG_UDB_DSI2_HC23 0x400f4217u
N#define CYREG_UDB_DSI2_HC24 0x400f4218u
N#define CYREG_UDB_DSI2_HC25 0x400f4219u
N#define CYREG_UDB_DSI2_HC26 0x400f421au
N#define CYREG_UDB_DSI2_HC27 0x400f421bu
N#define CYREG_UDB_DSI2_HC28 0x400f421cu
N#define CYREG_UDB_DSI2_HC29 0x400f421du
N#define CYREG_UDB_DSI2_HC30 0x400f421eu
N#define CYREG_UDB_DSI2_HC31 0x400f421fu
N#define CYREG_UDB_DSI2_HC32 0x400f4220u
N#define CYREG_UDB_DSI2_HC33 0x400f4221u
N#define CYREG_UDB_DSI2_HC34 0x400f4222u
N#define CYREG_UDB_DSI2_HC35 0x400f4223u
N#define CYREG_UDB_DSI2_HC36 0x400f4224u
N#define CYREG_UDB_DSI2_HC37 0x400f4225u
N#define CYREG_UDB_DSI2_HC38 0x400f4226u
N#define CYREG_UDB_DSI2_HC39 0x400f4227u
N#define CYREG_UDB_DSI2_HC40 0x400f4228u
N#define CYREG_UDB_DSI2_HC41 0x400f4229u
N#define CYREG_UDB_DSI2_HC42 0x400f422au
N#define CYREG_UDB_DSI2_HC43 0x400f422bu
N#define CYREG_UDB_DSI2_HC44 0x400f422cu
N#define CYREG_UDB_DSI2_HC45 0x400f422du
N#define CYREG_UDB_DSI2_HC46 0x400f422eu
N#define CYREG_UDB_DSI2_HC47 0x400f422fu
N#define CYREG_UDB_DSI2_HC48 0x400f4230u
N#define CYREG_UDB_DSI2_HC49 0x400f4231u
N#define CYREG_UDB_DSI2_HC50 0x400f4232u
N#define CYREG_UDB_DSI2_HC51 0x400f4233u
N#define CYREG_UDB_DSI2_HC52 0x400f4234u
N#define CYREG_UDB_DSI2_HC53 0x400f4235u
N#define CYREG_UDB_DSI2_HC54 0x400f4236u
N#define CYREG_UDB_DSI2_HC55 0x400f4237u
N#define CYREG_UDB_DSI2_HC56 0x400f4238u
N#define CYREG_UDB_DSI2_HC57 0x400f4239u
N#define CYREG_UDB_DSI2_HC58 0x400f423au
N#define CYREG_UDB_DSI2_HC59 0x400f423bu
N#define CYREG_UDB_DSI2_HC60 0x400f423cu
N#define CYREG_UDB_DSI2_HC61 0x400f423du
N#define CYREG_UDB_DSI2_HC62 0x400f423eu
N#define CYREG_UDB_DSI2_HC63 0x400f423fu
N#define CYREG_UDB_DSI2_HC64 0x400f4240u
N#define CYREG_UDB_DSI2_HC65 0x400f4241u
N#define CYREG_UDB_DSI2_HC66 0x400f4242u
N#define CYREG_UDB_DSI2_HC67 0x400f4243u
N#define CYREG_UDB_DSI2_HC68 0x400f4244u
N#define CYREG_UDB_DSI2_HC69 0x400f4245u
N#define CYREG_UDB_DSI2_HC70 0x400f4246u
N#define CYREG_UDB_DSI2_HC71 0x400f4247u
N#define CYREG_UDB_DSI2_HC72 0x400f4248u
N#define CYREG_UDB_DSI2_HC73 0x400f4249u
N#define CYREG_UDB_DSI2_HC74 0x400f424au
N#define CYREG_UDB_DSI2_HC75 0x400f424bu
N#define CYREG_UDB_DSI2_HC76 0x400f424cu
N#define CYREG_UDB_DSI2_HC77 0x400f424du
N#define CYREG_UDB_DSI2_HC78 0x400f424eu
N#define CYREG_UDB_DSI2_HC79 0x400f424fu
N#define CYREG_UDB_DSI2_HC80 0x400f4250u
N#define CYREG_UDB_DSI2_HC81 0x400f4251u
N#define CYREG_UDB_DSI2_HC82 0x400f4252u
N#define CYREG_UDB_DSI2_HC83 0x400f4253u
N#define CYREG_UDB_DSI2_HC84 0x400f4254u
N#define CYREG_UDB_DSI2_HC85 0x400f4255u
N#define CYREG_UDB_DSI2_HC86 0x400f4256u
N#define CYREG_UDB_DSI2_HC87 0x400f4257u
N#define CYREG_UDB_DSI2_HC88 0x400f4258u
N#define CYREG_UDB_DSI2_HC89 0x400f4259u
N#define CYREG_UDB_DSI2_HC90 0x400f425au
N#define CYREG_UDB_DSI2_HC91 0x400f425bu
N#define CYREG_UDB_DSI2_HC92 0x400f425cu
N#define CYREG_UDB_DSI2_HC93 0x400f425du
N#define CYREG_UDB_DSI2_HC94 0x400f425eu
N#define CYREG_UDB_DSI2_HC95 0x400f425fu
N#define CYREG_UDB_DSI2_HC96 0x400f4260u
N#define CYREG_UDB_DSI2_HC97 0x400f4261u
N#define CYREG_UDB_DSI2_HC98 0x400f4262u
N#define CYREG_UDB_DSI2_HC99 0x400f4263u
N#define CYREG_UDB_DSI2_HC100 0x400f4264u
N#define CYREG_UDB_DSI2_HC101 0x400f4265u
N#define CYREG_UDB_DSI2_HC102 0x400f4266u
N#define CYREG_UDB_DSI2_HC103 0x400f4267u
N#define CYREG_UDB_DSI2_HC104 0x400f4268u
N#define CYREG_UDB_DSI2_HC105 0x400f4269u
N#define CYREG_UDB_DSI2_HC106 0x400f426au
N#define CYREG_UDB_DSI2_HC107 0x400f426bu
N#define CYREG_UDB_DSI2_HC108 0x400f426cu
N#define CYREG_UDB_DSI2_HC109 0x400f426du
N#define CYREG_UDB_DSI2_HC110 0x400f426eu
N#define CYREG_UDB_DSI2_HC111 0x400f426fu
N#define CYREG_UDB_DSI2_HC112 0x400f4270u
N#define CYREG_UDB_DSI2_HC113 0x400f4271u
N#define CYREG_UDB_DSI2_HC114 0x400f4272u
N#define CYREG_UDB_DSI2_HC115 0x400f4273u
N#define CYREG_UDB_DSI2_HC116 0x400f4274u
N#define CYREG_UDB_DSI2_HC117 0x400f4275u
N#define CYREG_UDB_DSI2_HC118 0x400f4276u
N#define CYREG_UDB_DSI2_HC119 0x400f4277u
N#define CYREG_UDB_DSI2_HC120 0x400f4278u
N#define CYREG_UDB_DSI2_HC121 0x400f4279u
N#define CYREG_UDB_DSI2_HC122 0x400f427au
N#define CYREG_UDB_DSI2_HC123 0x400f427bu
N#define CYREG_UDB_DSI2_HC124 0x400f427cu
N#define CYREG_UDB_DSI2_HC125 0x400f427du
N#define CYREG_UDB_DSI2_HC126 0x400f427eu
N#define CYREG_UDB_DSI2_HC127 0x400f427fu
N#define CYREG_UDB_DSI2_HV_L0 0x400f4280u
N#define CYREG_UDB_DSI2_HV_L1 0x400f4281u
N#define CYREG_UDB_DSI2_HV_L2 0x400f4282u
N#define CYREG_UDB_DSI2_HV_L3 0x400f4283u
N#define CYREG_UDB_DSI2_HV_L4 0x400f4284u
N#define CYREG_UDB_DSI2_HV_L5 0x400f4285u
N#define CYREG_UDB_DSI2_HV_L6 0x400f4286u
N#define CYREG_UDB_DSI2_HV_L7 0x400f4287u
N#define CYREG_UDB_DSI2_HV_L8 0x400f4288u
N#define CYREG_UDB_DSI2_HV_L9 0x400f4289u
N#define CYREG_UDB_DSI2_HV_L10 0x400f428au
N#define CYREG_UDB_DSI2_HV_L11 0x400f428bu
N#define CYREG_UDB_DSI2_HV_L12 0x400f428cu
N#define CYREG_UDB_DSI2_HV_L13 0x400f428du
N#define CYREG_UDB_DSI2_HV_L14 0x400f428eu
N#define CYREG_UDB_DSI2_HV_L15 0x400f428fu
N#define CYREG_UDB_DSI2_HS0 0x400f4290u
N#define CYREG_UDB_DSI2_HS1 0x400f4291u
N#define CYREG_UDB_DSI2_HS2 0x400f4292u
N#define CYREG_UDB_DSI2_HS3 0x400f4293u
N#define CYREG_UDB_DSI2_HS4 0x400f4294u
N#define CYREG_UDB_DSI2_HS5 0x400f4295u
N#define CYREG_UDB_DSI2_HS6 0x400f4296u
N#define CYREG_UDB_DSI2_HS7 0x400f4297u
N#define CYREG_UDB_DSI2_HS8 0x400f4298u
N#define CYREG_UDB_DSI2_HS9 0x400f4299u
N#define CYREG_UDB_DSI2_HS10 0x400f429au
N#define CYREG_UDB_DSI2_HS11 0x400f429bu
N#define CYREG_UDB_DSI2_HS12 0x400f429cu
N#define CYREG_UDB_DSI2_HS13 0x400f429du
N#define CYREG_UDB_DSI2_HS14 0x400f429eu
N#define CYREG_UDB_DSI2_HS15 0x400f429fu
N#define CYREG_UDB_DSI2_HS16 0x400f42a0u
N#define CYREG_UDB_DSI2_HS17 0x400f42a1u
N#define CYREG_UDB_DSI2_HS18 0x400f42a2u
N#define CYREG_UDB_DSI2_HS19 0x400f42a3u
N#define CYREG_UDB_DSI2_HS20 0x400f42a4u
N#define CYREG_UDB_DSI2_HS21 0x400f42a5u
N#define CYREG_UDB_DSI2_HS22 0x400f42a6u
N#define CYREG_UDB_DSI2_HS23 0x400f42a7u
N#define CYREG_UDB_DSI2_HV_R0 0x400f42a8u
N#define CYREG_UDB_DSI2_HV_R1 0x400f42a9u
N#define CYREG_UDB_DSI2_HV_R2 0x400f42aau
N#define CYREG_UDB_DSI2_HV_R3 0x400f42abu
N#define CYREG_UDB_DSI2_HV_R4 0x400f42acu
N#define CYREG_UDB_DSI2_HV_R5 0x400f42adu
N#define CYREG_UDB_DSI2_HV_R6 0x400f42aeu
N#define CYREG_UDB_DSI2_HV_R7 0x400f42afu
N#define CYREG_UDB_DSI2_HV_R8 0x400f42b0u
N#define CYREG_UDB_DSI2_HV_R9 0x400f42b1u
N#define CYREG_UDB_DSI2_HV_R10 0x400f42b2u
N#define CYREG_UDB_DSI2_HV_R11 0x400f42b3u
N#define CYREG_UDB_DSI2_HV_R12 0x400f42b4u
N#define CYREG_UDB_DSI2_HV_R13 0x400f42b5u
N#define CYREG_UDB_DSI2_HV_R14 0x400f42b6u
N#define CYREG_UDB_DSI2_HV_R15 0x400f42b7u
N#define CYREG_UDB_DSI2_DSIINP0 0x400f42c0u
N#define CYREG_UDB_DSI2_DSIINP1 0x400f42c2u
N#define CYREG_UDB_DSI2_DSIINP2 0x400f42c4u
N#define CYREG_UDB_DSI2_DSIINP3 0x400f42c6u
N#define CYREG_UDB_DSI2_DSIINP4 0x400f42c8u
N#define CYREG_UDB_DSI2_DSIINP5 0x400f42cau
N#define CYREG_UDB_DSI2_DSIOUTP0 0x400f42ccu
N#define CYREG_UDB_DSI2_DSIOUTP1 0x400f42ceu
N#define CYREG_UDB_DSI2_DSIOUTP2 0x400f42d0u
N#define CYREG_UDB_DSI2_DSIOUTP3 0x400f42d2u
N#define CYREG_UDB_DSI2_DSIOUTT0 0x400f42d4u
N#define CYREG_UDB_DSI2_DSIOUTT1 0x400f42d6u
N#define CYREG_UDB_DSI2_DSIOUTT2 0x400f42d8u
N#define CYREG_UDB_DSI2_DSIOUTT3 0x400f42dau
N#define CYREG_UDB_DSI2_DSIOUTT4 0x400f42dcu
N#define CYREG_UDB_DSI2_DSIOUTT5 0x400f42deu
N#define CYREG_UDB_DSI2_VS0 0x400f42e0u
N#define CYREG_UDB_DSI2_VS1 0x400f42e2u
N#define CYREG_UDB_DSI2_VS2 0x400f42e4u
N#define CYREG_UDB_DSI2_VS3 0x400f42e6u
N#define CYREG_UDB_DSI2_VS4 0x400f42e8u
N#define CYREG_UDB_DSI2_VS5 0x400f42eau
N#define CYREG_UDB_DSI2_VS6 0x400f42ecu
N#define CYREG_UDB_DSI2_VS7 0x400f42eeu
N#define CYDEV_UDB_DSI3_BASE 0x400f4300u
N#define CYDEV_UDB_DSI3_SIZE 0x00000100u
N#define CYREG_UDB_DSI3_HC0 0x400f4300u
N#define CYREG_UDB_DSI3_HC1 0x400f4301u
N#define CYREG_UDB_DSI3_HC2 0x400f4302u
N#define CYREG_UDB_DSI3_HC3 0x400f4303u
N#define CYREG_UDB_DSI3_HC4 0x400f4304u
N#define CYREG_UDB_DSI3_HC5 0x400f4305u
N#define CYREG_UDB_DSI3_HC6 0x400f4306u
N#define CYREG_UDB_DSI3_HC7 0x400f4307u
N#define CYREG_UDB_DSI3_HC8 0x400f4308u
N#define CYREG_UDB_DSI3_HC9 0x400f4309u
N#define CYREG_UDB_DSI3_HC10 0x400f430au
N#define CYREG_UDB_DSI3_HC11 0x400f430bu
N#define CYREG_UDB_DSI3_HC12 0x400f430cu
N#define CYREG_UDB_DSI3_HC13 0x400f430du
N#define CYREG_UDB_DSI3_HC14 0x400f430eu
N#define CYREG_UDB_DSI3_HC15 0x400f430fu
N#define CYREG_UDB_DSI3_HC16 0x400f4310u
N#define CYREG_UDB_DSI3_HC17 0x400f4311u
N#define CYREG_UDB_DSI3_HC18 0x400f4312u
N#define CYREG_UDB_DSI3_HC19 0x400f4313u
N#define CYREG_UDB_DSI3_HC20 0x400f4314u
N#define CYREG_UDB_DSI3_HC21 0x400f4315u
N#define CYREG_UDB_DSI3_HC22 0x400f4316u
N#define CYREG_UDB_DSI3_HC23 0x400f4317u
N#define CYREG_UDB_DSI3_HC24 0x400f4318u
N#define CYREG_UDB_DSI3_HC25 0x400f4319u
N#define CYREG_UDB_DSI3_HC26 0x400f431au
N#define CYREG_UDB_DSI3_HC27 0x400f431bu
N#define CYREG_UDB_DSI3_HC28 0x400f431cu
N#define CYREG_UDB_DSI3_HC29 0x400f431du
N#define CYREG_UDB_DSI3_HC30 0x400f431eu
N#define CYREG_UDB_DSI3_HC31 0x400f431fu
N#define CYREG_UDB_DSI3_HC32 0x400f4320u
N#define CYREG_UDB_DSI3_HC33 0x400f4321u
N#define CYREG_UDB_DSI3_HC34 0x400f4322u
N#define CYREG_UDB_DSI3_HC35 0x400f4323u
N#define CYREG_UDB_DSI3_HC36 0x400f4324u
N#define CYREG_UDB_DSI3_HC37 0x400f4325u
N#define CYREG_UDB_DSI3_HC38 0x400f4326u
N#define CYREG_UDB_DSI3_HC39 0x400f4327u
N#define CYREG_UDB_DSI3_HC40 0x400f4328u
N#define CYREG_UDB_DSI3_HC41 0x400f4329u
N#define CYREG_UDB_DSI3_HC42 0x400f432au
N#define CYREG_UDB_DSI3_HC43 0x400f432bu
N#define CYREG_UDB_DSI3_HC44 0x400f432cu
N#define CYREG_UDB_DSI3_HC45 0x400f432du
N#define CYREG_UDB_DSI3_HC46 0x400f432eu
N#define CYREG_UDB_DSI3_HC47 0x400f432fu
N#define CYREG_UDB_DSI3_HC48 0x400f4330u
N#define CYREG_UDB_DSI3_HC49 0x400f4331u
N#define CYREG_UDB_DSI3_HC50 0x400f4332u
N#define CYREG_UDB_DSI3_HC51 0x400f4333u
N#define CYREG_UDB_DSI3_HC52 0x400f4334u
N#define CYREG_UDB_DSI3_HC53 0x400f4335u
N#define CYREG_UDB_DSI3_HC54 0x400f4336u
N#define CYREG_UDB_DSI3_HC55 0x400f4337u
N#define CYREG_UDB_DSI3_HC56 0x400f4338u
N#define CYREG_UDB_DSI3_HC57 0x400f4339u
N#define CYREG_UDB_DSI3_HC58 0x400f433au
N#define CYREG_UDB_DSI3_HC59 0x400f433bu
N#define CYREG_UDB_DSI3_HC60 0x400f433cu
N#define CYREG_UDB_DSI3_HC61 0x400f433du
N#define CYREG_UDB_DSI3_HC62 0x400f433eu
N#define CYREG_UDB_DSI3_HC63 0x400f433fu
N#define CYREG_UDB_DSI3_HC64 0x400f4340u
N#define CYREG_UDB_DSI3_HC65 0x400f4341u
N#define CYREG_UDB_DSI3_HC66 0x400f4342u
N#define CYREG_UDB_DSI3_HC67 0x400f4343u
N#define CYREG_UDB_DSI3_HC68 0x400f4344u
N#define CYREG_UDB_DSI3_HC69 0x400f4345u
N#define CYREG_UDB_DSI3_HC70 0x400f4346u
N#define CYREG_UDB_DSI3_HC71 0x400f4347u
N#define CYREG_UDB_DSI3_HC72 0x400f4348u
N#define CYREG_UDB_DSI3_HC73 0x400f4349u
N#define CYREG_UDB_DSI3_HC74 0x400f434au
N#define CYREG_UDB_DSI3_HC75 0x400f434bu
N#define CYREG_UDB_DSI3_HC76 0x400f434cu
N#define CYREG_UDB_DSI3_HC77 0x400f434du
N#define CYREG_UDB_DSI3_HC78 0x400f434eu
N#define CYREG_UDB_DSI3_HC79 0x400f434fu
N#define CYREG_UDB_DSI3_HC80 0x400f4350u
N#define CYREG_UDB_DSI3_HC81 0x400f4351u
N#define CYREG_UDB_DSI3_HC82 0x400f4352u
N#define CYREG_UDB_DSI3_HC83 0x400f4353u
N#define CYREG_UDB_DSI3_HC84 0x400f4354u
N#define CYREG_UDB_DSI3_HC85 0x400f4355u
N#define CYREG_UDB_DSI3_HC86 0x400f4356u
N#define CYREG_UDB_DSI3_HC87 0x400f4357u
N#define CYREG_UDB_DSI3_HC88 0x400f4358u
N#define CYREG_UDB_DSI3_HC89 0x400f4359u
N#define CYREG_UDB_DSI3_HC90 0x400f435au
N#define CYREG_UDB_DSI3_HC91 0x400f435bu
N#define CYREG_UDB_DSI3_HC92 0x400f435cu
N#define CYREG_UDB_DSI3_HC93 0x400f435du
N#define CYREG_UDB_DSI3_HC94 0x400f435eu
N#define CYREG_UDB_DSI3_HC95 0x400f435fu
N#define CYREG_UDB_DSI3_HC96 0x400f4360u
N#define CYREG_UDB_DSI3_HC97 0x400f4361u
N#define CYREG_UDB_DSI3_HC98 0x400f4362u
N#define CYREG_UDB_DSI3_HC99 0x400f4363u
N#define CYREG_UDB_DSI3_HC100 0x400f4364u
N#define CYREG_UDB_DSI3_HC101 0x400f4365u
N#define CYREG_UDB_DSI3_HC102 0x400f4366u
N#define CYREG_UDB_DSI3_HC103 0x400f4367u
N#define CYREG_UDB_DSI3_HC104 0x400f4368u
N#define CYREG_UDB_DSI3_HC105 0x400f4369u
N#define CYREG_UDB_DSI3_HC106 0x400f436au
N#define CYREG_UDB_DSI3_HC107 0x400f436bu
N#define CYREG_UDB_DSI3_HC108 0x400f436cu
N#define CYREG_UDB_DSI3_HC109 0x400f436du
N#define CYREG_UDB_DSI3_HC110 0x400f436eu
N#define CYREG_UDB_DSI3_HC111 0x400f436fu
N#define CYREG_UDB_DSI3_HC112 0x400f4370u
N#define CYREG_UDB_DSI3_HC113 0x400f4371u
N#define CYREG_UDB_DSI3_HC114 0x400f4372u
N#define CYREG_UDB_DSI3_HC115 0x400f4373u
N#define CYREG_UDB_DSI3_HC116 0x400f4374u
N#define CYREG_UDB_DSI3_HC117 0x400f4375u
N#define CYREG_UDB_DSI3_HC118 0x400f4376u
N#define CYREG_UDB_DSI3_HC119 0x400f4377u
N#define CYREG_UDB_DSI3_HC120 0x400f4378u
N#define CYREG_UDB_DSI3_HC121 0x400f4379u
N#define CYREG_UDB_DSI3_HC122 0x400f437au
N#define CYREG_UDB_DSI3_HC123 0x400f437bu
N#define CYREG_UDB_DSI3_HC124 0x400f437cu
N#define CYREG_UDB_DSI3_HC125 0x400f437du
N#define CYREG_UDB_DSI3_HC126 0x400f437eu
N#define CYREG_UDB_DSI3_HC127 0x400f437fu
N#define CYREG_UDB_DSI3_HV_L0 0x400f4380u
N#define CYREG_UDB_DSI3_HV_L1 0x400f4381u
N#define CYREG_UDB_DSI3_HV_L2 0x400f4382u
N#define CYREG_UDB_DSI3_HV_L3 0x400f4383u
N#define CYREG_UDB_DSI3_HV_L4 0x400f4384u
N#define CYREG_UDB_DSI3_HV_L5 0x400f4385u
N#define CYREG_UDB_DSI3_HV_L6 0x400f4386u
N#define CYREG_UDB_DSI3_HV_L7 0x400f4387u
N#define CYREG_UDB_DSI3_HV_L8 0x400f4388u
N#define CYREG_UDB_DSI3_HV_L9 0x400f4389u
N#define CYREG_UDB_DSI3_HV_L10 0x400f438au
N#define CYREG_UDB_DSI3_HV_L11 0x400f438bu
N#define CYREG_UDB_DSI3_HV_L12 0x400f438cu
N#define CYREG_UDB_DSI3_HV_L13 0x400f438du
N#define CYREG_UDB_DSI3_HV_L14 0x400f438eu
N#define CYREG_UDB_DSI3_HV_L15 0x400f438fu
N#define CYREG_UDB_DSI3_HS0 0x400f4390u
N#define CYREG_UDB_DSI3_HS1 0x400f4391u
N#define CYREG_UDB_DSI3_HS2 0x400f4392u
N#define CYREG_UDB_DSI3_HS3 0x400f4393u
N#define CYREG_UDB_DSI3_HS4 0x400f4394u
N#define CYREG_UDB_DSI3_HS5 0x400f4395u
N#define CYREG_UDB_DSI3_HS6 0x400f4396u
N#define CYREG_UDB_DSI3_HS7 0x400f4397u
N#define CYREG_UDB_DSI3_HS8 0x400f4398u
N#define CYREG_UDB_DSI3_HS9 0x400f4399u
N#define CYREG_UDB_DSI3_HS10 0x400f439au
N#define CYREG_UDB_DSI3_HS11 0x400f439bu
N#define CYREG_UDB_DSI3_HS12 0x400f439cu
N#define CYREG_UDB_DSI3_HS13 0x400f439du
N#define CYREG_UDB_DSI3_HS14 0x400f439eu
N#define CYREG_UDB_DSI3_HS15 0x400f439fu
N#define CYREG_UDB_DSI3_HS16 0x400f43a0u
N#define CYREG_UDB_DSI3_HS17 0x400f43a1u
N#define CYREG_UDB_DSI3_HS18 0x400f43a2u
N#define CYREG_UDB_DSI3_HS19 0x400f43a3u
N#define CYREG_UDB_DSI3_HS20 0x400f43a4u
N#define CYREG_UDB_DSI3_HS21 0x400f43a5u
N#define CYREG_UDB_DSI3_HS22 0x400f43a6u
N#define CYREG_UDB_DSI3_HS23 0x400f43a7u
N#define CYREG_UDB_DSI3_HV_R0 0x400f43a8u
N#define CYREG_UDB_DSI3_HV_R1 0x400f43a9u
N#define CYREG_UDB_DSI3_HV_R2 0x400f43aau
N#define CYREG_UDB_DSI3_HV_R3 0x400f43abu
N#define CYREG_UDB_DSI3_HV_R4 0x400f43acu
N#define CYREG_UDB_DSI3_HV_R5 0x400f43adu
N#define CYREG_UDB_DSI3_HV_R6 0x400f43aeu
N#define CYREG_UDB_DSI3_HV_R7 0x400f43afu
N#define CYREG_UDB_DSI3_HV_R8 0x400f43b0u
N#define CYREG_UDB_DSI3_HV_R9 0x400f43b1u
N#define CYREG_UDB_DSI3_HV_R10 0x400f43b2u
N#define CYREG_UDB_DSI3_HV_R11 0x400f43b3u
N#define CYREG_UDB_DSI3_HV_R12 0x400f43b4u
N#define CYREG_UDB_DSI3_HV_R13 0x400f43b5u
N#define CYREG_UDB_DSI3_HV_R14 0x400f43b6u
N#define CYREG_UDB_DSI3_HV_R15 0x400f43b7u
N#define CYREG_UDB_DSI3_DSIINP0 0x400f43c0u
N#define CYREG_UDB_DSI3_DSIINP1 0x400f43c2u
N#define CYREG_UDB_DSI3_DSIINP2 0x400f43c4u
N#define CYREG_UDB_DSI3_DSIINP3 0x400f43c6u
N#define CYREG_UDB_DSI3_DSIINP4 0x400f43c8u
N#define CYREG_UDB_DSI3_DSIINP5 0x400f43cau
N#define CYREG_UDB_DSI3_DSIOUTP0 0x400f43ccu
N#define CYREG_UDB_DSI3_DSIOUTP1 0x400f43ceu
N#define CYREG_UDB_DSI3_DSIOUTP2 0x400f43d0u
N#define CYREG_UDB_DSI3_DSIOUTP3 0x400f43d2u
N#define CYREG_UDB_DSI3_DSIOUTT0 0x400f43d4u
N#define CYREG_UDB_DSI3_DSIOUTT1 0x400f43d6u
N#define CYREG_UDB_DSI3_DSIOUTT2 0x400f43d8u
N#define CYREG_UDB_DSI3_DSIOUTT3 0x400f43dau
N#define CYREG_UDB_DSI3_DSIOUTT4 0x400f43dcu
N#define CYREG_UDB_DSI3_DSIOUTT5 0x400f43deu
N#define CYREG_UDB_DSI3_VS0 0x400f43e0u
N#define CYREG_UDB_DSI3_VS1 0x400f43e2u
N#define CYREG_UDB_DSI3_VS2 0x400f43e4u
N#define CYREG_UDB_DSI3_VS3 0x400f43e6u
N#define CYREG_UDB_DSI3_VS4 0x400f43e8u
N#define CYREG_UDB_DSI3_VS5 0x400f43eau
N#define CYREG_UDB_DSI3_VS6 0x400f43ecu
N#define CYREG_UDB_DSI3_VS7 0x400f43eeu
N#define CYDEV_UDB_PA0_BASE 0x400f5000u
N#define CYDEV_UDB_PA0_SIZE 0x00000010u
N#define CYREG_UDB_PA0_CFG0 0x400f5000u
N#define CYREG_UDB_PA0_CFG1 0x400f5001u
N#define CYREG_UDB_PA0_CFG2 0x400f5002u
N#define CYREG_UDB_PA0_CFG3 0x400f5003u
N#define CYREG_UDB_PA0_CFG4 0x400f5004u
N#define CYREG_UDB_PA0_CFG5 0x400f5005u
N#define CYREG_UDB_PA0_CFG6 0x400f5006u
N#define CYREG_UDB_PA0_CFG7 0x400f5007u
N#define CYREG_UDB_PA0_CFG8 0x400f5008u
N#define CYREG_UDB_PA0_CFG9 0x400f5009u
N#define CYREG_UDB_PA0_CFG10 0x400f500au
N#define CYREG_UDB_PA0_CFG11 0x400f500bu
N#define CYREG_UDB_PA0_CFG12 0x400f500cu
N#define CYREG_UDB_PA0_CFG13 0x400f500du
N#define CYREG_UDB_PA0_CFG14 0x400f500eu
N#define CYDEV_UDB_PA1_BASE 0x400f5010u
N#define CYDEV_UDB_PA1_SIZE 0x00000010u
N#define CYREG_UDB_PA1_CFG0 0x400f5010u
N#define CYREG_UDB_PA1_CFG1 0x400f5011u
N#define CYREG_UDB_PA1_CFG2 0x400f5012u
N#define CYREG_UDB_PA1_CFG3 0x400f5013u
N#define CYREG_UDB_PA1_CFG4 0x400f5014u
N#define CYREG_UDB_PA1_CFG5 0x400f5015u
N#define CYREG_UDB_PA1_CFG6 0x400f5016u
N#define CYREG_UDB_PA1_CFG7 0x400f5017u
N#define CYREG_UDB_PA1_CFG8 0x400f5018u
N#define CYREG_UDB_PA1_CFG9 0x400f5019u
N#define CYREG_UDB_PA1_CFG10 0x400f501au
N#define CYREG_UDB_PA1_CFG11 0x400f501bu
N#define CYREG_UDB_PA1_CFG12 0x400f501cu
N#define CYREG_UDB_PA1_CFG13 0x400f501du
N#define CYREG_UDB_PA1_CFG14 0x400f501eu
N#define CYDEV_UDB_PA2_BASE 0x400f5020u
N#define CYDEV_UDB_PA2_SIZE 0x00000010u
N#define CYREG_UDB_PA2_CFG0 0x400f5020u
N#define CYREG_UDB_PA2_CFG1 0x400f5021u
N#define CYREG_UDB_PA2_CFG2 0x400f5022u
N#define CYREG_UDB_PA2_CFG3 0x400f5023u
N#define CYREG_UDB_PA2_CFG4 0x400f5024u
N#define CYREG_UDB_PA2_CFG5 0x400f5025u
N#define CYREG_UDB_PA2_CFG6 0x400f5026u
N#define CYREG_UDB_PA2_CFG7 0x400f5027u
N#define CYREG_UDB_PA2_CFG8 0x400f5028u
N#define CYREG_UDB_PA2_CFG9 0x400f5029u
N#define CYREG_UDB_PA2_CFG10 0x400f502au
N#define CYREG_UDB_PA2_CFG11 0x400f502bu
N#define CYREG_UDB_PA2_CFG12 0x400f502cu
N#define CYREG_UDB_PA2_CFG13 0x400f502du
N#define CYREG_UDB_PA2_CFG14 0x400f502eu
N#define CYDEV_UDB_PA3_BASE 0x400f5030u
N#define CYDEV_UDB_PA3_SIZE 0x00000010u
N#define CYREG_UDB_PA3_CFG0 0x400f5030u
N#define CYREG_UDB_PA3_CFG1 0x400f5031u
N#define CYREG_UDB_PA3_CFG2 0x400f5032u
N#define CYREG_UDB_PA3_CFG3 0x400f5033u
N#define CYREG_UDB_PA3_CFG4 0x400f5034u
N#define CYREG_UDB_PA3_CFG5 0x400f5035u
N#define CYREG_UDB_PA3_CFG6 0x400f5036u
N#define CYREG_UDB_PA3_CFG7 0x400f5037u
N#define CYREG_UDB_PA3_CFG8 0x400f5038u
N#define CYREG_UDB_PA3_CFG9 0x400f5039u
N#define CYREG_UDB_PA3_CFG10 0x400f503au
N#define CYREG_UDB_PA3_CFG11 0x400f503bu
N#define CYREG_UDB_PA3_CFG12 0x400f503cu
N#define CYREG_UDB_PA3_CFG13 0x400f503du
N#define CYREG_UDB_PA3_CFG14 0x400f503eu
N#define CYDEV_UDB_BCTL0_BASE 0x400f6000u
N#define CYDEV_UDB_BCTL0_SIZE 0x00001000u
N#define CYREG_UDB_BCTL0_DRV 0x400f6000u
N#define CYREG_UDB_BCTL0_MDCLK_EN 0x400f6001u
N#define CYREG_UDB_BCTL0_MBCLK_EN 0x400f6002u
N#define CYREG_UDB_BCTL0_BOTSEL_L 0x400f6008u
N#define CYREG_UDB_BCTL0_BOTSEL_U 0x400f6009u
N#define CYREG_UDB_BCTL0_TOPSEL_L 0x400f600au
N#define CYREG_UDB_BCTL0_TOPSEL_U 0x400f600bu
N#define CYREG_UDB_BCTL0_QCLK_EN0 0x400f6010u
N#define CYREG_UDB_BCTL0_QCLK_EN1 0x400f6012u
N#define CYDEV_UDB_UDBIF_BASE 0x400f7000u
N#define CYDEV_UDB_UDBIF_SIZE 0x00001000u
N#define CYREG_UDB_UDBIF_BANK_CTL 0x400f7000u
N#define CYREG_UDB_UDBIF_WAIT_CFG 0x400f7001u
N#define CYREG_UDB_UDBIF_INT_CLK_CTL 0x400f701cu
N#define CYREG_UDB_INT_CFG 0x400f8000u
N#define CYDEV_CTBM_BASE 0x40100000u
N#define CYDEV_CTBM_SIZE 0x00010000u
N#define CYREG_CTBM_CTB_CTRL 0x40100000u
N#define CYREG_CTBM_OA_RES0_CTRL 0x40100004u
N#define CYREG_CTBM_OA_RES1_CTRL 0x40100008u
N#define CYREG_CTBM_COMP_STAT 0x4010000cu
N#define CYREG_CTBM_INTR 0x40100020u
N#define CYREG_CTBM_INTR_SET 0x40100024u
N#define CYREG_CTBM_INTR_MASK 0x40100028u
N#define CYREG_CTBM_INTR_MASKED 0x4010002cu
N#define CYREG_CTBM_DFT_CTRL 0x40100030u
N#define CYREG_CTBM_OA0_SW 0x40100080u
N#define CYREG_CTBM_OA0_SW_CLEAR 0x40100084u
N#define CYREG_CTBM_OA1_SW 0x40100088u
N#define CYREG_CTBM_OA1_SW_CLEAR 0x4010008cu
N#define CYREG_CTBM_CTB_SW_HW_CTRL 0x401000c0u
N#define CYREG_CTBM_CTB_SW_STATUS 0x401000c4u
N#define CYREG_CTBM_OA0_OFFSET_TRIM 0x40100f00u
N#define CYREG_CTBM_OA0_SLOPE_OFFSET_TRIM 0x40100f04u
N#define CYREG_CTBM_OA0_COMP_TRIM 0x40100f08u
N#define CYREG_CTBM_OA1_OFFSET_TRIM 0x40100f0cu
N#define CYREG_CTBM_OA1_SLOPE_OFFSET_TRIM 0x40100f10u
N#define CYREG_CTBM_OA1_COMP_TRIM 0x40100f14u
N#define CYDEV_SAR_BASE 0x401a0000u
N#define CYDEV_SAR_SIZE 0x00010000u
N#define CYREG_SAR_CTRL 0x401a0000u
N#define CYREG_SAR_SAMPLE_CTRL 0x401a0004u
N#define CYREG_SAR_SAMPLE_TIME01 0x401a0010u
N#define CYREG_SAR_SAMPLE_TIME23 0x401a0014u
N#define CYREG_SAR_RANGE_THRES 0x401a0018u
N#define CYREG_SAR_RANGE_COND 0x401a001cu
N#define CYREG_SAR_CHAN_EN 0x401a0020u
N#define CYREG_SAR_START_CTRL 0x401a0024u
N#define CYREG_SAR_DFT_CTRL 0x401a0030u
N#define CYREG_SAR_CHAN_CONFIG00 0x401a0080u
N#define CYREG_SAR_CHAN_CONFIG01 0x401a0084u
N#define CYREG_SAR_CHAN_CONFIG02 0x401a0088u
N#define CYREG_SAR_CHAN_CONFIG03 0x401a008cu
N#define CYREG_SAR_CHAN_CONFIG04 0x401a0090u
N#define CYREG_SAR_CHAN_CONFIG05 0x401a0094u
N#define CYREG_SAR_CHAN_CONFIG06 0x401a0098u
N#define CYREG_SAR_CHAN_CONFIG07 0x401a009cu
N#define CYREG_SAR_CHAN_WORK00 0x401a0100u
N#define CYREG_SAR_CHAN_WORK01 0x401a0104u
N#define CYREG_SAR_CHAN_WORK02 0x401a0108u
N#define CYREG_SAR_CHAN_WORK03 0x401a010cu
N#define CYREG_SAR_CHAN_WORK04 0x401a0110u
N#define CYREG_SAR_CHAN_WORK05 0x401a0114u
N#define CYREG_SAR_CHAN_WORK06 0x401a0118u
N#define CYREG_SAR_CHAN_WORK07 0x401a011cu
N#define CYREG_SAR_CHAN_RESULT00 0x401a0180u
N#define CYREG_SAR_CHAN_RESULT01 0x401a0184u
N#define CYREG_SAR_CHAN_RESULT02 0x401a0188u
N#define CYREG_SAR_CHAN_RESULT03 0x401a018cu
N#define CYREG_SAR_CHAN_RESULT04 0x401a0190u
N#define CYREG_SAR_CHAN_RESULT05 0x401a0194u
N#define CYREG_SAR_CHAN_RESULT06 0x401a0198u
N#define CYREG_SAR_CHAN_RESULT07 0x401a019cu
N#define CYREG_SAR_CHAN_WORK_VALID 0x401a0200u
N#define CYREG_SAR_CHAN_RESULT_VALID 0x401a0204u
N#define CYREG_SAR_STATUS 0x401a0208u
N#define CYREG_SAR_AVG_STAT 0x401a020cu
N#define CYREG_SAR_INTR 0x401a0210u
N#define CYREG_SAR_INTR_SET 0x401a0214u
N#define CYREG_SAR_INTR_MASK 0x401a0218u
N#define CYREG_SAR_INTR_MASKED 0x401a021cu
N#define CYREG_SAR_SATURATE_INTR 0x401a0220u
N#define CYREG_SAR_SATURATE_INTR_SET 0x401a0224u
N#define CYREG_SAR_SATURATE_INTR_MASK 0x401a0228u
N#define CYREG_SAR_SATURATE_INTR_MASKED 0x401a022cu
N#define CYREG_SAR_RANGE_INTR 0x401a0230u
N#define CYREG_SAR_RANGE_INTR_SET 0x401a0234u
N#define CYREG_SAR_RANGE_INTR_MASK 0x401a0238u
N#define CYREG_SAR_RANGE_INTR_MASKED 0x401a023cu
N#define CYREG_SAR_INTR_CAUSE 0x401a0240u
N#define CYREG_SAR_INJ_CHAN_CONFIG 0x401a0280u
N#define CYREG_SAR_INJ_RESULT 0x401a0290u
N#define CYREG_SAR_MUX_SWITCH0 0x401a0300u
N#define CYREG_SAR_MUX_SWITCH_CLEAR0 0x401a0304u
N#define CYREG_SAR_MUX_SWITCH1 0x401a0308u
N#define CYREG_SAR_MUX_SWITCH_CLEAR1 0x401a030cu
N#define CYREG_SAR_MUX_SWITCH_HW_CTRL 0x401a0340u
N#define CYREG_SAR_MUX_SWITCH_STATUS 0x401a0348u
N#define CYREG_SAR_PUMP_CTRL 0x401a0380u
N#define CYREG_SAR_ANA_TRIM 0x401a0f00u
N#define CYREG_SAR_WOUNDING 0x401a0f04u
N#define CYDEV_CM0_BASE 0xe0000000u
N#define CYDEV_CM0_SIZE 0x00100000u
N#define CYREG_CM0_DWT_PID4 0xe0001fd0u
N#define CYREG_CM0_DWT_PID0 0xe0001fe0u
N#define CYREG_CM0_DWT_PID1 0xe0001fe4u
N#define CYREG_CM0_DWT_PID2 0xe0001fe8u
N#define CYREG_CM0_DWT_PID3 0xe0001fecu
N#define CYREG_CM0_DWT_CID0 0xe0001ff0u
N#define CYREG_CM0_DWT_CID1 0xe0001ff4u
N#define CYREG_CM0_DWT_CID2 0xe0001ff8u
N#define CYREG_CM0_DWT_CID3 0xe0001ffcu
N#define CYREG_CM0_BP_PID4 0xe0002fd0u
N#define CYREG_CM0_BP_PID0 0xe0002fe0u
N#define CYREG_CM0_BP_PID1 0xe0002fe4u
N#define CYREG_CM0_BP_PID2 0xe0002fe8u
N#define CYREG_CM0_BP_PID3 0xe0002fecu
N#define CYREG_CM0_BP_CID0 0xe0002ff0u
N#define CYREG_CM0_BP_CID1 0xe0002ff4u
N#define CYREG_CM0_BP_CID2 0xe0002ff8u
N#define CYREG_CM0_BP_CID3 0xe0002ffcu
N#define CYREG_CM0_SYST_CSR 0xe000e010u
N#define CYREG_CM0_SYST_RVR 0xe000e014u
N#define CYREG_CM0_SYST_CVR 0xe000e018u
N#define CYREG_CM0_SYST_CALIB 0xe000e01cu
N#define CYREG_CM0_ISER 0xe000e100u
N#define CYREG_CM0_ICER 0xe000e180u
N#define CYREG_CM0_ISPR 0xe000e200u
N#define CYREG_CM0_ICPR 0xe000e280u
N#define CYREG_CM0_IPR0 0xe000e400u
N#define CYREG_CM0_IPR1 0xe000e404u
N#define CYREG_CM0_IPR2 0xe000e408u
N#define CYREG_CM0_IPR3 0xe000e40cu
N#define CYREG_CM0_IPR4 0xe000e410u
N#define CYREG_CM0_IPR5 0xe000e414u
N#define CYREG_CM0_IPR6 0xe000e418u
N#define CYREG_CM0_IPR7 0xe000e41cu
N#define CYREG_CM0_CPUID 0xe000ed00u
N#define CYREG_CM0_ICSR 0xe000ed04u
N#define CYREG_CM0_AIRCR 0xe000ed0cu
N#define CYREG_CM0_SCR 0xe000ed10u
N#define CYREG_CM0_CCR 0xe000ed14u
N#define CYREG_CM0_SHPR2 0xe000ed1cu
N#define CYREG_CM0_SHPR3 0xe000ed20u
N#define CYREG_CM0_SHCSR 0xe000ed24u
N#define CYREG_CM0_SCS_PID4 0xe000efd0u
N#define CYREG_CM0_SCS_PID0 0xe000efe0u
N#define CYREG_CM0_SCS_PID1 0xe000efe4u
N#define CYREG_CM0_SCS_PID2 0xe000efe8u
N#define CYREG_CM0_SCS_PID3 0xe000efecu
N#define CYREG_CM0_SCS_CID0 0xe000eff0u
N#define CYREG_CM0_SCS_CID1 0xe000eff4u
N#define CYREG_CM0_SCS_CID2 0xe000eff8u
N#define CYREG_CM0_SCS_CID3 0xe000effcu
N#define CYREG_CM0_ROM_SCS 0xe00ff000u
N#define CYREG_CM0_ROM_DWT 0xe00ff004u
N#define CYREG_CM0_ROM_BPU 0xe00ff008u
N#define CYREG_CM0_ROM_END 0xe00ff00cu
N#define CYREG_CM0_ROM_CSMT 0xe00fffccu
N#define CYREG_CM0_ROM_PID4 0xe00fffd0u
N#define CYREG_CM0_ROM_PID0 0xe00fffe0u
N#define CYREG_CM0_ROM_PID1 0xe00fffe4u
N#define CYREG_CM0_ROM_PID2 0xe00fffe8u
N#define CYREG_CM0_ROM_PID3 0xe00fffecu
N#define CYREG_CM0_ROM_CID0 0xe00ffff0u
N#define CYREG_CM0_ROM_CID1 0xe00ffff4u
N#define CYREG_CM0_ROM_CID2 0xe00ffff8u
N#define CYREG_CM0_ROM_CID3 0xe00ffffcu
N#define CYDEV_CoreSightTable_BASE 0xf0000000u
N#define CYDEV_CoreSightTable_SIZE 0x00001000u
N#define CYREG_CoreSightTable_DATA_MBASE 0xf0000000u
N#define CYREG_CoreSightTable_DATA_MSIZE 0x00001000u
N#define CYDEV_FLS_SECTOR_SIZE 0x00008000u
N#define CYDEV_FLS_ROW_SIZE 0x00000080u
N#endif /* CYDEVICE_TRM_H */
L 21 ".\Generated_Source\PSoC4\UART_1.h" 2
N#include "cyfitter.h"
L 1 ".\Generated_Source\PSoC4\cyfitter.h" 1
N#ifndef INCLUDED_CYFITTER_H
N#define INCLUDED_CYFITTER_H
N#include <cydevice_trm.h>
N
N/* UART_1_SCBCLK */
N#define UART_1_SCBCLK__DIVIDER_MASK 0x0000FFFFu
N#define UART_1_SCBCLK__ENABLE CYREG_CLK_DIVIDER_B00
N#define UART_1_SCBCLK__ENABLE_MASK 0x80000000u
N#define UART_1_SCBCLK__MASK 0x80000000u
N#define UART_1_SCBCLK__REGISTER CYREG_CLK_DIVIDER_B00
N
N/* SPI_miso_m */
N#define SPI_miso_m__0__DM__MASK 0x38u
N#define SPI_miso_m__0__DM__SHIFT 3
N#define SPI_miso_m__0__DR CYREG_PRT3_DR
N#define SPI_miso_m__0__HSIOM CYREG_HSIOM_PORT_SEL3
N#define SPI_miso_m__0__HSIOM_MASK 0x000000F0u
N#define SPI_miso_m__0__HSIOM_SHIFT 4u
N#define SPI_miso_m__0__INTCFG CYREG_PRT3_INTCFG
N#define SPI_miso_m__0__INTSTAT CYREG_PRT3_INTSTAT
N#define SPI_miso_m__0__MASK 0x02u
N#define SPI_miso_m__0__PA__CFG0 CYREG_UDB_PA3_CFG0
N#define SPI_miso_m__0__PA__CFG1 CYREG_UDB_PA3_CFG1
N#define SPI_miso_m__0__PA__CFG10 CYREG_UDB_PA3_CFG10
N#define SPI_miso_m__0__PA__CFG11 CYREG_UDB_PA3_CFG11
N#define SPI_miso_m__0__PA__CFG12 CYREG_UDB_PA3_CFG12
N#define SPI_miso_m__0__PA__CFG13 CYREG_UDB_PA3_CFG13
N#define SPI_miso_m__0__PA__CFG14 CYREG_UDB_PA3_CFG14
N#define SPI_miso_m__0__PA__CFG2 CYREG_UDB_PA3_CFG2
N#define SPI_miso_m__0__PA__CFG3 CYREG_UDB_PA3_CFG3
N#define SPI_miso_m__0__PA__CFG4 CYREG_UDB_PA3_CFG4
N#define SPI_miso_m__0__PA__CFG5 CYREG_UDB_PA3_CFG5
N#define SPI_miso_m__0__PA__CFG6 CYREG_UDB_PA3_CFG6
N#define SPI_miso_m__0__PA__CFG7 CYREG_UDB_PA3_CFG7
N#define SPI_miso_m__0__PA__CFG8 CYREG_UDB_PA3_CFG8
N#define SPI_miso_m__0__PA__CFG9 CYREG_UDB_PA3_CFG9
N#define SPI_miso_m__0__PC CYREG_PRT3_PC
N#define SPI_miso_m__0__PC2 CYREG_PRT3_PC2
N#define SPI_miso_m__0__PORT 3u
N#define SPI_miso_m__0__PS CYREG_PRT3_PS
N#define SPI_miso_m__0__SHIFT 1
N#define SPI_miso_m__DR CYREG_PRT3_DR
N#define SPI_miso_m__INTCFG CYREG_PRT3_INTCFG
N#define SPI_miso_m__INTSTAT CYREG_PRT3_INTSTAT
N#define SPI_miso_m__MASK 0x02u
N#define SPI_miso_m__PA__CFG0 CYREG_UDB_PA3_CFG0
N#define SPI_miso_m__PA__CFG1 CYREG_UDB_PA3_CFG1
N#define SPI_miso_m__PA__CFG10 CYREG_UDB_PA3_CFG10
N#define SPI_miso_m__PA__CFG11 CYREG_UDB_PA3_CFG11
N#define SPI_miso_m__PA__CFG12 CYREG_UDB_PA3_CFG12
N#define SPI_miso_m__PA__CFG13 CYREG_UDB_PA3_CFG13
N#define SPI_miso_m__PA__CFG14 CYREG_UDB_PA3_CFG14
N#define SPI_miso_m__PA__CFG2 CYREG_UDB_PA3_CFG2
N#define SPI_miso_m__PA__CFG3 CYREG_UDB_PA3_CFG3
N#define SPI_miso_m__PA__CFG4 CYREG_UDB_PA3_CFG4
N#define SPI_miso_m__PA__CFG5 CYREG_UDB_PA3_CFG5
N#define SPI_miso_m__PA__CFG6 CYREG_UDB_PA3_CFG6
N#define SPI_miso_m__PA__CFG7 CYREG_UDB_PA3_CFG7
N#define SPI_miso_m__PA__CFG8 CYREG_UDB_PA3_CFG8
N#define SPI_miso_m__PA__CFG9 CYREG_UDB_PA3_CFG9
N#define SPI_miso_m__PC CYREG_PRT3_PC
N#define SPI_miso_m__PC2 CYREG_PRT3_PC2
N#define SPI_miso_m__PORT 3u
N#define SPI_miso_m__PS CYREG_PRT3_PS
N#define SPI_miso_m__SHIFT 1
N
N/* SPI_mosi_m */
N#define SPI_mosi_m__0__DM__MASK 0x07u
N#define SPI_mosi_m__0__DM__SHIFT 0
N#define SPI_mosi_m__0__DR CYREG_PRT3_DR
N#define SPI_mosi_m__0__HSIOM CYREG_HSIOM_PORT_SEL3
N#define SPI_mosi_m__0__HSIOM_MASK 0x0000000Fu
N#define SPI_mosi_m__0__HSIOM_SHIFT 0u
N#define SPI_mosi_m__0__INTCFG CYREG_PRT3_INTCFG
N#define SPI_mosi_m__0__INTSTAT CYREG_PRT3_INTSTAT
N#define SPI_mosi_m__0__MASK 0x01u
N#define SPI_mosi_m__0__OUT_SEL CYREG_UDB_PA3_CFG10
N#define SPI_mosi_m__0__OUT_SEL_SHIFT 0u
N#define SPI_mosi_m__0__OUT_SEL_VAL -1u
N#define SPI_mosi_m__0__PA__CFG0 CYREG_UDB_PA3_CFG0
N#define SPI_mosi_m__0__PA__CFG1 CYREG_UDB_PA3_CFG1
N#define SPI_mosi_m__0__PA__CFG10 CYREG_UDB_PA3_CFG10
N#define SPI_mosi_m__0__PA__CFG11 CYREG_UDB_PA3_CFG11
N#define SPI_mosi_m__0__PA__CFG12 CYREG_UDB_PA3_CFG12
N#define SPI_mosi_m__0__PA__CFG13 CYREG_UDB_PA3_CFG13
N#define SPI_mosi_m__0__PA__CFG14 CYREG_UDB_PA3_CFG14
N#define SPI_mosi_m__0__PA__CFG2 CYREG_UDB_PA3_CFG2
N#define SPI_mosi_m__0__PA__CFG3 CYREG_UDB_PA3_CFG3
N#define SPI_mosi_m__0__PA__CFG4 CYREG_UDB_PA3_CFG4
N#define SPI_mosi_m__0__PA__CFG5 CYREG_UDB_PA3_CFG5
N#define SPI_mosi_m__0__PA__CFG6 CYREG_UDB_PA3_CFG6
N#define SPI_mosi_m__0__PA__CFG7 CYREG_UDB_PA3_CFG7
N#define SPI_mosi_m__0__PA__CFG8 CYREG_UDB_PA3_CFG8
N#define SPI_mosi_m__0__PA__CFG9 CYREG_UDB_PA3_CFG9
N#define SPI_mosi_m__0__PC CYREG_PRT3_PC
N#define SPI_mosi_m__0__PC2 CYREG_PRT3_PC2
N#define SPI_mosi_m__0__PORT 3u
N#define SPI_mosi_m__0__PS CYREG_PRT3_PS
N#define SPI_mosi_m__0__SHIFT 0
N#define SPI_mosi_m__DR CYREG_PRT3_DR
N#define SPI_mosi_m__INTCFG CYREG_PRT3_INTCFG
N#define SPI_mosi_m__INTSTAT CYREG_PRT3_INTSTAT
N#define SPI_mosi_m__MASK 0x01u
N#define SPI_mosi_m__PA__CFG0 CYREG_UDB_PA3_CFG0
N#define SPI_mosi_m__PA__CFG1 CYREG_UDB_PA3_CFG1
N#define SPI_mosi_m__PA__CFG10 CYREG_UDB_PA3_CFG10
N#define SPI_mosi_m__PA__CFG11 CYREG_UDB_PA3_CFG11
N#define SPI_mosi_m__PA__CFG12 CYREG_UDB_PA3_CFG12
N#define SPI_mosi_m__PA__CFG13 CYREG_UDB_PA3_CFG13
N#define SPI_mosi_m__PA__CFG14 CYREG_UDB_PA3_CFG14
N#define SPI_mosi_m__PA__CFG2 CYREG_UDB_PA3_CFG2
N#define SPI_mosi_m__PA__CFG3 CYREG_UDB_PA3_CFG3
N#define SPI_mosi_m__PA__CFG4 CYREG_UDB_PA3_CFG4
N#define SPI_mosi_m__PA__CFG5 CYREG_UDB_PA3_CFG5
N#define SPI_mosi_m__PA__CFG6 CYREG_UDB_PA3_CFG6
N#define SPI_mosi_m__PA__CFG7 CYREG_UDB_PA3_CFG7
N#define SPI_mosi_m__PA__CFG8 CYREG_UDB_PA3_CFG8
N#define SPI_mosi_m__PA__CFG9 CYREG_UDB_PA3_CFG9
N#define SPI_mosi_m__PC CYREG_PRT3_PC
N#define SPI_mosi_m__PC2 CYREG_PRT3_PC2
N#define SPI_mosi_m__PORT 3u
N#define SPI_mosi_m__PS CYREG_PRT3_PS
N#define SPI_mosi_m__SHIFT 0
N
N/* SPI_SCBCLK */
N#define SPI_SCBCLK__DIVIDER_MASK 0x0000FFFFu
N#define SPI_SCBCLK__ENABLE CYREG_CLK_DIVIDER_A00
N#define SPI_SCBCLK__ENABLE_MASK 0x80000000u
N#define SPI_SCBCLK__MASK 0x80000000u
N#define SPI_SCBCLK__REGISTER CYREG_CLK_DIVIDER_A00
N
N/* SPI_sclk_m */
N#define SPI_sclk_m__0__DM__MASK 0x1C0000u
N#define SPI_sclk_m__0__DM__SHIFT 18
N#define SPI_sclk_m__0__DR CYREG_PRT0_DR
N#define SPI_sclk_m__0__HSIOM CYREG_HSIOM_PORT_SEL0
N#define SPI_sclk_m__0__HSIOM_MASK 0x0F000000u
N#define SPI_sclk_m__0__HSIOM_SHIFT 24u
N#define SPI_sclk_m__0__INTCFG CYREG_PRT0_INTCFG
N#define SPI_sclk_m__0__INTSTAT CYREG_PRT0_INTSTAT
N#define SPI_sclk_m__0__MASK 0x40u
N#define SPI_sclk_m__0__OUT_SEL CYREG_UDB_PA0_CFG10
N#define SPI_sclk_m__0__OUT_SEL_SHIFT 12u
N#define SPI_sclk_m__0__OUT_SEL_VAL -1u
N#define SPI_sclk_m__0__PA__CFG0 CYREG_UDB_PA0_CFG0
N#define SPI_sclk_m__0__PA__CFG1 CYREG_UDB_PA0_CFG1
N#define SPI_sclk_m__0__PA__CFG10 CYREG_UDB_PA0_CFG10
N#define SPI_sclk_m__0__PA__CFG11 CYREG_UDB_PA0_CFG11
N#define SPI_sclk_m__0__PA__CFG12 CYREG_UDB_PA0_CFG12
N#define SPI_sclk_m__0__PA__CFG13 CYREG_UDB_PA0_CFG13
N#define SPI_sclk_m__0__PA__CFG14 CYREG_UDB_PA0_CFG14
N#define SPI_sclk_m__0__PA__CFG2 CYREG_UDB_PA0_CFG2
N#define SPI_sclk_m__0__PA__CFG3 CYREG_UDB_PA0_CFG3
N#define SPI_sclk_m__0__PA__CFG4 CYREG_UDB_PA0_CFG4
N#define SPI_sclk_m__0__PA__CFG5 CYREG_UDB_PA0_CFG5
N#define SPI_sclk_m__0__PA__CFG6 CYREG_UDB_PA0_CFG6
N#define SPI_sclk_m__0__PA__CFG7 CYREG_UDB_PA0_CFG7
N#define SPI_sclk_m__0__PA__CFG8 CYREG_UDB_PA0_CFG8
N#define SPI_sclk_m__0__PA__CFG9 CYREG_UDB_PA0_CFG9
N#define SPI_sclk_m__0__PC CYREG_PRT0_PC
N#define SPI_sclk_m__0__PC2 CYREG_PRT0_PC2
N#define SPI_sclk_m__0__PORT 0u
N#define SPI_sclk_m__0__PS CYREG_PRT0_PS
N#define SPI_sclk_m__0__SHIFT 6
N#define SPI_sclk_m__DR CYREG_PRT0_DR
N#define SPI_sclk_m__INTCFG CYREG_PRT0_INTCFG
N#define SPI_sclk_m__INTSTAT CYREG_PRT0_INTSTAT
N#define SPI_sclk_m__MASK 0x40u
N#define SPI_sclk_m__PA__CFG0 CYREG_UDB_PA0_CFG0
N#define SPI_sclk_m__PA__CFG1 CYREG_UDB_PA0_CFG1
N#define SPI_sclk_m__PA__CFG10 CYREG_UDB_PA0_CFG10
N#define SPI_sclk_m__PA__CFG11 CYREG_UDB_PA0_CFG11
N#define SPI_sclk_m__PA__CFG12 CYREG_UDB_PA0_CFG12
N#define SPI_sclk_m__PA__CFG13 CYREG_UDB_PA0_CFG13
N#define SPI_sclk_m__PA__CFG14 CYREG_UDB_PA0_CFG14
N#define SPI_sclk_m__PA__CFG2 CYREG_UDB_PA0_CFG2
N#define SPI_sclk_m__PA__CFG3 CYREG_UDB_PA0_CFG3
N#define SPI_sclk_m__PA__CFG4 CYREG_UDB_PA0_CFG4
N#define SPI_sclk_m__PA__CFG5 CYREG_UDB_PA0_CFG5
N#define SPI_sclk_m__PA__CFG6 CYREG_UDB_PA0_CFG6
N#define SPI_sclk_m__PA__CFG7 CYREG_UDB_PA0_CFG7
N#define SPI_sclk_m__PA__CFG8 CYREG_UDB_PA0_CFG8
N#define SPI_sclk_m__PA__CFG9 CYREG_UDB_PA0_CFG9
N#define SPI_sclk_m__PC CYREG_PRT0_PC
N#define SPI_sclk_m__PC2 CYREG_PRT0_PC2
N#define SPI_sclk_m__PORT 0u
N#define SPI_sclk_m__PS CYREG_PRT0_PS
N#define SPI_sclk_m__SHIFT 6
N
N/* UART_1_SCB */
N#define UART_1_SCB__BIST_CONTROL CYREG_SCB0_BIST_CONTROL
N#define UART_1_SCB__BIST_DATA CYREG_SCB0_BIST_DATA
N#define UART_1_SCB__CTRL CYREG_SCB0_CTRL
N#define UART_1_SCB__EZ_DATA00 CYREG_SCB0_EZ_DATA00
N#define UART_1_SCB__EZ_DATA01 CYREG_SCB0_EZ_DATA01
N#define UART_1_SCB__EZ_DATA02 CYREG_SCB0_EZ_DATA02
N#define UART_1_SCB__EZ_DATA03 CYREG_SCB0_EZ_DATA03
N#define UART_1_SCB__EZ_DATA04 CYREG_SCB0_EZ_DATA04
N#define UART_1_SCB__EZ_DATA05 CYREG_SCB0_EZ_DATA05
N#define UART_1_SCB__EZ_DATA06 CYREG_SCB0_EZ_DATA06
N#define UART_1_SCB__EZ_DATA07 CYREG_SCB0_EZ_DATA07
N#define UART_1_SCB__EZ_DATA08 CYREG_SCB0_EZ_DATA08
N#define UART_1_SCB__EZ_DATA09 CYREG_SCB0_EZ_DATA09
N#define UART_1_SCB__EZ_DATA10 CYREG_SCB0_EZ_DATA10
N#define UART_1_SCB__EZ_DATA11 CYREG_SCB0_EZ_DATA11
N#define UART_1_SCB__EZ_DATA12 CYREG_SCB0_EZ_DATA12
N#define UART_1_SCB__EZ_DATA13 CYREG_SCB0_EZ_DATA13
N#define UART_1_SCB__EZ_DATA14 CYREG_SCB0_EZ_DATA14
N#define UART_1_SCB__EZ_DATA15 CYREG_SCB0_EZ_DATA15
N#define UART_1_SCB__EZ_DATA16 CYREG_SCB0_EZ_DATA16
N#define UART_1_SCB__EZ_DATA17 CYREG_SCB0_EZ_DATA17
N#define UART_1_SCB__EZ_DATA18 CYREG_SCB0_EZ_DATA18
N#define UART_1_SCB__EZ_DATA19 CYREG_SCB0_EZ_DATA19
N#define UART_1_SCB__EZ_DATA20 CYREG_SCB0_EZ_DATA20
N#define UART_1_SCB__EZ_DATA21 CYREG_SCB0_EZ_DATA21
N#define UART_1_SCB__EZ_DATA22 CYREG_SCB0_EZ_DATA22
N#define UART_1_SCB__EZ_DATA23 CYREG_SCB0_EZ_DATA23
N#define UART_1_SCB__EZ_DATA24 CYREG_SCB0_EZ_DATA24
N#define UART_1_SCB__EZ_DATA25 CYREG_SCB0_EZ_DATA25
N#define UART_1_SCB__EZ_DATA26 CYREG_SCB0_EZ_DATA26
N#define UART_1_SCB__EZ_DATA27 CYREG_SCB0_EZ_DATA27
N#define UART_1_SCB__EZ_DATA28 CYREG_SCB0_EZ_DATA28
N#define UART_1_SCB__EZ_DATA29 CYREG_SCB0_EZ_DATA29
N#define UART_1_SCB__EZ_DATA30 CYREG_SCB0_EZ_DATA30
N#define UART_1_SCB__EZ_DATA31 CYREG_SCB0_EZ_DATA31
N#define UART_1_SCB__I2C_CFG CYREG_SCB0_I2C_CFG
N#define UART_1_SCB__I2C_CTRL CYREG_SCB0_I2C_CTRL
N#define UART_1_SCB__I2C_M_CMD CYREG_SCB0_I2C_M_CMD
N#define UART_1_SCB__I2C_STATUS CYREG_SCB0_I2C_STATUS
N#define UART_1_SCB__I2C_S_CMD CYREG_SCB0_I2C_S_CMD
N#define UART_1_SCB__INTR_CAUSE CYREG_SCB0_INTR_CAUSE
N#define UART_1_SCB__INTR_I2C_EC CYREG_SCB0_INTR_I2C_EC
N#define UART_1_SCB__INTR_I2C_EC_MASK CYREG_SCB0_INTR_I2C_EC_MASK
N#define UART_1_SCB__INTR_I2C_EC_MASKED CYREG_SCB0_INTR_I2C_EC_MASKED
N#define UART_1_SCB__INTR_M CYREG_SCB0_INTR_M
N#define UART_1_SCB__INTR_M_MASK CYREG_SCB0_INTR_M_MASK
N#define UART_1_SCB__INTR_M_MASKED CYREG_SCB0_INTR_M_MASKED
N#define UART_1_SCB__INTR_M_SET CYREG_SCB0_INTR_M_SET
N#define UART_1_SCB__INTR_RX CYREG_SCB0_INTR_RX
N#define UART_1_SCB__INTR_RX_MASK CYREG_SCB0_INTR_RX_MASK
N#define UART_1_SCB__INTR_RX_MASKED CYREG_SCB0_INTR_RX_MASKED
N#define UART_1_SCB__INTR_RX_SET CYREG_SCB0_INTR_RX_SET
N#define UART_1_SCB__INTR_S CYREG_SCB0_INTR_S
N#define UART_1_SCB__INTR_SPI_EC CYREG_SCB0_INTR_SPI_EC
N#define UART_1_SCB__INTR_SPI_EC_MASK CYREG_SCB0_INTR_SPI_EC_MASK
N#define UART_1_SCB__INTR_SPI_EC_MASKED CYREG_SCB0_INTR_SPI_EC_MASKED
N#define UART_1_SCB__INTR_S_MASK CYREG_SCB0_INTR_S_MASK
N#define UART_1_SCB__INTR_S_MASKED CYREG_SCB0_INTR_S_MASKED
N#define UART_1_SCB__INTR_S_SET CYREG_SCB0_INTR_S_SET
N#define UART_1_SCB__INTR_TX CYREG_SCB0_INTR_TX
N#define UART_1_SCB__INTR_TX_MASK CYREG_SCB0_INTR_TX_MASK
N#define UART_1_SCB__INTR_TX_MASKED CYREG_SCB0_INTR_TX_MASKED
N#define UART_1_SCB__INTR_TX_SET CYREG_SCB0_INTR_TX_SET
N#define UART_1_SCB__RX_CTRL CYREG_SCB0_RX_CTRL
N#define UART_1_SCB__RX_FIFO_CTRL CYREG_SCB0_RX_FIFO_CTRL
N#define UART_1_SCB__RX_FIFO_RD CYREG_SCB0_RX_FIFO_RD
N#define UART_1_SCB__RX_FIFO_RD_SILENT CYREG_SCB0_RX_FIFO_RD_SILENT
N#define UART_1_SCB__RX_FIFO_STATUS CYREG_SCB0_RX_FIFO_STATUS
N#define UART_1_SCB__RX_MATCH CYREG_SCB0_RX_MATCH
N#define UART_1_SCB__SPI_CTRL CYREG_SCB0_SPI_CTRL
N#define UART_1_SCB__SPI_STATUS CYREG_SCB0_SPI_STATUS
N#define UART_1_SCB__STATUS CYREG_SCB0_STATUS
N#define UART_1_SCB__TX_CTRL CYREG_SCB0_TX_CTRL
N#define UART_1_SCB__TX_FIFO_CTRL CYREG_SCB0_TX_FIFO_CTRL
N#define UART_1_SCB__TX_FIFO_STATUS CYREG_SCB0_TX_FIFO_STATUS
N#define UART_1_SCB__TX_FIFO_WR CYREG_SCB0_TX_FIFO_WR
N#define UART_1_SCB__UART_CTRL CYREG_SCB0_UART_CTRL
N#define UART_1_SCB__UART_RX_CTRL CYREG_SCB0_UART_RX_CTRL
N#define UART_1_SCB__UART_RX_STATUS CYREG_SCB0_UART_RX_STATUS
N#define UART_1_SCB__UART_TX_CTRL CYREG_SCB0_UART_TX_CTRL
N
N/* SPI_ss0_m */
N#define SPI_ss0_m__0__DM__MASK 0xE00000u
N#define SPI_ss0_m__0__DM__SHIFT 21
N#define SPI_ss0_m__0__DR CYREG_PRT0_DR
N#define SPI_ss0_m__0__HSIOM CYREG_HSIOM_PORT_SEL0
N#define SPI_ss0_m__0__HSIOM_MASK 0xF0000000u
N#define SPI_ss0_m__0__HSIOM_SHIFT 28u
N#define SPI_ss0_m__0__INTCFG CYREG_PRT0_INTCFG
N#define SPI_ss0_m__0__INTSTAT CYREG_PRT0_INTSTAT
N#define SPI_ss0_m__0__MASK 0x80u
N#define SPI_ss0_m__0__OUT_SEL CYREG_UDB_PA0_CFG10
N#define SPI_ss0_m__0__OUT_SEL_SHIFT 14u
N#define SPI_ss0_m__0__OUT_SEL_VAL -1u
N#define SPI_ss0_m__0__PA__CFG0 CYREG_UDB_PA0_CFG0
N#define SPI_ss0_m__0__PA__CFG1 CYREG_UDB_PA0_CFG1
N#define SPI_ss0_m__0__PA__CFG10 CYREG_UDB_PA0_CFG10
N#define SPI_ss0_m__0__PA__CFG11 CYREG_UDB_PA0_CFG11
N#define SPI_ss0_m__0__PA__CFG12 CYREG_UDB_PA0_CFG12
N#define SPI_ss0_m__0__PA__CFG13 CYREG_UDB_PA0_CFG13
N#define SPI_ss0_m__0__PA__CFG14 CYREG_UDB_PA0_CFG14
N#define SPI_ss0_m__0__PA__CFG2 CYREG_UDB_PA0_CFG2
N#define SPI_ss0_m__0__PA__CFG3 CYREG_UDB_PA0_CFG3
N#define SPI_ss0_m__0__PA__CFG4 CYREG_UDB_PA0_CFG4
N#define SPI_ss0_m__0__PA__CFG5 CYREG_UDB_PA0_CFG5
N#define SPI_ss0_m__0__PA__CFG6 CYREG_UDB_PA0_CFG6
N#define SPI_ss0_m__0__PA__CFG7 CYREG_UDB_PA0_CFG7
N#define SPI_ss0_m__0__PA__CFG8 CYREG_UDB_PA0_CFG8
N#define SPI_ss0_m__0__PA__CFG9 CYREG_UDB_PA0_CFG9
N#define SPI_ss0_m__0__PC CYREG_PRT0_PC
N#define SPI_ss0_m__0__PC2 CYREG_PRT0_PC2
N#define SPI_ss0_m__0__PORT 0u
N#define SPI_ss0_m__0__PS CYREG_PRT0_PS
N#define SPI_ss0_m__0__SHIFT 7
N#define SPI_ss0_m__DR CYREG_PRT0_DR
N#define SPI_ss0_m__INTCFG CYREG_PRT0_INTCFG
N#define SPI_ss0_m__INTSTAT CYREG_PRT0_INTSTAT
N#define SPI_ss0_m__MASK 0x80u
N#define SPI_ss0_m__PA__CFG0 CYREG_UDB_PA0_CFG0
N#define SPI_ss0_m__PA__CFG1 CYREG_UDB_PA0_CFG1
N#define SPI_ss0_m__PA__CFG10 CYREG_UDB_PA0_CFG10
N#define SPI_ss0_m__PA__CFG11 CYREG_UDB_PA0_CFG11
N#define SPI_ss0_m__PA__CFG12 CYREG_UDB_PA0_CFG12
N#define SPI_ss0_m__PA__CFG13 CYREG_UDB_PA0_CFG13
N#define SPI_ss0_m__PA__CFG14 CYREG_UDB_PA0_CFG14
N#define SPI_ss0_m__PA__CFG2 CYREG_UDB_PA0_CFG2
N#define SPI_ss0_m__PA__CFG3 CYREG_UDB_PA0_CFG3
N#define SPI_ss0_m__PA__CFG4 CYREG_UDB_PA0_CFG4
N#define SPI_ss0_m__PA__CFG5 CYREG_UDB_PA0_CFG5
N#define SPI_ss0_m__PA__CFG6 CYREG_UDB_PA0_CFG6
N#define SPI_ss0_m__PA__CFG7 CYREG_UDB_PA0_CFG7
N#define SPI_ss0_m__PA__CFG8 CYREG_UDB_PA0_CFG8
N#define SPI_ss0_m__PA__CFG9 CYREG_UDB_PA0_CFG9
N#define SPI_ss0_m__PC CYREG_PRT0_PC
N#define SPI_ss0_m__PC2 CYREG_PRT0_PC2
N#define SPI_ss0_m__PORT 0u
N#define SPI_ss0_m__PS CYREG_PRT0_PS
N#define SPI_ss0_m__SHIFT 7
N
N/* UART_1_rx */
N#define UART_1_rx__0__DM__MASK 0x07u
N#define UART_1_rx__0__DM__SHIFT 0
N#define UART_1_rx__0__DR CYREG_PRT4_DR
N#define UART_1_rx__0__HSIOM CYREG_HSIOM_PORT_SEL4
N#define UART_1_rx__0__HSIOM_MASK 0x0000000Fu
N#define UART_1_rx__0__HSIOM_SHIFT 0u
N#define UART_1_rx__0__INTCFG CYREG_PRT4_INTCFG
N#define UART_1_rx__0__INTSTAT CYREG_PRT4_INTSTAT
N#define UART_1_rx__0__MASK 0x01u
N#define UART_1_rx__0__PC CYREG_PRT4_PC
N#define UART_1_rx__0__PC2 CYREG_PRT4_PC2
N#define UART_1_rx__0__PORT 4u
N#define UART_1_rx__0__PS CYREG_PRT4_PS
N#define UART_1_rx__0__SHIFT 0
N#define UART_1_rx__DR CYREG_PRT4_DR
N#define UART_1_rx__INTCFG CYREG_PRT4_INTCFG
N#define UART_1_rx__INTSTAT CYREG_PRT4_INTSTAT
N#define UART_1_rx__MASK 0x01u
N#define UART_1_rx__PC CYREG_PRT4_PC
N#define UART_1_rx__PC2 CYREG_PRT4_PC2
N#define UART_1_rx__PORT 4u
N#define UART_1_rx__PS CYREG_PRT4_PS
N#define UART_1_rx__SHIFT 0
N
N/* UART_1_tx */
N#define UART_1_tx__0__DM__MASK 0x38u
N#define UART_1_tx__0__DM__SHIFT 3
N#define UART_1_tx__0__DR CYREG_PRT4_DR
N#define UART_1_tx__0__HSIOM CYREG_HSIOM_PORT_SEL4
N#define UART_1_tx__0__HSIOM_MASK 0x000000F0u
N#define UART_1_tx__0__HSIOM_SHIFT 4u
N#define UART_1_tx__0__INTCFG CYREG_PRT4_INTCFG
N#define UART_1_tx__0__INTSTAT CYREG_PRT4_INTSTAT
N#define UART_1_tx__0__MASK 0x02u
N#define UART_1_tx__0__PC CYREG_PRT4_PC
N#define UART_1_tx__0__PC2 CYREG_PRT4_PC2
N#define UART_1_tx__0__PORT 4u
N#define UART_1_tx__0__PS CYREG_PRT4_PS
N#define UART_1_tx__0__SHIFT 1
N#define UART_1_tx__DR CYREG_PRT4_DR
N#define UART_1_tx__INTCFG CYREG_PRT4_INTCFG
N#define UART_1_tx__INTSTAT CYREG_PRT4_INTSTAT
N#define UART_1_tx__MASK 0x02u
N#define UART_1_tx__PC CYREG_PRT4_PC
N#define UART_1_tx__PC2 CYREG_PRT4_PC2
N#define UART_1_tx__PORT 4u
N#define UART_1_tx__PS CYREG_PRT4_PS
N#define UART_1_tx__SHIFT 1
N
N/* SPI_SCB */
N#define SPI_SCB__BIST_CONTROL CYREG_SCB1_BIST_CONTROL
N#define SPI_SCB__BIST_DATA CYREG_SCB1_BIST_DATA
N#define SPI_SCB__CTRL CYREG_SCB1_CTRL
N#define SPI_SCB__EZ_DATA00 CYREG_SCB1_EZ_DATA00
N#define SPI_SCB__EZ_DATA01 CYREG_SCB1_EZ_DATA01
N#define SPI_SCB__EZ_DATA02 CYREG_SCB1_EZ_DATA02
N#define SPI_SCB__EZ_DATA03 CYREG_SCB1_EZ_DATA03
N#define SPI_SCB__EZ_DATA04 CYREG_SCB1_EZ_DATA04
N#define SPI_SCB__EZ_DATA05 CYREG_SCB1_EZ_DATA05
N#define SPI_SCB__EZ_DATA06 CYREG_SCB1_EZ_DATA06
N#define SPI_SCB__EZ_DATA07 CYREG_SCB1_EZ_DATA07
N#define SPI_SCB__EZ_DATA08 CYREG_SCB1_EZ_DATA08
N#define SPI_SCB__EZ_DATA09 CYREG_SCB1_EZ_DATA09
N#define SPI_SCB__EZ_DATA10 CYREG_SCB1_EZ_DATA10
N#define SPI_SCB__EZ_DATA11 CYREG_SCB1_EZ_DATA11
N#define SPI_SCB__EZ_DATA12 CYREG_SCB1_EZ_DATA12
N#define SPI_SCB__EZ_DATA13 CYREG_SCB1_EZ_DATA13
N#define SPI_SCB__EZ_DATA14 CYREG_SCB1_EZ_DATA14
N#define SPI_SCB__EZ_DATA15 CYREG_SCB1_EZ_DATA15
N#define SPI_SCB__EZ_DATA16 CYREG_SCB1_EZ_DATA16
N#define SPI_SCB__EZ_DATA17 CYREG_SCB1_EZ_DATA17
N#define SPI_SCB__EZ_DATA18 CYREG_SCB1_EZ_DATA18
N#define SPI_SCB__EZ_DATA19 CYREG_SCB1_EZ_DATA19
N#define SPI_SCB__EZ_DATA20 CYREG_SCB1_EZ_DATA20
N#define SPI_SCB__EZ_DATA21 CYREG_SCB1_EZ_DATA21
N#define SPI_SCB__EZ_DATA22 CYREG_SCB1_EZ_DATA22
N#define SPI_SCB__EZ_DATA23 CYREG_SCB1_EZ_DATA23
N#define SPI_SCB__EZ_DATA24 CYREG_SCB1_EZ_DATA24
N#define SPI_SCB__EZ_DATA25 CYREG_SCB1_EZ_DATA25
N#define SPI_SCB__EZ_DATA26 CYREG_SCB1_EZ_DATA26
N#define SPI_SCB__EZ_DATA27 CYREG_SCB1_EZ_DATA27
N#define SPI_SCB__EZ_DATA28 CYREG_SCB1_EZ_DATA28
N#define SPI_SCB__EZ_DATA29 CYREG_SCB1_EZ_DATA29
N#define SPI_SCB__EZ_DATA30 CYREG_SCB1_EZ_DATA30
N#define SPI_SCB__EZ_DATA31 CYREG_SCB1_EZ_DATA31
N#define SPI_SCB__I2C_CFG CYREG_SCB1_I2C_CFG
N#define SPI_SCB__I2C_CTRL CYREG_SCB1_I2C_CTRL
N#define SPI_SCB__I2C_M_CMD CYREG_SCB1_I2C_M_CMD
N#define SPI_SCB__I2C_STATUS CYREG_SCB1_I2C_STATUS
N#define SPI_SCB__I2C_S_CMD CYREG_SCB1_I2C_S_CMD
N#define SPI_SCB__INTR_CAUSE CYREG_SCB1_INTR_CAUSE
N#define SPI_SCB__INTR_I2C_EC CYREG_SCB1_INTR_I2C_EC
N#define SPI_SCB__INTR_I2C_EC_MASK CYREG_SCB1_INTR_I2C_EC_MASK
N#define SPI_SCB__INTR_I2C_EC_MASKED CYREG_SCB1_INTR_I2C_EC_MASKED
N#define SPI_SCB__INTR_M CYREG_SCB1_INTR_M
N#define SPI_SCB__INTR_M_MASK CYREG_SCB1_INTR_M_MASK
N#define SPI_SCB__INTR_M_MASKED CYREG_SCB1_INTR_M_MASKED
N#define SPI_SCB__INTR_M_SET CYREG_SCB1_INTR_M_SET
N#define SPI_SCB__INTR_RX CYREG_SCB1_INTR_RX
N#define SPI_SCB__INTR_RX_MASK CYREG_SCB1_INTR_RX_MASK
N#define SPI_SCB__INTR_RX_MASKED CYREG_SCB1_INTR_RX_MASKED
N#define SPI_SCB__INTR_RX_SET CYREG_SCB1_INTR_RX_SET
N#define SPI_SCB__INTR_S CYREG_SCB1_INTR_S
N#define SPI_SCB__INTR_SPI_EC CYREG_SCB1_INTR_SPI_EC
N#define SPI_SCB__INTR_SPI_EC_MASK CYREG_SCB1_INTR_SPI_EC_MASK
N#define SPI_SCB__INTR_SPI_EC_MASKED CYREG_SCB1_INTR_SPI_EC_MASKED
N#define SPI_SCB__INTR_S_MASK CYREG_SCB1_INTR_S_MASK
N#define SPI_SCB__INTR_S_MASKED CYREG_SCB1_INTR_S_MASKED
N#define SPI_SCB__INTR_S_SET CYREG_SCB1_INTR_S_SET
N#define SPI_SCB__INTR_TX CYREG_SCB1_INTR_TX
N#define SPI_SCB__INTR_TX_MASK CYREG_SCB1_INTR_TX_MASK
N#define SPI_SCB__INTR_TX_MASKED CYREG_SCB1_INTR_TX_MASKED
N#define SPI_SCB__INTR_TX_SET CYREG_SCB1_INTR_TX_SET
N#define SPI_SCB__RX_CTRL CYREG_SCB1_RX_CTRL
N#define SPI_SCB__RX_FIFO_CTRL CYREG_SCB1_RX_FIFO_CTRL
N#define SPI_SCB__RX_FIFO_RD CYREG_SCB1_RX_FIFO_RD
N#define SPI_SCB__RX_FIFO_RD_SILENT CYREG_SCB1_RX_FIFO_RD_SILENT
N#define SPI_SCB__RX_FIFO_STATUS CYREG_SCB1_RX_FIFO_STATUS
N#define SPI_SCB__RX_MATCH CYREG_SCB1_RX_MATCH
N#define SPI_SCB__SPI_CTRL CYREG_SCB1_SPI_CTRL
N#define SPI_SCB__SPI_STATUS CYREG_SCB1_SPI_STATUS
N#define SPI_SCB__STATUS CYREG_SCB1_STATUS
N#define SPI_SCB__TX_CTRL CYREG_SCB1_TX_CTRL
N#define SPI_SCB__TX_FIFO_CTRL CYREG_SCB1_TX_FIFO_CTRL
N#define SPI_SCB__TX_FIFO_STATUS CYREG_SCB1_TX_FIFO_STATUS
N#define SPI_SCB__TX_FIFO_WR CYREG_SCB1_TX_FIFO_WR
N#define SPI_SCB__UART_CTRL CYREG_SCB1_UART_CTRL
N#define SPI_SCB__UART_RX_CTRL CYREG_SCB1_UART_RX_CTRL
N#define SPI_SCB__UART_RX_STATUS CYREG_SCB1_UART_RX_STATUS
N#define SPI_SCB__UART_TX_CTRL CYREG_SCB1_UART_TX_CTRL
N
N/* SPI_CS */
N#define SPI_CS__0__DM__MASK 0x7000u
N#define SPI_CS__0__DM__SHIFT 12
N#define SPI_CS__0__DR CYREG_PRT3_DR
N#define SPI_CS__0__HSIOM CYREG_HSIOM_PORT_SEL3
N#define SPI_CS__0__HSIOM_MASK 0x000F0000u
N#define SPI_CS__0__HSIOM_SHIFT 16u
N#define SPI_CS__0__INTCFG CYREG_PRT3_INTCFG
N#define SPI_CS__0__INTSTAT CYREG_PRT3_INTSTAT
N#define SPI_CS__0__MASK 0x10u
N#define SPI_CS__0__PA__CFG0 CYREG_UDB_PA3_CFG0
N#define SPI_CS__0__PA__CFG1 CYREG_UDB_PA3_CFG1
N#define SPI_CS__0__PA__CFG10 CYREG_UDB_PA3_CFG10
N#define SPI_CS__0__PA__CFG11 CYREG_UDB_PA3_CFG11
N#define SPI_CS__0__PA__CFG12 CYREG_UDB_PA3_CFG12
N#define SPI_CS__0__PA__CFG13 CYREG_UDB_PA3_CFG13
N#define SPI_CS__0__PA__CFG14 CYREG_UDB_PA3_CFG14
N#define SPI_CS__0__PA__CFG2 CYREG_UDB_PA3_CFG2
N#define SPI_CS__0__PA__CFG3 CYREG_UDB_PA3_CFG3
N#define SPI_CS__0__PA__CFG4 CYREG_UDB_PA3_CFG4
N#define SPI_CS__0__PA__CFG5 CYREG_UDB_PA3_CFG5
N#define SPI_CS__0__PA__CFG6 CYREG_UDB_PA3_CFG6
N#define SPI_CS__0__PA__CFG7 CYREG_UDB_PA3_CFG7
N#define SPI_CS__0__PA__CFG8 CYREG_UDB_PA3_CFG8
N#define SPI_CS__0__PA__CFG9 CYREG_UDB_PA3_CFG9
N#define SPI_CS__0__PC CYREG_PRT3_PC
N#define SPI_CS__0__PC2 CYREG_PRT3_PC2
N#define SPI_CS__0__PORT 3u
N#define SPI_CS__0__PS CYREG_PRT3_PS
N#define SPI_CS__0__SHIFT 4
N#define SPI_CS__DR CYREG_PRT3_DR
N#define SPI_CS__INTCFG CYREG_PRT3_INTCFG
N#define SPI_CS__INTSTAT CYREG_PRT3_INTSTAT
N#define SPI_CS__MASK 0x10u
N#define SPI_CS__PA__CFG0 CYREG_UDB_PA3_CFG0
N#define SPI_CS__PA__CFG1 CYREG_UDB_PA3_CFG1
N#define SPI_CS__PA__CFG10 CYREG_UDB_PA3_CFG10
N#define SPI_CS__PA__CFG11 CYREG_UDB_PA3_CFG11
N#define SPI_CS__PA__CFG12 CYREG_UDB_PA3_CFG12
N#define SPI_CS__PA__CFG13 CYREG_UDB_PA3_CFG13
N#define SPI_CS__PA__CFG14 CYREG_UDB_PA3_CFG14
N#define SPI_CS__PA__CFG2 CYREG_UDB_PA3_CFG2
N#define SPI_CS__PA__CFG3 CYREG_UDB_PA3_CFG3
N#define SPI_CS__PA__CFG4 CYREG_UDB_PA3_CFG4
N#define SPI_CS__PA__CFG5 CYREG_UDB_PA3_CFG5
N#define SPI_CS__PA__CFG6 CYREG_UDB_PA3_CFG6
N#define SPI_CS__PA__CFG7 CYREG_UDB_PA3_CFG7
N#define SPI_CS__PA__CFG8 CYREG_UDB_PA3_CFG8
N#define SPI_CS__PA__CFG9 CYREG_UDB_PA3_CFG9
N#define SPI_CS__PC CYREG_PRT3_PC
N#define SPI_CS__PC2 CYREG_PRT3_PC2
N#define SPI_CS__PORT 3u
N#define SPI_CS__PS CYREG_PRT3_PS
N#define SPI_CS__SHIFT 4
N
N/* Miscellaneous */
N/* -- WARNING: define names containing LEOPARD or PANTHER are deprecated and will be removed in a future release */
N#define CYDEV_DEBUG_PROTECT_OPEN 1
N#define CYDEV_DEBUGGING_DPS_SWD 2
N#define CYDEV_CONFIG_UNUSED_IO_AllowButWarn 0
N#define CYDEV_CONFIGURATION_MODE_COMPRESSED 0
N#define CYDEV_CHIP_REV_PSOC4A_PRODUCTION 17u
N#define CYDEV_CHIP_REVISION_4A_PRODUCTION 17u
N#define CYDEV_CHIP_MEMBER_4A 2u
N#define CYDEV_CHIP_FAMILY_PSOC4 2u
N#define CYDEV_CHIP_DIE_PSOC4A 2u
N#define CYDEV_CHIP_DIE_EXPECT CYDEV_CHIP_DIE_PSOC4A
N#define CYDEV_BCLK__HFCLK__HZ 48000000U
N#define CYDEV_BCLK__HFCLK__KHZ 48000U
N#define CYDEV_BCLK__HFCLK__MHZ 48U
N#define CYDEV_BCLK__SYSCLK__HZ 48000000U
N#define CYDEV_BCLK__SYSCLK__KHZ 48000U
N#define CYDEV_BCLK__SYSCLK__MHZ 48U
N#define CYDEV_CHIP_DIE_ACTUAL CYDEV_CHIP_DIE_EXPECT
N#define CYDEV_CHIP_DIE_LEOPARD 1u
N#define CYDEV_CHIP_DIE_PANTHER 3u
N#define CYDEV_CHIP_DIE_PSOC5LP 4u
N#define CYDEV_CHIP_DIE_UNKNOWN 0u
N#define CYDEV_CHIP_FAMILY_PSOC3 1u
N#define CYDEV_CHIP_FAMILY_PSOC5 3u
N#define CYDEV_CHIP_FAMILY_UNKNOWN 0u
N#define CYDEV_CHIP_FAMILY_USED CYDEV_CHIP_FAMILY_PSOC4
N#define CYDEV_CHIP_JTAG_ID 0x04C81193u
N#define CYDEV_CHIP_MEMBER_3A 1u
N#define CYDEV_CHIP_MEMBER_5A 3u
N#define CYDEV_CHIP_MEMBER_5B 4u
N#define CYDEV_CHIP_MEMBER_UNKNOWN 0u
N#define CYDEV_CHIP_MEMBER_USED CYDEV_CHIP_MEMBER_4A
N#define CYDEV_CHIP_REVISION_3A_ES1 0u
N#define CYDEV_CHIP_REVISION_3A_ES2 1u
N#define CYDEV_CHIP_REVISION_3A_ES3 3u
N#define CYDEV_CHIP_REVISION_3A_PRODUCTION 3u
N#define CYDEV_CHIP_REVISION_4A_ES0 17u
N#define CYDEV_CHIP_REVISION_5A_ES0 0u
N#define CYDEV_CHIP_REVISION_5A_ES1 1u
N#define CYDEV_CHIP_REVISION_5A_PRODUCTION 1u
N#define CYDEV_CHIP_REVISION_5B_ES0 0u
N#define CYDEV_CHIP_REVISION_5B_PRODUCTION 0u
N#define CYDEV_CHIP_REVISION_USED CYDEV_CHIP_REVISION_4A_PRODUCTION
N#define CYDEV_CHIP_REV_EXPECT CYDEV_CHIP_REV_PSOC4A_PRODUCTION
N#define CYDEV_CHIP_REV_LEOPARD_ES1 0u
N#define CYDEV_CHIP_REV_LEOPARD_ES2 1u
N#define CYDEV_CHIP_REV_LEOPARD_ES3 3u
N#define CYDEV_CHIP_REV_LEOPARD_PRODUCTION 3u
N#define CYDEV_CHIP_REV_PANTHER_ES0 0u
N#define CYDEV_CHIP_REV_PANTHER_ES1 1u
N#define CYDEV_CHIP_REV_PANTHER_PRODUCTION 1u
N#define CYDEV_CHIP_REV_PSOC4A_ES0 17u
N#define CYDEV_CHIP_REV_PSOC5LP_ES0 0u
N#define CYDEV_CHIP_REV_PSOC5LP_PRODUCTION 0u
N#define CYDEV_CONFIGURATION_COMPRESSED 1
N#define CYDEV_CONFIGURATION_MODE CYDEV_CONFIGURATION_MODE_COMPRESSED
N#define CYDEV_CONFIGURATION_MODE_DMA 2
N#define CYDEV_CONFIGURATION_MODE_UNCOMPRESSED 1
N#define CYDEV_CONFIG_READ_ACCELERATOR 1
N#define CYDEV_CONFIG_UNUSED_IO CYDEV_CONFIG_UNUSED_IO_AllowButWarn
N#define CYDEV_CONFIG_UNUSED_IO_AllowWithInfo 1
N#define CYDEV_CONFIG_UNUSED_IO_Disallowed 2
N#define CYDEV_DEBUGGING_DPS CYDEV_DEBUGGING_DPS_SWD
N#define CYDEV_DEBUGGING_DPS_Disable 3
N#define CYDEV_DEBUGGING_ENABLE 1
N#define CYDEV_DEBUG_PROTECT CYDEV_DEBUG_PROTECT_OPEN
N#define CYDEV_DEBUG_PROTECT_KILL 4
N#define CYDEV_DEBUG_PROTECT_PROTECTED 2
N#define CYDEV_HEAP_SIZE 0x0100
N#define CYDEV_PROJ_TYPE 0
N#define CYDEV_PROJ_TYPE_BOOTLOADER 1
N#define CYDEV_PROJ_TYPE_LOADABLE 2
N#define CYDEV_PROJ_TYPE_MULTIAPPBOOTLOADER 3
N#define CYDEV_PROJ_TYPE_STANDARD 0
N#define CYDEV_STACK_SIZE 0x0400
N#define CYDEV_USE_BUNDLED_CMSIS 1
N#define CYDEV_VARIABLE_VDDA 1
N#define CYDEV_VDDA 3.3
N#define CYDEV_VDDA_MV 3300
N#define CYDEV_VDDD 3.3
N#define CYDEV_VDDD_MV 3300
N#define CYDEV_BOOTLOADER_ENABLE 0
N
N#endif /* INCLUDED_CYFITTER_H */
L 22 ".\Generated_Source\PSoC4\UART_1.h" 2
N#include "cytypes.h"
L 1 ".\Generated_Source\PSoC4\cytypes.h" 1
N/*******************************************************************************
N* FILENAME: cytypes.h
N* Version 4.0
N*
N*  Description:
N*  CyTypes provides register access macros and approved types for use in
N*  firmware.
N*
N*  Note:
N*  Due to endiannesses of the hardware and some compilers, the register
N*  access macros for big endian compilers use some library calls to arrange
N*  data the correct way.
N*
N*  Register Access macros and functions perform their operations on an
N*  input of type pointer to void.  The arguments passed to it should be
N*  pointers to the type associated with the register size.
N*  (i.e. a "uint8 *" shouldn't be passed to obtain a 16-bit register value)
N*
N********************************************************************************
N* Copyright 2008-2013, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_BOOT_CYTYPES_H)
X#if !0L
N#define CY_BOOT_CYTYPES_H
N
N#if defined(__C51__)
X#if 0L
S    #include <intrins.h>
N#endif  /* (__C51__) */
N
N/* ARM and C99 or later */
N#if defined(__GNUC__) || defined(__ARMCC_VERSION) || (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L)
X#if 0L || 1L || (1L && 199409L >= 199901L)
N    #include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5030076
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 36 ".\Generated_Source\PSoC4\cytypes.h" 2
N#endif  /* (__GNUC__) || defined(__ARMCC_VERSION) || (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L) */
N
N#include "cyfitter.h"
N
N
N#if defined( __ICCARM__ )
X#if 0L
S    /* Suppress warning for multiple volatile variables in an expression. */
S    /* This is common in component code and the usage is not order dependent. */
S    #pragma diag_suppress=Pa082
N#endif /* defined( __ICCARM__ ) */
N
N
N/***************************************
N* Conditional Compilation Parameters
N***************************************/
N
N
N/*******************************************************************************
N* FAMILY encodes the overall architectural family
N*******************************************************************************/
N#define CY_PSOC3 (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC3)
N#define CY_PSOC4 (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC4)
N#define CY_PSOC5 (CYDEV_CHIP_FAMILY_USED == CYDEV_CHIP_FAMILY_PSOC5)
N
N
N/*******************************************************************************
N* MEMBER encodes both the family and the detailed architecture
N*******************************************************************************/
N#define CY_PSOC4A  (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4A)
N#ifdef CYDEV_CHIP_MEMBER_4D
S    #define CY_PSOC4D   (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_4D)
S    #define CY_PSOC4SF  (CY_PSOC4D)
N#else
N    #define CY_PSOC4D   (0u != 0u)
N    #define CY_PSOC4SF  (CY_PSOC4D)
N#endif  /* CYDEV_CHIP_MEMBER_4D */
N
N#define CY_PSOC5A  (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_5A)
N#ifdef CYDEV_CHIP_MEMBER_5B
N    #define CY_PSOC5LP  (CYDEV_CHIP_MEMBER_USED == CYDEV_CHIP_MEMBER_5B)
N#else
S    #define CY_PSOC5LP  (0u != 0u)
N#endif  /* CYDEV_CHIP_MEMBER_5B */
N
N
N/*******************************************************************************
N* UDB revisions
N*******************************************************************************/
N#define CY_UDB_V0 (CY_PSOC5A)
N#define CY_UDB_V1 (!CY_UDB_V0)
N
N
N/*******************************************************************************
N*   Base Types. Acceptable types from MISRA-C specifying signedness and size.
N*******************************************************************************/
Ntypedef unsigned char   uint8;
Ntypedef unsigned short  uint16;
Ntypedef unsigned long   uint32;
Ntypedef signed   char   int8;
Ntypedef signed   short  int16;
Ntypedef signed   long   int32;
Ntypedef          float  float32;
N
N#if(!CY_PSOC3)
X#if(!(2u == 1u))
N
N    typedef               double float64;
N    typedef          long long   int64;
N    typedef unsigned long long   uint64;
N
N#endif  /* (!CY_PSOC3) */
N
N/* Signed or unsigned depending on the compiler selection */
Ntypedef          char   char8;
N
N
N/*******************************************************************************
N*   Memory address functions prototypes
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    /***************************************************************************
S    * Prototypes for absolute memory address functions (cymem.a51) with built-in
S    * endian conversion. These functions should be called through the
S    * CY_GET_XTND_REGxx and CY_SET_XTND_REGxx macros.
S    ***************************************************************************/
S    extern uint8  cyread8       (const volatile void far *addr);
S    extern void   cywrite8      (volatile void far *addr, uint8 value);
S
S    extern uint16 cyread16      (const volatile void far *addr);
S    extern uint16 cyread16_nodpx(const volatile void far *addr);
S
S    extern void   cywrite16      (volatile void far *addr, uint16 value);
S    extern void   cywrite16_nodpx(volatile void far *addr, uint16 value);
S
S    extern uint32 cyread24      (const volatile void far *addr);
S    extern uint32 cyread24_nodpx(const volatile void far *addr);
S
S    extern void   cywrite24      (volatile void far *addr, uint32 value);
S    extern void   cywrite24_nodpx(volatile void far *addr, uint32 value);
S
S    extern uint32 cyread32      (const volatile void far *addr);
S    extern uint32 cyread32_nodpx(const volatile void far *addr);
S
S    extern void   cywrite32      (volatile void far *addr, uint32 value);
S    extern void   cywrite32_nodpx(volatile void far *addr, uint32 value);
S
S
S    /***************************************************************************
S    * Memory access routines from cymem.a51 for the generated device
S    * configuration code. These functions may be subject to change in future
S    * revisions of the cy_boot component and they are not available for all
S    * devices. Most code should use memset or memcpy instead.
S    ***************************************************************************/
S    void cymemzero(void far *addr, uint16 size);
S    void cyconfigcpy(uint16 size, const void far *src, void far *dest) large;
S    void cyconfigcpycode(uint16 size, const void code *src, void far *dest);
S
S    #define CYCONFIGCPY_DECLARED    (1)
S
N#else
N
N    /* Prototype for function to set a 24-bit register. Located at cyutils.c */
N    extern void     CySetReg24(uint32 volatile * addr, uint32 value);
N
N    #if(CY_PSOC4)
X    #if((2u == 2u))
N
N        extern uint32 CyGetReg24(uint32 const volatile * addr);
N
N    #endif  /* (CY_PSOC4) */
N
N#endif  /* (CY_PSOC3) */
N
N
N/*******************************************************************************
N*   Memory model definitions. To allow code to be 8051-ARM agnostic.
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    #define CYBDATA     bdata
S    #define CYBIT       bit
S    #define CYCODE      code
S    #define CYCOMPACT   compact
S    #define CYDATA      data
S    #define CYFAR       far
S    #define CYIDATA     idata
S    #define CYLARGE     large
S    #define CYPDATA     pdata
S    #define CYREENTRANT reentrant
S    #define CYSMALL     small
S    #define CYXDATA     xdata
S    #define XDATA       xdata
S
S    #define CY_NOINIT
S
N#else
N
N    #define CYBDATA
N    #define CYBIT      uint8
N    #define CYCODE
N    #define CYCOMPACT
N    #define CYDATA
N    #define CYFAR
N    #define CYIDATA
N    #define CYLARGE
N    #define CYPDATA
N    #define CYREENTRANT
N    #define CYSMALL
N    #define CYXDATA
N    #define XDATA
N
N    #if defined(__ARMCC_VERSION)
X    #if 1L
N        #define CY_NOINIT           __attribute__ ((section(".noinit"), zero_init))
N        #define CY_NORETURN         __attribute__ ((noreturn))
N        #define CY_SECTION(name)    __attribute__ ((section(name)))
N        #define CY_ALIGN(align)     __align(align)
N    #elif defined (__GNUC__)
S        #define CY_NOINIT           __attribute__ ((section(".noinit")))
S        #define CY_NORETURN         __attribute__ ((noreturn))
S        #define CY_SECTION(name)    __attribute__ ((section(name)))
S        #define CY_ALIGN(align)     __attribute__ ((aligned(align)))
S    #elif defined (__ICCARM__)
S        #define CY_NOINIT           __no_init
S        #define CY_NORETURN         __noreturn
N    #endif  /* (__ARMCC_VERSION) */
N
N#endif  /* (CY_PSOC3) */
N
N
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    /* 8051 naturally returns an 8 bit value. */
S    typedef unsigned char cystatus;
S
N#else
N
N    /* ARM naturally returns a 32 bit value. */
N    typedef unsigned long cystatus;
N
N#endif  /* (CY_PSOC3) */
N
N
N/*******************************************************************************
N*  Hardware Register Types.
N*******************************************************************************/
Ntypedef volatile uint8  CYXDATA reg8;
Xtypedef volatile uint8   reg8;
Ntypedef volatile uint16 CYXDATA reg16;
Xtypedef volatile uint16  reg16;
Ntypedef volatile uint32 CYXDATA reg32;
Xtypedef volatile uint32  reg32;
N
N
N/*******************************************************************************
N*  Interrupt Types and Macros
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    #define CY_ISR(FuncName)        void FuncName (void) interrupt 0
S    #define CY_ISR_PROTO(FuncName)  void FuncName (void)
S    typedef void (CYCODE * cyisraddress)(void);
S
N#else
N
N    #define CY_ISR(FuncName)        void FuncName (void)
N    #define CY_ISR_PROTO(FuncName)  void FuncName (void)
N    typedef void (* cyisraddress)(void);
N
N    #if defined (__ICCARM__)
X    #if 0L
S        typedef union { cyisraddress __fun; void * __ptr; } intvec_elem;
N    #endif  /* defined (__ICCARM__) */
N
N#endif  /* (CY_PSOC3) */
N
N
N/*******************************************************************************
N*  Register Access
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S
S    /*******************************************************************************
S    * KEIL for the 8051 is a big endian compiler This causes problems as the on chip
S    * registers are little endian.  Byte swapping for two and four byte registers is
S    * implemented in the functions below.  This will require conditional compilation
S    * of function prototypes in code.
S    *******************************************************************************/
S
S    /* Access macros for 8, 16, 24 and 32-bit registers, IN THE FIRST 64K OF XDATA */
S
S    #define CY_GET_REG8(addr)               (*((const reg8 *)(addr)))
S    #define CY_SET_REG8(addr, value)        (*((reg8 *)(addr))  = (uint8)(value))
S
S    #define CY_GET_REG16(addr)              cyread16_nodpx ((const volatile void far *)(const reg16 *)(addr))
S    #define CY_SET_REG16(addr, value)       cywrite16_nodpx((volatile void far *)(reg16 *)(addr), value)
S
S    #define CY_GET_REG24(addr)              cyread24_nodpx ((const volatile void far *)(const reg32 *)(addr))
S    #define CY_SET_REG24(addr, value)       cywrite24_nodpx((volatile void far *)(reg32 *)(addr),value)
S
S    #define CY_GET_REG32(addr)              cyread32_nodpx ((const volatile void far *)(const reg32 *)(addr))
S    #define CY_SET_REG32(addr, value)       cywrite32_nodpx((volatile void far *)(reg32 *)(addr), value)
S
S    /* Access 8, 16, 24 and 32-bit registers, ABOVE THE FIRST 64K OF XDATA */
S    #define CY_GET_XTND_REG8(addr)          cyread8((const volatile void far *)(addr))
S    #define CY_SET_XTND_REG8(addr, value)   cywrite8((volatile void far *)(addr), value)
S
S    #define CY_GET_XTND_REG16(addr)         cyread16((const volatile void far *)(addr))
S    #define CY_SET_XTND_REG16(addr, value)  cywrite16((volatile void far *)(addr), value)
S
S    #define CY_GET_XTND_REG24(addr)         cyread24((const volatile void far *)(addr))
S    #define CY_SET_XTND_REG24(addr, value)  cywrite24((volatile void far *)(addr), value)
S
S    #define CY_GET_XTND_REG32(addr)         cyread32((const volatile void far *)(addr))
S    #define CY_SET_XTND_REG32(addr, value)  cywrite32((volatile void far *)(addr), value)
S
N#else
N
N    /* 8, 16, 24 and 32-bit register access macros */
N    #define CY_GET_REG8(addr)               (*((const reg8 *)(addr)))
N    #define CY_SET_REG8(addr, value)        (*((reg8 *)(addr))  = (uint8)(value))
N
N    #define CY_GET_REG16(addr)              (*((const reg16 *)(addr)))
N    #define CY_SET_REG16(addr, value)       (*((reg16 *)(addr)) = (uint16)(value))
N
N
N    #define CY_SET_REG24(addr, value)       CySetReg24((reg32 *) (addr), (value))
N    #if(CY_PSOC4)
X    #if((2u == 2u))
N        #define CY_GET_REG24(addr)          CyGetReg24((const reg32 *) (addr))
N    #else
S        #define CY_GET_REG24(addr)          (*((const reg32 *)(addr)) & 0x00FFFFFFu)
N    #endif  /* (CY_PSOC4) */
N
N
N    #define CY_GET_REG32(addr)              (*((const reg32 *)(addr)))
N    #define CY_SET_REG32(addr, value)       (*((reg32 *)(addr)) = (uint32)(value))
N
N
N    /* To allow code to be 8051-ARM agnostic. */
N    #define CY_GET_XTND_REG8(addr)          CY_GET_REG8(addr)
N    #define CY_SET_XTND_REG8(addr, value)   CY_SET_REG8(addr, value)
N
N    #define CY_GET_XTND_REG16(addr)         CY_GET_REG16(addr)
N    #define CY_SET_XTND_REG16(addr, value)  CY_SET_REG16(addr, value)
N
N    #define CY_GET_XTND_REG24(addr)         CY_GET_REG24(addr)
N    #define CY_SET_XTND_REG24(addr, value)  CY_SET_REG24(addr, value)
N
N    #define CY_GET_XTND_REG32(addr)         CY_GET_REG32(addr)
N    #define CY_SET_XTND_REG32(addr, value)  CY_SET_REG32(addr, value)
N
N#endif  /* (CY_PSOC3) */
N
N
N
N/*******************************************************************************
N*  Data manipulation defines
N*******************************************************************************/
N
N/* Get 8 bits of a 16 bit value. */
N#define LO8(x)                  ((uint8) ((x) & 0xFFu))
N#define HI8(x)                  ((uint8) ((uint16)(x) >> 8))
N
N/* Get 16 bits of a 32 bit value. */
N#define LO16(x)                 ((uint16) ((x) & 0xFFFFu))
N#define HI16(x)                 ((uint16) ((uint32)(x) >> 16))
N
N/* Swap the byte ordering of a 32 bit value */
N#define CYSWAP_ENDIAN32(x)  \
N        ((uint32)(((x) >> 24) | (((x) & 0x00FF0000u) >> 8) | (((x) & 0x0000FF00u) << 8) | ((x) << 24)))
X#define CYSWAP_ENDIAN32(x)          ((uint32)(((x) >> 24) | (((x) & 0x00FF0000u) >> 8) | (((x) & 0x0000FF00u) << 8) | ((x) << 24)))
N
N/* Swap the byte ordering of a 16 bit value */
N#define CYSWAP_ENDIAN16(x)      ((uint16)(((x) << 8) | ((x) >> 8)))
N
N
N/*******************************************************************************
N* Defines the standard return values used PSoC content. A function is
N* not limited to these return values but can use them when returning standard
N* error values. Return values can be overloaded if documented in the function
N* header. On the 8051 a function can use a larger return type but still use the
N* defined return codes.
N*
N* Zero is successful, all other values indicate some form of failure. 1 - 0x7F -
N* standard defined values; 0x80 - ...  - user or content defined values.
N*******************************************************************************/
N#define CYRET_SUCCESS           (0x00u)           /* Successful */
N#define CYRET_BAD_PARAM         (0x01u)           /* One or more invalid parameters */
N#define CYRET_INVALID_OBJECT    (0x02u)           /* Invalid object specified */
N#define CYRET_MEMORY            (0x03u)           /* Memory related failure */
N#define CYRET_LOCKED            (0x04u)           /* Resource lock failure */
N#define CYRET_EMPTY             (0x05u)           /* No more objects available */
N#define CYRET_BAD_DATA          (0x06u)           /* Bad data received (CRC or other error check) */
N#define CYRET_STARTED           (0x07u)           /* Operation started, but not necessarily completed yet */
N#define CYRET_FINISHED          (0x08u)           /* Operation completed */
N#define CYRET_CANCELED          (0x09u)           /* Operation canceled */
N#define CYRET_TIMEOUT           (0x10u)           /* Operation timed out */
N#define CYRET_INVALID_STATE     (0x11u)           /* Operation not setup or is in an improper state */
N#define CYRET_UNKNOWN           ((cystatus) 0xFFFFFFFFu)    /* Unknown failure */
N
N
N/*******************************************************************************
N*   Intrinsic Defines: Processor NOP instruction
N*******************************************************************************/
N#if(CY_PSOC3)
X#if((2u == 1u))
S
S    #define CY_NOP          _nop_()
S
N#else
N
N    #if defined(__ARMCC_VERSION)
X    #if 1L
N
N        /* RealView */
N        #define CY_NOP      __nop()
N
N    #else
S
S        /* GCC */
S        #define CY_NOP      __asm("NOP\n")
S
N    #endif  /* defined(__ARMCC_VERSION) */
N
N#endif  /* (CY_PSOC3) */
N
N#endif  /* CY_BOOT_CYTYPES_H */
N
N
N/* [] END OF FILE */
L 23 ".\Generated_Source\PSoC4\UART_1.h" 2
N#include "CyLib.h"
L 1 ".\Generated_Source\PSoC4\CyLib.h" 1
N/*******************************************************************************
N* File Name: CyLib.h
N* Version 4.0
N*
N*  Description:
N*
N*  Note:
N*   Documentation of the API's in this file is located in the
N*   System Reference Guide provided with PSoC Creator.
N*
N********************************************************************************
N* Copyright 2008-2013, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_BOOT_CYLIB_H)
X#if !0L
N#define CY_BOOT_CYLIB_H
N
N#include "cytypes.h"
N#include "cydevice_trm.h"
N
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 25 ".\Generated_Source\PSoC4\CyLib.h" 2
N#include <limits.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5030076
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
N  #define CHAR_MIN (-128)
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 127
N      /* maximum value for an object of type char */
N#else
S  #define CHAR_MIN 0
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 255
S      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#define LONG_MIN  (~0x7fffffffL)
N    /* minimum value for an object of type long int */
N#define LONG_MAX  0x7fffffffL
N    /* maximum value for an object of type long int */
N#define ULONG_MAX 0xffffffffUL
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 26 ".\Generated_Source\PSoC4\CyLib.h" 2
N#include <ctype.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5030076
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
S#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __pure unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
X__inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 27 ".\Generated_Source\PSoC4\CyLib.h" 2
N
N
N/***************************************
N*    Function Prototypes
N***************************************/
N
N/* Clocks API */
Nvoid CySysClkImoStart(void);
Nvoid CySysClkImoStop(void);
Nvoid CySysClkIloStart(void);
Nvoid CySysClkIloStop(void);
Nvoid CySysClkWriteHfclkDirect(uint32 clkSelect);
Nvoid CySysClkWriteSysclkDiv(uint32 divider);
Nvoid CySysClkWriteImoFreq(uint32 freq);
N
N#if(CY_PSOC4A)
X#if((2u == 2u))
N    /* WDT API */
N    void   CySysWdtLock(void);
N    void   CySysWdtUnlock(void);
N    void   CySysWdtWriteMode(uint32 counterNum, uint32 mode);
N    uint32 CySysWdtReadMode(uint32 counterNum);
N    uint32 CySysWdtReadEnabledStatus(uint32 counterNum);
N    void   CySysWdtWriteClearOnMatch(uint32 counterNum, uint32 enable);
N    uint32 CySysWdtReadClearOnMatch(uint32 counterNum);
N    void   CySysWdtEnable(uint32 counterMask);
N    void   CySysWdtDisable(uint32 counterMask);
N    void   CySysWdtWriteCascade(uint32 cascadeMask);
N    uint32 CySysWdtReadCascade(void);
N    void   CySysWdtWriteMatch(uint32 counterNum, uint32 match);
N    void   CySysWdtWriteToggleBit(uint32 bits);
N    uint32 CySysWdtReadToggleBit(void);
N    uint32 CySysWdtReadMatch(uint32 counterNum);
N    uint32 CySysWdtReadCount(uint32 counterNum);
N    uint32 CySysWdtGetInterruptSource(void);
N    void   CySysWdtClearInterrupt(uint32 counterMask);
N    void   CySysWdtResetCounters(uint32 countersMask);
N
N    /* Low Voltage Detection */
N    void   CySysLvdEnable(uint32 threshold);
N    void   CySysLvdDisable(void);
N    uint32 CySysLvdGetInterruptSource(void);
N    void   CySysLvdClearInterrupt(void);
N#else
S    /* WDT API */
S    uint32 CySysWdtReadEnabledStatus(void);
S    void   CySysWdtEnable(void);
S    void   CySysWdtDisable(void);
S    void   CySysWdtWriteMatch(uint32 match);
S    uint32 CySysWdtReadMatch(void);
S    uint32 CySysWdtReadCount(void);
S    void   CySysWdtWriteIgnoreBits(uint32 bitsNum);
S    uint32 CySysWdtReadIgnoreBits(void);
S    void   CySysWdtClearInterrupt(void);
S    void   CySysWdtMaskInterrupt(void);
S    void   CySysWdtUnmaskInterrupt(void);
N#endif  /* (CY_PSOC4A) */
N
N/* Interrupt Function Prototypes */
Ncyisraddress CyIntSetSysVector(uint8 number, cyisraddress address);
Ncyisraddress CyIntGetSysVector(uint8 number);
N
Ncyisraddress CyIntSetVector(uint8 number, cyisraddress address);
Ncyisraddress CyIntGetVector(uint8 number);
N
Nvoid   CyIntSetPriority(uint8 number, uint8 priority);
Nuint8  CyIntGetPriority(uint8 number);
N
Nvoid   CyIntEnable(uint8 number);
Nuint8  CyIntGetState(uint8 number);
Nvoid   CyIntDisable(uint8 number);
N
Nvoid   CyIntSetPending(uint8 number);
Nvoid   CyIntClearPending(uint8 number);
N
Nuint32 CyDisableInts(void);
Nvoid   CyEnableInts(uint32 mask);
N
N/* System Function Prototypes */
Nvoid  CyDelay(uint32 milliseconds);
Nvoid  CyDelayUs(uint16 microseconds);
Nvoid  CyDelayFreq(uint32 freq);
Nvoid  CyDelayCycles(uint32 cycles);
N
N/* General APIs */
Nvoid  CySoftwareReset(void);
Nuint8 CyEnterCriticalSection(void);
Nvoid  CyExitCriticalSection(uint8 savedIntrStatus);
Nvoid  CyHalt(uint8 reason);
N
N
N/* Do not use these definitions directly in your application */
Nextern uint32 cydelayFreqHz;
Nextern uint32 cydelayFreqKhz;
Nextern uint8  cydelayFreqMhz;
Nextern uint32 cydelay32kMs;
N
N
N/***************************************
N* API Constants
N***************************************/
N
N
N/*******************************************************************************
N* Clock API Constants
N*******************************************************************************/
N
N/* CySysClkWriteSysclkDiv() - parameter definitions */
N#define CY_SYS_CLK_SYSCLK_DIV1              (0u)
N#define CY_SYS_CLK_SYSCLK_DIV2              (1u)
N#define CY_SYS_CLK_SYSCLK_DIV4              (2u)
N#define CY_SYS_CLK_SYSCLK_DIV8              (3u)
N#define CY_SYS_CLK_SYSCLK_DIV16             (4u)
N#define CY_SYS_CLK_SYSCLK_DIV32             (5u)
N#define CY_SYS_CLK_SYSCLK_DIV64             (6u)
N#define CY_SYS_CLK_SYSCLK_DIV128            (7u)
N
N/* CySysClkWriteSysclkDiv() - implementation definitions */
N#define CY_SYS_CLK_SELECT_SYSCLK_DIV_SHIFT  (19u)
N#define CY_SYS_CLK_SELECT_SYSCLK_DIV_MASK   (( uint32 )0x07u)
N
N
N/* CySysClkWriteHfclkDirect() - parameter definitions */
N#define CY_SYS_CLK_HFCLK_IMO                (0u)
N#define CY_SYS_CLK_HFCLK_EXTCLK             (1u)
N
N/* CySysClkWriteHfclkDirect() - implementation definitions */
N#define CY_SYS_CLK_SELECT_DIRECT_SEL_MASK   (( uint32 ) 0x07u)
N#define CY_SYS_CLK_SELECT_DIRECT_SEL_PARAM_MASK     (( uint32 ) 0x01u)
N
N
N#define CY_SYS_CLK_IMO_CONFIG_ENABLE        (( uint32 )(( uint32 )0x01u << 31u))
N#define CY_SYS_CLK_IMO_FREQ_BITS_MASK       (( uint32 )0x3Fu)
N#define CY_SYS_CLK_IMO_FREQ_CLEAR           (( uint32 )(CY_SYS_CLK_IMO_FREQ_BITS_MASK << 8u))
N#define CY_SYS_CLK_ILO_CONFIG_ENABLE        (( uint32 )(( uint32 )0x01u << 31u))
N
N
N/* CySysClkWriteImoFreq() - implementation definitions */
N#define CY_SYS_CLK_IMO_MAX_FREQ_MHZ             (48u)
N
N#if(CY_PSOC4A)
X#if((2u == 2u))
N    #define CY_SYS_CLK_IMO_MIN_FREQ_MHZ         (3u)
N    #define CY_SYS_CLK_IMO_TEMP_FREQ_MHZ        (24u)
N    #define CY_SYS_CLK_IMO_BOUNDARY_FREQ_MHZ    (43u)
N    #define CY_SYS_CLK_IMO_FREQ_TIMEOUT_CYCLES  (5u)
N    #define CY_SYS_CLK_IMO_TRIM_TIMEOUT_US      (5u)
N    #define CY_SYS_CLK_IMO_FREQ_TABLE_SIZE      (46u)
N    #define CY_SYS_CLK_IMO_FREQ_TABLE_OFFSET    (3u)
N#else
S    #define CY_SYS_CLK_IMO_MIN_FREQ_MHZ         (24u)
N#endif  /* (CY_PSOC4A) */
N
N/* SFLASH0 block has been renamed to SFLASH */
N#if !defined(CYREG_SFLASH_IMO_TRIM21)
X#if !1L
S    #define CYREG_SFLASH_IMO_TRIM21         (CYREG_SFLASH0_IMO_TRIM21)
N#endif  /* !defined(CYREG_SFLASH_IMO_TRIM21) */
N
N
N/*******************************************************************************
N* WDT API Constants
N*******************************************************************************/
N#if(CY_PSOC4A)
X#if((2u == 2u))
N    #define CY_SYS_WDT_MODE_NONE                (0u)
N    #define CY_SYS_WDT_MODE_INT                 (1u)
N    #define CY_SYS_WDT_MODE_RESET               (2u)
N    #define CY_SYS_WDT_MODE_INT_RESET           (3u)
N
N    #define CY_SYS_WDT_COUNTER0_MASK            (0x01u)
N    #define CY_SYS_WDT_COUNTER1_MASK            (0x01u << 8u)
N    #define CY_SYS_WDT_COUNTER2_MASK            (0x01u << 16u)
N
N    #define CY_SYS_WDT_CASCADE_NONE             ((uint32)0x00u)
N    #define CY_SYS_WDT_CASCADE_01               ((uint32)0x01u << 3u)
N    #define CY_SYS_WDT_CASCADE_12               ((uint32)0x01u << 11u)
N
N    #define CY_SYS_WDT_COUNTER0_INT             ((uint32)0x01u << 2u)
N    #define CY_SYS_WDT_COUNTER1_INT             ((uint32)0x01u << 10u)
N    #define CY_SYS_WDT_COUNTER2_INT             ((uint32)0x01u << 18u)
N
N    #define CY_SYS_WDT_COUNTER0_RESET           ((uint32)0x01u << 3u)
N    #define CY_SYS_WDT_COUNTER1_RESET           ((uint32)0x01u << 11u)
N    #define CY_SYS_WDT_COUNTER2_RESET           ((uint32)0x01u << 19u)
N
N    #define CY_SYS_WDT_COUNTER0                 (0x00u)
N    #define CY_SYS_WDT_COUNTER1                 (0x01u)
N    #define CY_SYS_WDT_COUNTER2                 (0x02u)
N
N    #define CY_SYS_WDT_MODE_MASK                (uint32)(0x03u)
N
N    #define CY_SYS_WDT_CLK_LOCK_BITS_MASK       ((uint32)0x03u << 14u)
N    #define CY_SYS_WDT_CLK_LOCK_BIT0            ((uint32)0x01u << 14u)
N    #define CY_SYS_WDT_CLK_LOCK_BIT1            ((uint32)0x01u << 15u)
N
N    #define CY_SYS_WDT_CONFIG_BITS2_MASK        (uint32)(0x1Fu)
N    #define CY_SYS_WDT_CONFIG_BITS2_POS         (uint32)(24u)
N    #define CY_SYS_WDT_LOWER_16BITS_MASK        (uint32)(0xFFFFu)
N    #define CY_SYS_WDT_COUNTERS_MAX             (0x03u)
N    #define CY_SYS_WDT_CNT_SHIFT                (0x08u)
N    #define CY_SYS_WDT_CNT_MATCH_CLR_SHIFT      (0x02u)
N    #define CY_SYS_WDT_CNT_STTS_SHIFT           (0x01u)
N    #define CY_SYS_WDT_CNT_MATCH_SHIFT          (0x10u)
N
N    #define CY_SYS_WDT_3LFCLK_DELAY_US          (0x82u)
N#else
S    #define CY_SYS_WDT_KEY                      (0xACED8865u)
S    #define CY_SYS_WDT_MATCH_MASK               (0x0000FFFFu)
S    #define CY_SYS_WDT_IGNORE_BITS_MASK         (0x000F0000u)
S    #define CY_SYS_WDT_LOWER_BIT_MASK           (0x00000001u)
N#endif  /* (CY_PSOC4A) */
N
N
N/*******************************************************************************
N* System API Constants
N*******************************************************************************/
N
N/* CySoftwareReset() - implementation definitions */
N
N/* Vector Key */
N#define CY_SYS_CM0_AIRCR_VECTKEY_SHIFT      (16u)
N#define CY_SYS_CM0_AIRCR_VECTKEY            ((uint32)((uint32)0x05FAu << CY_SYS_CM0_AIRCR_VECTKEY_SHIFT))
N#define CY_SYS_CM0_AIRCR_VECTKEY_MASK       ((uint32)((uint32)0xFFFFu << CY_SYS_CM0_AIRCR_VECTKEY_SHIFT))
N
N/* System Reset Request */
N#define CY_SYS_CM0_AIRCR_SYSRESETREQ_SHIFT  (2u)
N#define CY_SYS_CM0_AIRCR_SYSRESETREQ        ((uint32)((uint32)1u << CY_SYS_CM0_AIRCR_SYSRESETREQ_SHIFT))
N
N
N#if defined(__ARMCC_VERSION)
X#if 1L
N
N    #define CyGlobalIntEnable           do                      \
N                                        {                       \
N                                            __enable_irq();     \
N                                        } while ( 0 )
X    #define CyGlobalIntEnable           do                                                              {                                                                   __enable_irq();                                             } while ( 0 )
N
N    #define CyGlobalIntDisable          do                      \
N                                        {                       \
N                                            __disable_irq();    \
N                                        } while ( 0 )
X    #define CyGlobalIntDisable          do                                                              {                                                                   __disable_irq();                                            } while ( 0 )
N
N#elif defined(__GNUC__) || defined (__ICCARM__)
S
S    #define CyGlobalIntEnable           do                      \
S                                        {                       \
S                                            __asm("CPSIE   i"); \
S                                        } while ( 0 )
X    #define CyGlobalIntEnable           do                                                              {                                                                   __asm("CPSIE   i");                                         } while ( 0 )
S
S    #define CyGlobalIntDisable          do                      \
S                                        {                       \
S                                            __asm("CPSID   i"); \
S                                        } while ( 0 )
X    #define CyGlobalIntDisable          do                                                              {                                                                   __asm("CPSID   i");                                         } while ( 0 )
S#else
S    #error No compiler toolchain defined
S    #define CyGlobalIntEnable
S    #define CyGlobalIntDisable
N#endif  /* (__ARMCC_VERSION) */
N
N
N/*******************************************************************************
N* Macro Name: CyAssert
N********************************************************************************
N* Summary:
N*  Macro that evaluates the expression and if it is false (evaluates to 0)
N*  then the processor is halted.
N*
N*  This macro is evaluated unless NDEBUG is defined.
N*  If NDEBUG is defined, then no code is generated for this macro.
N*  NDEBUG is defined by default for a Release build setting and not defined for
N*  a Debug build setting.
N*
N* Parameters:
N*  expr: Logical expression.  Asserts if false.
N*
N* Return:
N*  None
N*
N*******************************************************************************/
N#if !defined(NDEBUG)
X#if !1L
S    #define CYASSERT(x)                 do                              \
S                                        {                               \
S                                            if(0u == (x))               \
S                                            {                           \
S                                                CyHalt((uint8) 0u);     \
S                                            }                           \
S                                        } while ( 0u )
X    #define CYASSERT(x)                 do                                                                      {                                                                           if(0u == (x))                                                           {                                                                           CyHalt((uint8) 0u);                                                 }                                                                   } while ( 0u )
N#else
N    #define CYASSERT(x)
N#endif  /* !defined(NDEBUG) */
N
N
N/*******************************************************************************
N* Interrupt API Constants
N*******************************************************************************/
N#define CY_NUM_INTERRUPTS                   (32u)
N#define CY_MIN_PRIORITY                     (3u)
N
N#define CY_INT_IRQ_BASE                     (16u)
N#define CY_INT_CLEAR_DISABLE_ALL            (0xFFFFFFFFu)
N#define CY_INT_ENABLE_RANGE_MASK            (0x1Fu)
N
N/* Register n contains priorities for interrupts N=4n .. 4n+3 */
N#define CY_INT_PRIORITY_SHIFT(number)       (( uint32 )6u + (8u * (( uint32 )(number) % 4u)))
N
N/* Mask to get valid range of system priority 0-3 */
N#define CY_INT_PRIORITY_MASK                (( uint32 ) 0x03u)
N
N#if(CY_PSOC4A)
X#if((2u == 2u))
N    /*******************************************************************************
N    * Low Voltage Detection API Constants
N    *******************************************************************************/
N
N    /* CySysLvdEnable() - parameter definitions */
N    #define CY_LVD_THRESHOLD_1_75_V             (( uint32 )  0u)
N    #define CY_LVD_THRESHOLD_1_80_V             (( uint32 )  1u)
N    #define CY_LVD_THRESHOLD_1_90_V             (( uint32 )  2u)
N    #define CY_LVD_THRESHOLD_2_00_V             (( uint32 )  3u)
N    #define CY_LVD_THRESHOLD_2_10_V             (( uint32 )  4u)
N    #define CY_LVD_THRESHOLD_2_20_V             (( uint32 )  5u)
N    #define CY_LVD_THRESHOLD_2_30_V             (( uint32 )  6u)
N    #define CY_LVD_THRESHOLD_2_40_V             (( uint32 )  7u)
N    #define CY_LVD_THRESHOLD_2_50_V             (( uint32 )  8u)
N    #define CY_LVD_THRESHOLD_2_60_V             (( uint32 )  9u)
N    #define CY_LVD_THRESHOLD_2_70_V             (( uint32 ) 10u)
N    #define CY_LVD_THRESHOLD_2_80_V             (( uint32 ) 11u)
N    #define CY_LVD_THRESHOLD_2_90_V             (( uint32 ) 12u)
N    #define CY_LVD_THRESHOLD_3_00_V             (( uint32 ) 13u)
N    #define CY_LVD_THRESHOLD_3_20_V             (( uint32 ) 14u)
N    #define CY_LVD_THRESHOLD_4_50_V             (( uint32 ) 15u)
N
N    /* CySysLvdEnable()  - implementation definitions */
N    #define CY_LVD_PWR_VMON_CONFIG_LVD_EN           (( uint32 ) 0x01u)
N    #define CY_LVD_PWR_VMON_CONFIG_LVD_SEL_SHIFT    (1u)
N    #define CY_LVD_PWR_VMON_CONFIG_LVD_SEL_MASK     (( uint32 ) (0x0F << CY_LVD_PWR_VMON_CONFIG_LVD_SEL_SHIFT))
N    #define CY_LVD_PROPAGATE_INT_TO_CPU             (( uint32 ) 0x02u)
N
N    /* CySysLvdGetInterruptSource()/ CySysLvdClearInterrupt()  - parameter definitions  */
N    #define CY_SYS_LVD_INT                          (( uint32 ) 0x02u)
N#endif  /* (CY_PSOC4A) */
N
N/* CyDelay()/CyDelayFreq()  - implementation definitions */
N#define CY_DELAY_MS_OVERFLOW                    (0x8000u)
N#define CY_DELAY_1M_THRESHOLD                   (1000000u)
N#define CY_DELAY_1M_MINUS_1_THRESHOLD           (999999u)
N#define CY_DELAY_1K_THRESHOLD                   (1000u)
N#define CY_DELAY_1K_MINUS_1_THRESHOLD           (999u)
N
N    
N/***************************************
N* Registers
N***************************************/
N
N
N/*******************************************************************************
N* Clocks API Registers
N*******************************************************************************/
N#define CY_SYS_CLK_IMO_TRIM1_REG            (*(reg32 *) CYREG_CLK_IMO_TRIM1)
N#define CY_SYS_CLK_IMO_TRIM1_PTR            ( (reg32 *) CYREG_CLK_IMO_TRIM1)
N
N#define CY_SYS_CLK_IMO_TRIM2_REG            (*(reg32 *) CYREG_CLK_IMO_TRIM2)
N#define CY_SYS_CLK_IMO_TRIM2_PTR            ( (reg32 *) CYREG_CLK_IMO_TRIM2)
N
N#define CY_SYS_CLK_IMO_TRIM3_REG            (*(reg32 *) CYREG_CLK_IMO_TRIM3)
N#define CY_SYS_CLK_IMO_TRIM3_PTR            ( (reg32 *) CYREG_CLK_IMO_TRIM3)
N
N#define CY_SYS_CLK_IMO_CONFIG_REG           (*(reg32 *) CYREG_CLK_IMO_CONFIG)
N#define CY_SYS_CLK_IMO_CONFIG_PTR           ( (reg32 *) CYREG_CLK_IMO_CONFIG)
N
N#define CY_SYS_CLK_ILO_CONFIG_REG           (*(reg32 *) CYREG_CLK_ILO_CONFIG)
N#define CY_SYS_CLK_ILO_CONFIG_PTR           ( (reg32 *) CYREG_CLK_ILO_CONFIG)
N
N#define CY_SYS_CLK_SELECT_REG               (*(reg32 *) CYREG_CLK_SELECT)
N#define CY_SYS_CLK_SELECT_PTR               ( (reg32 *) CYREG_CLK_SELECT)
N
N#if(CY_PSOC4A)
X#if((2u == 2u))
N    #define CY_SYS_CLK_ILO_TRIM_REG             (*(reg32 *) CYREG_CLK_ILO_TRIM)
N    #define CY_SYS_CLK_ILO_TRIM_PTR             ( (reg32 *) CYREG_CLK_ILO_TRIM)
N
N    #define CY_SFLASH_IMO_TRIM_REG(number)      ( ((reg8 *) CYREG_SFLASH_IMO_TRIM00)[number])
N    #define CY_SFLASH_IMO_TRIM_PTR(number)      (&((reg8 *) CYREG_SFLASH_IMO_TRIM00)[number])
N
N    #define CY_SFLASH_IMO_MAXF0_REG             (*(reg8 *) CYREG_SFLASH_IMO_MAXF0)
N    #define CY_SFLASH_IMO_MAXF0_PTR             ( (reg8 *) CYREG_SFLASH_IMO_MAXF0)
N
N    #define CY_SFLASH_IMO_ABS0_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS0)
N    #define CY_SFLASH_IMO_ABS0_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS0)
N
N    #define CY_SFLASH_IMO_TMPCO0_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO0)
N    #define CY_SFLASH_IMO_TMPCO0_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO0)
N
N    #define CY_SFLASH_IMO_MAXF1_REG             (*(reg8 *) CYREG_SFLASH_IMO_MAXF1)
N    #define CY_SFLASH_IMO_MAXF1_PTR             ( (reg8 *) CYREG_SFLASH_IMO_MAXF1)
N
N    #define CY_SFLASH_IMO_ABS1_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS1)
N    #define CY_SFLASH_IMO_ABS1_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS1)
N
N    #define CY_SFLASH_IMO_TMPCO1_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO1)
N    #define CY_SFLASH_IMO_TMPCO1_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO1)
N
N    #define CY_SFLASH_IMO_MAXF2_REG             (*(reg8 *) CYREG_SFLASH_IMO_MAXF2)
N    #define CY_SFLASH_IMO_MAXF2_PTR             ( (reg8 *) CYREG_SFLASH_IMO_MAXF2)
N
N    #define CY_SFLASH_IMO_ABS2_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS2)
N    #define CY_SFLASH_IMO_ABS2_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS2)
N
N    #define CY_SFLASH_IMO_TMPCO2_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO2)
N    #define CY_SFLASH_IMO_TMPCO2_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO2)
N
N    #define CY_SFLASH_IMO_MAXF3_REG             (*(reg8 *) CYREG_SFLASH_IMO_MAXF3)
N    #define CY_SFLASH_IMO_MAXF3_PTR             ( (reg8 *) CYREG_SFLASH_IMO_MAXF3)
N
N    #define CY_SFLASH_IMO_ABS3_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS3)
N    #define CY_SFLASH_IMO_ABS3_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS3)
N
N    #define CY_SFLASH_IMO_TMPCO3_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO3)
N    #define CY_SFLASH_IMO_TMPCO3_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO3)
N
N    #define CY_SFLASH_IMO_ABS4_REG              (*(reg8 *) CYREG_SFLASH_IMO_ABS4)
N    #define CY_SFLASH_IMO_ABS4_PTR              ( (reg8 *) CYREG_SFLASH_IMO_ABS4)
N
N    #define CY_SFLASH_IMO_TMPCO4_REG            (*(reg8 *) CYREG_SFLASH_IMO_TMPCO4)
N    #define CY_SFLASH_IMO_TMPCO4_PTR            ( (reg8 *) CYREG_SFLASH_IMO_TMPCO4)
N
N    #define CY_PWR_BG_TRIM4_REG                 (*(reg32 *) CYREG_PWR_BG_TRIM4)
N    #define CY_PWR_BG_TRIM4_PTR                 ( (reg32 *) CYREG_PWR_BG_TRIM4)
N
N    #define CY_PWR_BG_TRIM5_REG                 (*(reg32 *) CYREG_PWR_BG_TRIM5)
N    #define CY_PWR_BG_TRIM5_PTR                 ( (reg32 *) CYREG_PWR_BG_TRIM5)
N#else
S    #define CY_SYS_CLK_IMO_SELECT_REG           (*(reg32 *) CYREG_CLK_IMO_SELECT)
S    #define CY_SYS_CLK_IMO_SELECT_PTR           ( (reg32 *) CYREG_CLK_IMO_SELECT)
S
S    #define CY_SFLASH_IMO_TCTRIM_REG(number)    ( ((reg8 *) CYREG_SFLASH_IMO_TCTRIM_LT00)[number])
S    #define CY_SFLASH_IMO_TCTRIM_PTR(number)    (&((reg8 *) CYREG_SFLASH_IMO_TCTRIM_LT00)[number])
S
S    #define CY_SFLASH_IMO_TRIM_REG(number)      ( ((reg8 *) CYREG_SFLASH_IMO_TRIM_LT00)[number])
S    #define CY_SFLASH_IMO_TRIM_PTR(number)      (&((reg8 *) CYREG_SFLASH_IMO_TRIM_LT00)[number])
N#endif  /* (CY_PSOC4A) */
N
N/*******************************************************************************
N* WDT API Registers
N*******************************************************************************/
N#if(CY_PSOC4A)
X#if((2u == 2u))
N    #define CY_SYS_WDT_CTRLOW_REG               (*(reg32 *) CYREG_WDT_CTRLOW)
N    #define CY_SYS_WDT_CTRLOW_PTR               ( (reg32 *) CYREG_WDT_CTRLOW)
N
N    #define CY_SYS_WDT_CTRHIGH_REG              (*(reg32 *) CYREG_WDT_CTRHIGH)
N    #define CY_SYS_WDT_CTRHIGH_PTR              ( (reg32 *) CYREG_WDT_CTRHIGH)
N
N    #define CY_SYS_WDT_MATCH_REG                (*(reg32 *) CYREG_WDT_MATCH)
N    #define CY_SYS_WDT_MATCH_PTR                ( (reg32 *) CYREG_WDT_MATCH)
N
N    #define CY_SYS_WDT_CONFIG_REG               (*(reg32 *) CYREG_WDT_CONFIG)
N    #define CY_SYS_WDT_CONFIG_PTR               ( (reg32 *) CYREG_WDT_CONFIG)
N
N    #define CY_SYS_WDT_CONTROL_REG              (*(reg32 *) CYREG_WDT_CONTROL)
N    #define CY_SYS_WDT_CONTROL_PTR              ( (reg32 *) CYREG_WDT_CONTROL)
N#else
S    #define CY_SYS_WDT_DISABLE_KEY_REG          (*(reg32 *) CYREG_WDT_DISABLE_KEY)
S    #define CY_SYS_WDT_DISABLE_KEY_PTR          ( (reg32 *) CYREG_WDT_DISABLE_KEY)
S    
S    #define CY_SYS_WDT_MATCH_REG                (*(reg32 *) CYREG_WDT_MATCH)
S    #define CY_SYS_WDT_MATCH_PTR                ( (reg32 *) CYREG_WDT_MATCH)
S    
S    #define CY_SYS_WDT_COUNTER_REG              (*(reg16 *) CYREG_WDT_COUNTER)
S    #define CY_SYS_WDT_COUNTER_PTR              ( (reg16 *) CYREG_WDT_COUNTER)
S    
S    #define CY_SYS_SRSS_INTR_REG                (*(reg32 *) CYREG_SRSS_INTR)
S    #define CY_SYS_SRSS_INTR_PTR                ( (reg32 *) CYREG_SRSS_INTR)
S    
S    #define CY_SYS_SRSS_INTR_MASK_REG           (*(reg32 *) CYREG_SRSS_INTR_MASK)
S    #define CY_SYS_SRSS_INTR_MASK_PTR           ( (reg32 *) CYREG_SRSS_INTR_MASK)
N#endif  /* (CY_PSOC4A) */
N
N/*******************************************************************************
N* System API Registers
N*******************************************************************************/
N#define CY_SYS_CM0_AIRCR_REG                (*(reg32 *) CYREG_CM0_AIRCR)
N#define CY_SYS_CM0_AIRCR_PTR                ( (reg32 *) CYREG_CM0_AIRCR)
N
N
N#if(CY_PSOC4A)
X#if((2u == 2u))
N    /*******************************************************************************
N    * Low Voltage Detection
N    *******************************************************************************/
N
N    /* Voltage Monitoring Trim and Configuration */
N    #define CY_LVD_PWR_VMON_CONFIG_REG          (*(reg32 *) CYREG_PWR_VMON_CONFIG)
N    #define CY_LVD_PWR_VMON_CONFIG_PTR          ( (reg32 *) CYREG_PWR_VMON_CONFIG)
N
N    /* Power System Interrupt Mask Register */
N    #define CY_LVD_PWR_INTR_MASK_REG            (*(reg32 *) CYREG_PWR_INTR_MASK)
N    #define CY_LVD_PWR_INTR_MASK_PTR            ( (reg32 *) CYREG_PWR_INTR_MASK)
N
N    /* Power System Interrupt Register */
N    #define CY_LVD_PWR_INTR_REG                 (*(reg32 *) CYREG_PWR_INTR)
N    #define CY_LVD_PWR_INTR_PTR                 ( (reg32 *) CYREG_PWR_INTR)
N#endif  /* (CY_PSOC4A) */
N    
N
N/*******************************************************************************
N* Interrupt API Registers
N*******************************************************************************/
N#define CY_INT_VECT_TABLE                   ( (cyisraddress **) CYDEV_SRAM_BASE)
N
N#define CY_INT_PRIORITY_REG(number)         ( ((reg32 *) CYREG_CM0_IPR0)[(number)/4u])
N#define CY_INT_PRIORITY_PTR(number)         (&((reg32 *) CYREG_CM0_IPR0)[(number)/4u])
N
N#define CY_INT_ENABLE_REG                   (*(reg32 *) CYREG_CM0_ISER)
N#define CY_INT_ENABLE_PTR                   ( (reg32 *) CYREG_CM0_ISER)
N
N#define CY_INT_CLEAR_REG                    (*(reg32 *) CYREG_CM0_ICER)
N#define CY_INT_CLEAR_PTR                    ( (reg32 *) CYREG_CM0_ICER)
N
N#define CY_INT_SET_PEND_REG                 (*(reg32 *) CYREG_CM0_ISPR)
N#define CY_INT_SET_PEND_PTR                 ( (reg32 *) CYREG_CM0_ISPR)
N
N#define CY_INT_CLR_PEND_REG                 (*(reg32 *) CYREG_CM0_ICPR)
N#define CY_INT_CLR_PEND_PTR                 ( (reg32 *) CYREG_CM0_ICPR)
N
N
N/*******************************************************************************
N* Following code are OBSOLETE and must not be used
N*******************************************************************************/
N#define CYINT_IRQ_BASE                     (CY_INT_IRQ_BASE)
N
N#endif  /* CY_BOOT_CYLIB_H */
N
N
N/* [] END OF FILE */
L 24 ".\Generated_Source\PSoC4\UART_1.h" 2
N
N
N/***************************************
N*  Conditional Compilation Parameters
N****************************************/
N
N#define UART_1_SCB_MODE                     (4u)
N
N/* SCB modes enum */
N#define UART_1_SCB_MODE_I2C                 (0x01u)
N#define UART_1_SCB_MODE_SPI                 (0x02u)
N#define UART_1_SCB_MODE_UART                (0x04u)
N#define UART_1_SCB_MODE_EZI2C               (0x08u)
N#define UART_1_SCB_MODE_UNCONFIG            (0xFFu)
N
N/* Define run time operation mode */
N#define UART_1_SCB_MODE_I2C_RUNTM_CFG       (UART_1_SCB_MODE_I2C       == UART_1_scbMode)
N#define UART_1_SCB_MODE_SPI_RUNTM_CFG       (UART_1_SCB_MODE_SPI       == UART_1_scbMode)
N#define UART_1_SCB_MODE_UART_RUNTM_CFG      (UART_1_SCB_MODE_UART      == UART_1_scbMode)
N#define UART_1_SCB_MODE_EZI2C_RUNTM_CFG     (UART_1_SCB_MODE_EZI2C     == UART_1_scbMode)
N#define UART_1_SCB_MODE_UNCONFIG_RUNTM_CFG  (UART_1_SCB_MODE_UNCONFIG  == UART_1_scbMode)
N
N/* Condition compilation depends on operation mode: unconfigured implies apply to all modes */
N#define UART_1_SCB_MODE_I2C_CONST_CFG       (UART_1_SCB_MODE_I2C       == UART_1_SCB_MODE)
N#define UART_1_SCB_MODE_SPI_CONST_CFG       (UART_1_SCB_MODE_SPI       == UART_1_SCB_MODE)
N#define UART_1_SCB_MODE_UART_CONST_CFG      (UART_1_SCB_MODE_UART      == UART_1_SCB_MODE)
N#define UART_1_SCB_MODE_EZI2C_CONST_CFG     (UART_1_SCB_MODE_EZI2C     == UART_1_SCB_MODE)
N#define UART_1_SCB_MODE_UNCONFIG_CONST_CFG  (UART_1_SCB_MODE_UNCONFIG  == UART_1_SCB_MODE)
N
N/* Condition compilation for includes */
N#define UART_1_SCB_MODE_I2C_INC       (0u !=(UART_1_SCB_MODE_I2C       & UART_1_SCB_MODE))
N#define UART_1_SCB_MODE_SPI_INC       (0u !=(UART_1_SCB_MODE_SPI       & UART_1_SCB_MODE))
N#define UART_1_SCB_MODE_UART_INC      (0u !=(UART_1_SCB_MODE_UART      & UART_1_SCB_MODE))
N#define UART_1_SCB_MODE_EZI2C_INC     (0u !=(UART_1_SCB_MODE_EZI2C     & UART_1_SCB_MODE))
N
N/* Interrupts remove options */
N#define UART_1_REMOVE_SCB_IRQ             (1u)
N#define UART_1_SCB_IRQ_INTERNAL           (0u == UART_1_REMOVE_SCB_IRQ)
N
N#define UART_1_REMOVE_UART_RX_WAKEUP_IRQ  (1u)
N#define UART_1_UART_RX_WAKEUP_IRQ         (0u == UART_1_REMOVE_UART_RX_WAKEUP_IRQ)
N
N/* SCB interrupt enum */
N#define UART_1_SCB_INTR_MODE_NONE     (0u)
N#define UART_1_SCB_INTR_MODE_INTERNAL (1u)
N#define UART_1_SCB_INTR_MODE_EXTERNAL (2u)
N
N/* Bootloader communication interface enable */
N#define UART_1_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) || \
N                                             (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
X#define UART_1_BTLDR_COMM_ENABLED ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) ||                                              (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
N
N
N/***************************************
N*       Includes
N****************************************/
N
N#include "UART_1_PINS.h"
L 1 ".\Generated_Source\PSoC4\UART_1_PINS.h" 1
N/*******************************************************************************
N* File Name: UART_1_PINS.h
N* Version 1.10
N*
N* Description:
N*  This file provides constants and parameter values for the pin components
N*  buried into SCB Component.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2013, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_PINS_UART_1_H)
X#if !0L
N#define CY_SCB_PINS_UART_1_H
N
N#include "cydevice_trm.h"
N#include "cyfitter.h"
N#include "cytypes.h"
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N/* Unconfigured pins */
N#define UART_1_REMOVE_MOSI_SCL_RX_WAKE_PIN    (1u)
N#define UART_1_REMOVE_MOSI_SCL_RX_PIN         (1u)
N#define UART_1_REMOVE_MISO_SDA_TX_PIN         (1u)
N#define UART_1_REMOVE_SCLK_PIN                (1u)
N#define UART_1_REMOVE_SS0_PIN                 (1u)
N#define UART_1_REMOVE_SS1_PIN                 (1u)
N#define UART_1_REMOVE_SS2_PIN                 (1u)
N#define UART_1_REMOVE_SS3_PIN                 (1u)
N
N/* Mode defined pins */
N#define UART_1_REMOVE_I2C_PINS                (1u)
N#define UART_1_REMOVE_SPI_MASTER_PINS         (1u)
N#define UART_1_REMOVE_SPI_SLAVE_PINS          (1u)
N#define UART_1_REMOVE_SPI_MASTER_SS0_PIN      (1u)
N#define UART_1_REMOVE_SPI_MASTER_SS1_PIN      (1u)
N#define UART_1_REMOVE_SPI_MASTER_SS2_PIN      (1u)
N#define UART_1_REMOVE_SPI_MASTER_SS3_PIN      (1u)
N#define UART_1_REMOVE_UART_TX_PIN             (0u)
N#define UART_1_REMOVE_UART_RX_TX_PIN          (1u)
N#define UART_1_REMOVE_UART_RX_PIN             (0u)
N#define UART_1_REMOVE_UART_RX_WAKE_PIN        (1u)
N
N/* Unconfigured pins */
N#define UART_1_MOSI_SCL_RX_WAKE_PIN   (0u == UART_1_REMOVE_MOSI_SCL_RX_WAKE_PIN)
N#define UART_1_MOSI_SCL_RX_PIN        (0u == UART_1_REMOVE_MOSI_SCL_RX_PIN)
N#define UART_1_MISO_SDA_TX_PIN        (0u == UART_1_REMOVE_MISO_SDA_TX_PIN)
N#define UART_1_SCLK_PIN               (0u == UART_1_REMOVE_SCLK_PIN)
N#define UART_1_SS0_PIN                (0u == UART_1_REMOVE_SS0_PIN)
N#define UART_1_SS1_PIN                (0u == UART_1_REMOVE_SS1_PIN)
N#define UART_1_SS2_PIN                (0u == UART_1_REMOVE_SS2_PIN)
N#define UART_1_SS3_PIN                (0u == UART_1_REMOVE_SS3_PIN)
N
N/* Mode defined pins */
N#define UART_1_I2C_PINS               (0u == UART_1_REMOVE_I2C_PINS)
N#define UART_1_SPI_MASTER_PINS        (0u == UART_1_REMOVE_SPI_MASTER_PINS) 
N#define UART_1_SPI_SLAVE_PINS         (0u == UART_1_REMOVE_SPI_SLAVE_PINS)
N#define UART_1_SPI_MASTER_SS0_PIN     (0u == UART_1_REMOVE_SPI_MASTER_SS0_PIN)
N#define UART_1_SPI_MASTER_SS1_PIN     (0u == UART_1_REMOVE_SPI_MASTER_SS1_PIN)
N#define UART_1_SPI_MASTER_SS2_PIN     (0u == UART_1_REMOVE_SPI_MASTER_SS2_PIN)
N#define UART_1_SPI_MASTER_SS3_PIN     (0u == UART_1_REMOVE_SPI_MASTER_SS3_PIN)
N#define UART_1_UART_TX_PIN            (0u == UART_1_REMOVE_UART_TX_PIN)
N#define UART_1_UART_RX_TX_PIN         (0u == UART_1_REMOVE_UART_RX_TX_PIN)
N#define UART_1_UART_RX_PIN            (0u == UART_1_REMOVE_UART_RX_PIN)
N#define UART_1_UART_RX_WAKE_PIN       (0u == UART_1_REMOVE_UART_RX_WAKE_PIN)
N
N
N/***************************************
N*             Includes
N****************************************/
N
N#if(UART_1_MOSI_SCL_RX_WAKE_PIN)
X#if((0u == (1u)))
S    #include "UART_1_spi_mosi_i2c_scl_uart_rx_wake.h"
N#endif /* (UART_1_MOSI_SCL_RX_WAKE_PIN) */
N
N#if(UART_1_MOSI_SCL_RX_PIN)
X#if((0u == (1u)))
S    #include "UART_1_spi_mosi_i2c_scl_uart_rx.h"
N#endif /* (UART_1_MOSI_SCL_RX_PIN) */
N
N#if(UART_1_MISO_SDA_TX_PIN)
X#if((0u == (1u)))
S    #include "UART_1_spi_miso_i2c_sda_uart_tx.h"
N#endif /* (UART_1_MISO_SDA_TX_PIN_PIN) */
N
N#if(UART_1_SCLK_PIN)
X#if((0u == (1u)))
S    #include "UART_1_spi_sclk.h"
N#endif /* (UART_1_SCLK_PIN) */
N
N#if(UART_1_SS0_PIN)
X#if((0u == (1u)))
S    #include "UART_1_spi_ss0.h"
N#endif /* (UART_1_SS1_PIN) */
N
N#if(UART_1_SS1_PIN)
X#if((0u == (1u)))
S    #include "UART_1_spi_ss1.h"
N#endif /* (UART_1_SS1_PIN) */
N
N#if(UART_1_SS2_PIN)
X#if((0u == (1u)))
S    #include "UART_1_spi_ss2.h"
N#endif /* (UART_1_SS2_PIN) */
N
N#if(UART_1_SS3_PIN)
X#if((0u == (1u)))
S    #include "UART_1_spi_ss3.h"
N#endif /* (UART_1_SS3_PIN) */
N
N#if(UART_1_I2C_PINS)
X#if((0u == (1u)))
S    #include "UART_1_scl.h"
S    #include "UART_1_sda.h"
N#endif /* (UART_1_I2C_PINS) */
N    
N#if(UART_1_SPI_MASTER_PINS)
X#if((0u == (1u)))
S    #include "UART_1_sclk_m.h"
S    #include "UART_1_mosi_m.h"
S    #include "UART_1_miso_m.h"
N#endif /* (UART_1_SPI_MASTER_PINS) */
N
N#if(UART_1_SPI_SLAVE_PINS)
X#if((0u == (1u)))
S    #include "UART_1_sclk_s.h"
S    #include "UART_1_mosi_s.h"
S    #include "UART_1_miso_s.h"
S    #include "UART_1_ss_s.h"
N#endif /* (UART_1_SPI_SLAVE_PINS) */
N
N#if(UART_1_SPI_MASTER_SS0_PIN)
X#if((0u == (1u)))
S    #include "UART_1_ss0_m.h"
N#endif /* (UART_1_SPI_MASTER_SS0_PIN) */
N
N#if(UART_1_SPI_MASTER_SS1_PIN)
X#if((0u == (1u)))
S    #include "UART_1_ss1_m.h"
N#endif /* (UART_1_SPI_MASTER_SS1_PIN) */
N
N#if(UART_1_SPI_MASTER_SS2_PIN)
X#if((0u == (1u)))
S    #include "UART_1_ss2_m.h"
N#endif /* (UART_1_SPI_MASTER_SS2_PIN) */
N
N#if(UART_1_SPI_MASTER_SS3_PIN)
X#if((0u == (1u)))
S    #include "UART_1_ss3_m.h"
N#endif /* (UART_1_SPI_MASTER_SS3_PIN) */
N
N#if(UART_1_UART_TX_PIN)
X#if((0u == (0u)))
N    #include "UART_1_tx.h"
L 1 ".\Generated_Source\PSoC4\UART_1_tx.h" 1
N/*******************************************************************************
N* File Name: UART_1_tx.h  
N* Version 1.90
N*
N* Description:
N*  This file containts Control Register function prototypes and register defines
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_tx_H) /* Pins UART_1_tx_H */
X#if !0L  
N#define CY_PINS_UART_1_tx_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "UART_1_tx_aliases.h"
L 1 ".\Generated_Source\PSoC4\UART_1_tx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_1_tx.h  
N* Version 1.90
N*
N* Description:
N*  This file containts Control Register function prototypes and register defines
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_tx_ALIASES_H) /* Pins UART_1_tx_ALIASES_H */
X#if !0L  
N#define CY_PINS_UART_1_tx_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define UART_1_tx_0		UART_1_tx__0__PC
N
N#endif /* End Pins UART_1_tx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 23 ".\Generated_Source\PSoC4\UART_1_tx.h" 2
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/    
N
Nvoid    UART_1_tx_Write(uint8 value) ;
Nvoid    UART_1_tx_SetDriveMode(uint8 mode) ;
Nuint8   UART_1_tx_ReadDataReg(void) ;
Nuint8   UART_1_tx_Read(void) ;
Nuint8   UART_1_tx_ClearInterrupt(void) ;
N
N
N/***************************************
N*           API Constants        
N***************************************/
N
N/* Drive Modes */
N#define UART_1_tx_DRIVE_MODE_BITS        (3)
N#define UART_1_tx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_1_tx_DRIVE_MODE_BITS))
N#define UART_1_tx_DRIVE_MODE_SHIFT       (0x00u)
N#define UART_1_tx_DRIVE_MODE_MASK        (0x07u << UART_1_tx_DRIVE_MODE_SHIFT)
N
N#define UART_1_tx_DM_ALG_HIZ         (0x00u << UART_1_tx_DRIVE_MODE_SHIFT)
N#define UART_1_tx_DM_DIG_HIZ         (0x01u << UART_1_tx_DRIVE_MODE_SHIFT)
N#define UART_1_tx_DM_RES_UP          (0x02u << UART_1_tx_DRIVE_MODE_SHIFT)
N#define UART_1_tx_DM_RES_DWN         (0x03u << UART_1_tx_DRIVE_MODE_SHIFT)
N#define UART_1_tx_DM_OD_LO           (0x04u << UART_1_tx_DRIVE_MODE_SHIFT)
N#define UART_1_tx_DM_OD_HI           (0x05u << UART_1_tx_DRIVE_MODE_SHIFT)
N#define UART_1_tx_DM_STRONG          (0x06u << UART_1_tx_DRIVE_MODE_SHIFT)
N#define UART_1_tx_DM_RES_UPDWN       (0x07u << UART_1_tx_DRIVE_MODE_SHIFT)
N
N/* Digital Port Constants */
N#define UART_1_tx_MASK               UART_1_tx__MASK
N#define UART_1_tx_SHIFT              UART_1_tx__SHIFT
N#define UART_1_tx_WIDTH              1u
N
N
N/***************************************
N*             Registers        
N***************************************/
N
N/* Main Port Registers */
N/* Pin State */
N#define UART_1_tx_PS                     (* (reg32 *) UART_1_tx__PS)
N/* Port Configuration */
N#define UART_1_tx_PC                     (* (reg32 *) UART_1_tx__PC)
N/* Data Register */
N#define UART_1_tx_DR                     (* (reg32 *) UART_1_tx__DR)
N/* Input Buffer Disable Override */
N#define UART_1_tx_INP_DIS                (* (reg32 *) UART_1_tx__PC2)
N
N
N#if defined(UART_1_tx__INTSTAT)  /* Interrupt Registers */
X#if 1L   
N
N    #define UART_1_tx_INTSTAT                (* (reg32 *) UART_1_tx__INTSTAT)
N
N#endif /* Interrupt Registers */
N
N#endif /* End Pins UART_1_tx_H */
N
N
N/* [] END OF FILE */
L 149 ".\Generated_Source\PSoC4\UART_1_PINS.h" 2
N#endif /* (UART_1_UART_TX_PIN) */
N
N#if(UART_1_UART_RX_TX_PIN)
X#if((0u == (1u)))
S    #include "UART_1_rx_tx.h"
N#endif /* (UART_1_UART_RX_TX_PIN) */
N
N#if(UART_1_UART_RX_PIN)
X#if((0u == (0u)))
N    #include "UART_1_rx.h"
L 1 ".\Generated_Source\PSoC4\UART_1_rx.h" 1
N/*******************************************************************************
N* File Name: UART_1_rx.h  
N* Version 1.90
N*
N* Description:
N*  This file containts Control Register function prototypes and register defines
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_rx_H) /* Pins UART_1_rx_H */
X#if !0L  
N#define CY_PINS_UART_1_rx_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N#include "UART_1_rx_aliases.h"
L 1 ".\Generated_Source\PSoC4\UART_1_rx_aliases.h" 1
N/*******************************************************************************
N* File Name: UART_1_rx.h  
N* Version 1.90
N*
N* Description:
N*  This file containts Control Register function prototypes and register defines
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2008-2012, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions, 
N* disclaimers, and limitations in the end user license agreement accompanying 
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_PINS_UART_1_rx_ALIASES_H) /* Pins UART_1_rx_ALIASES_H */
X#if !0L  
N#define CY_PINS_UART_1_rx_ALIASES_H
N
N#include "cytypes.h"
N#include "cyfitter.h"
N
N
N/***************************************
N*              Constants        
N***************************************/
N#define UART_1_rx_0		UART_1_rx__0__PC
N
N#endif /* End Pins UART_1_rx_ALIASES_H */
N
N
N/* [] END OF FILE */
L 23 ".\Generated_Source\PSoC4\UART_1_rx.h" 2
N
N
N/***************************************
N*        Function Prototypes             
N***************************************/    
N
Nvoid    UART_1_rx_Write(uint8 value) ;
Nvoid    UART_1_rx_SetDriveMode(uint8 mode) ;
Nuint8   UART_1_rx_ReadDataReg(void) ;
Nuint8   UART_1_rx_Read(void) ;
Nuint8   UART_1_rx_ClearInterrupt(void) ;
N
N
N/***************************************
N*           API Constants        
N***************************************/
N
N/* Drive Modes */
N#define UART_1_rx_DRIVE_MODE_BITS        (3)
N#define UART_1_rx_DRIVE_MODE_IND_MASK    (0xFFFFFFFFu >> (32 - UART_1_rx_DRIVE_MODE_BITS))
N#define UART_1_rx_DRIVE_MODE_SHIFT       (0x00u)
N#define UART_1_rx_DRIVE_MODE_MASK        (0x07u << UART_1_rx_DRIVE_MODE_SHIFT)
N
N#define UART_1_rx_DM_ALG_HIZ         (0x00u << UART_1_rx_DRIVE_MODE_SHIFT)
N#define UART_1_rx_DM_DIG_HIZ         (0x01u << UART_1_rx_DRIVE_MODE_SHIFT)
N#define UART_1_rx_DM_RES_UP          (0x02u << UART_1_rx_DRIVE_MODE_SHIFT)
N#define UART_1_rx_DM_RES_DWN         (0x03u << UART_1_rx_DRIVE_MODE_SHIFT)
N#define UART_1_rx_DM_OD_LO           (0x04u << UART_1_rx_DRIVE_MODE_SHIFT)
N#define UART_1_rx_DM_OD_HI           (0x05u << UART_1_rx_DRIVE_MODE_SHIFT)
N#define UART_1_rx_DM_STRONG          (0x06u << UART_1_rx_DRIVE_MODE_SHIFT)
N#define UART_1_rx_DM_RES_UPDWN       (0x07u << UART_1_rx_DRIVE_MODE_SHIFT)
N
N/* Digital Port Constants */
N#define UART_1_rx_MASK               UART_1_rx__MASK
N#define UART_1_rx_SHIFT              UART_1_rx__SHIFT
N#define UART_1_rx_WIDTH              1u
N
N
N/***************************************
N*             Registers        
N***************************************/
N
N/* Main Port Registers */
N/* Pin State */
N#define UART_1_rx_PS                     (* (reg32 *) UART_1_rx__PS)
N/* Port Configuration */
N#define UART_1_rx_PC                     (* (reg32 *) UART_1_rx__PC)
N/* Data Register */
N#define UART_1_rx_DR                     (* (reg32 *) UART_1_rx__DR)
N/* Input Buffer Disable Override */
N#define UART_1_rx_INP_DIS                (* (reg32 *) UART_1_rx__PC2)
N
N
N#if defined(UART_1_rx__INTSTAT)  /* Interrupt Registers */
X#if 1L   
N
N    #define UART_1_rx_INTSTAT                (* (reg32 *) UART_1_rx__INTSTAT)
N
N#endif /* Interrupt Registers */
N
N#endif /* End Pins UART_1_rx_H */
N
N
N/* [] END OF FILE */
L 157 ".\Generated_Source\PSoC4\UART_1_PINS.h" 2
N#endif /* (UART_1_UART_RX_PIN) */
N
N#if(UART_1_UART_RX_WAKE_PIN)
X#if((0u == (1u)))
S    #include "UART_1_rx_wake.h"
N#endif /* (UART_1_UART_RX_WAKE_PIN) */
N
N
N/***************************************
N*              Registers
N***************************************/
N
N#if(UART_1_MOSI_SCL_RX_WAKE_PIN)
X#if((0u == (1u)))
S    #define UART_1_MOSI_SCL_RX_WAKE_HSIOM_REG  \
S                                                (*(reg32 *) UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__HSIOM)
X    #define UART_1_MOSI_SCL_RX_WAKE_HSIOM_REG                                                  (*(reg32 *) UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__HSIOM)
S    #define UART_1_MOSI_SCL_RX_WAKE_HSIOM_PTR  \
S                                                ( (reg32 *) UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__HSIOM)
X    #define UART_1_MOSI_SCL_RX_WAKE_HSIOM_PTR                                                  ( (reg32 *) UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__HSIOM)
S    #define UART_1_MOSI_SCL_RX_WAKE_HSIOM_MASK \
S                                                (UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__HSIOM_MASK)
X    #define UART_1_MOSI_SCL_RX_WAKE_HSIOM_MASK                                                 (UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__HSIOM_MASK)
S    #define UART_1_MOSI_SCL_RX_WAKE_HSIOM_POS  \
S                                                (UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__HSIOM_SHIFT)
X    #define UART_1_MOSI_SCL_RX_WAKE_HSIOM_POS                                                  (UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__HSIOM_SHIFT)
S
S    #define UART_1_MOSI_SCL_RX_WAKE_INTCFG_REG    (*(reg32 *) \
S                                                              UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__INTCFG)
X    #define UART_1_MOSI_SCL_RX_WAKE_INTCFG_REG    (*(reg32 *)                                                               UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__INTCFG)
S    #define UART_1_MOSI_SCL_RX_WAKE_INTCFG_PTR    ( (reg32 *) \
S                                                              UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__INTCFG)
X    #define UART_1_MOSI_SCL_RX_WAKE_INTCFG_PTR    ( (reg32 *)                                                               UART_1_spi_mosi_i2c_scl_uart_rx_wake__0__INTCFG)
S
S    #define UART_1_INTCFG_TYPE_MASK                  (0x03u)
S    #define UART_1_MOSI_SCL_RX_WAKE_INTCFG_TYPE_POS  (UART_1_spi_mosi_i2c_scl_uart_rx_wake__SHIFT)
S    #define UART_1_MOSI_SCL_RX_WAKE_INTCFG_TYPE_MASK ((uint32)                                           \
S                                                                    ((uint32) UART_1_INTCFG_TYPE_MASK << \
S                                                                    UART_1_MOSI_SCL_RX_WAKE_INTCFG_TYPE_POS))
X    #define UART_1_MOSI_SCL_RX_WAKE_INTCFG_TYPE_MASK ((uint32)                                                                                                               ((uint32) UART_1_INTCFG_TYPE_MASK <<                                                                     UART_1_MOSI_SCL_RX_WAKE_INTCFG_TYPE_POS))
N#endif /* (UART_1_MOSI_SCL_RX_WAKE_PIN) */
N
N#if(UART_1_MOSI_SCL_RX_PIN)
X#if((0u == (1u)))
S    #define UART_1_MOSI_SCL_RX_HSIOM_REG      (*(reg32 *) UART_1_spi_mosi_i2c_scl_uart_rx__0__HSIOM)
S    #define UART_1_MOSI_SCL_RX_HSIOM_PTR      ( (reg32 *) UART_1_spi_mosi_i2c_scl_uart_rx__0__HSIOM)
S    #define UART_1_MOSI_SCL_RX_HSIOM_MASK     (UART_1_spi_mosi_i2c_scl_uart_rx__0__HSIOM_MASK)
S    #define UART_1_MOSI_SCL_RX_HSIOM_POS      (UART_1_spi_mosi_i2c_scl_uart_rx__0__HSIOM_SHIFT)
N#endif /* (UART_1_MOSI_SCL_RX_PIN) */
N
N#if(UART_1_MISO_SDA_TX_PIN)
X#if((0u == (1u)))
S    #define UART_1_MISO_SDA_TX_HSIOM_REG      (*(reg32 *) UART_1_spi_miso_i2c_sda_uart_tx__0__HSIOM)
S    #define UART_1_MISO_SDA_TX_HSIOM_PTR      ( (reg32 *) UART_1_spi_miso_i2c_sda_uart_tx__0__HSIOM)
S    #define UART_1_MISO_SDA_TX_HSIOM_MASK     (UART_1_spi_miso_i2c_sda_uart_tx__0__HSIOM_MASK)
S    #define UART_1_MISO_SDA_TX_HSIOM_POS      (UART_1_spi_miso_i2c_sda_uart_tx__0__HSIOM_SHIFT)
N#endif /* (UART_1_MISO_SDA_TX_PIN_PIN) */
N
N#if(UART_1_SCLK_PIN)
X#if((0u == (1u)))
S    #define UART_1_SCLK_HSIOM_REG     (*(reg32 *) UART_1_spi_sclk__0__HSIOM)
S    #define UART_1_SCLK_HSIOM_PTR     ( (reg32 *) UART_1_spi_sclk__0__HSIOM)
S    #define UART_1_SCLK_HSIOM_MASK    (UART_1_spi_sclk__0__HSIOM_MASK)
S    #define UART_1_SCLK_HSIOM_POS     (UART_1_spi_sclk__0__HSIOM_SHIFT)
N#endif /* (UART_1_SCLK_PIN) */
N
N#if(UART_1_SS0_PIN)
X#if((0u == (1u)))
S    #define UART_1_SS0_HSIOM_REG      (*(reg32 *) UART_1_spi_ss0__0__HSIOM)
S    #define UART_1_SS0_HSIOM_PTR      ( (reg32 *) UART_1_spi_ss0__0__HSIOM)
S    #define UART_1_SS0_HSIOM_MASK     (UART_1_spi_ss0__0__HSIOM_MASK)
S    #define UART_1_SS0_HSIOM_POS      (UART_1_spi_ss0__0__HSIOM_SHIFT)
N#endif /* (UART_1_SS1_PIN) */
N
N#if(UART_1_SS1_PIN)
X#if((0u == (1u)))
S    #define UART_1_SS1_HSIOM_REG      (*(reg32 *) UART_1_spi_ss1__0__HSIOM)
S    #define UART_1_SS1_HSIOM_PTR      ( (reg32 *) UART_1_spi_ss1__0__HSIOM)
S    #define UART_1_SS1_HSIOM_MASK     (UART_1_spi_ss1__0__HSIOM_MASK)
S    #define UART_1_SS1_HSIOM_POS      (UART_1_spi_ss1__0__HSIOM_SHIFT)
N#endif /* (UART_1_SS1_PIN) */
N
N#if(UART_1_SS2_PIN)
X#if((0u == (1u)))
S    #define UART_1_SS2_HSIOM_REG     (*(reg32 *) UART_1_spi_ss2__0__HSIOM)
S    #define UART_1_SS2_HSIOM_PTR     ( (reg32 *) UART_1_spi_ss2__0__HSIOM)
S    #define UART_1_SS2_HSIOM_MASK    (UART_1_spi_ss2__0__HSIOM_MASK)
S    #define UART_1_SS2_HSIOM_POS     (UART_1_spi_ss2__0__HSIOM_SHIFT)
N#endif /* (UART_1_SS2_PIN) */
N
N#if(UART_1_SS3_PIN)
X#if((0u == (1u)))
S    #define UART_1_SS3_HSIOM_REG     (*(reg32 *) UART_1_spi_ss3__0__HSIOM)
S    #define UART_1_SS3_HSIOM_PTR     ( (reg32 *) UART_1_spi_ss3__0__HSIOM)
S    #define UART_1_SS3_HSIOM_MASK    (UART_1_spi_ss3__0__HSIOM_MASK)
S    #define UART_1_SS3_HSIOM_POS     (UART_1_spi_ss3__0__HSIOM_SHIFT)
N#endif /* (UART_1_SS3_PIN) */
N
N#if(UART_1_I2C_PINS)
X#if((0u == (1u)))
S    #define UART_1_SCL_HSIOM_REG     (*(reg32 *) UART_1_scl__0__HSIOM)
S    #define UART_1_SCL_HSIOM_PTR     ( (reg32 *) UART_1_scl__0__HSIOM)
S    #define UART_1_SCL_HSIOM_MASK    (UART_1_scl__0__HSIOM_MASK)
S    #define UART_1_SCL_HSIOM_POS     (UART_1_scl__0__HSIOM_SHIFT)
S
S    #define UART_1_SDA_HSIOM_REG     (*(reg32 *) UART_1_sda__0__HSIOM)
S    #define UART_1_SDA_HSIOM_PTR     ( (reg32 *) UART_1_sda__0__HSIOM)
S    #define UART_1_SDA_HSIOM_MASK    (UART_1_sda__0__HSIOM_MASK)
S    #define UART_1_SDA_HSIOM_POS     (UART_1_sda__0__HSIOM_SHIFT)
N#endif /* (UART_1_I2C_PINS) */
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* Pins constanst */
N#define UART_1_HSIOM_DEF_SEL      (0x00u)
N#define UART_1_HSIOM_GPIO_SEL     (0x00u)
N#define UART_1_HSIOM_UART_SEL     (0x09u)
N#define UART_1_HSIOM_I2C_SEL      (0x0Eu)
N#define UART_1_HSIOM_SPI_SEL      (0x0Fu)
N
N#define UART_1_SCB_PINS_NUMBER            (7u)
N#define UART_1_MOSI_SCL_RX_PIN_INDEX      (0u) /* RX pins without interrupt */
N#define UART_1_MOSI_SCL_RX_WAKE_PIN_INDEX (0u) /* RX pin with interrupt     */
N#define UART_1_MISO_SDA_TX_PIN_INDEX      (1u)
N#define UART_1_SCLK_PIN_INDEX             (2u)
N#define UART_1_SS0_PIN_INDEX              (3u)
N#define UART_1_SS1_PIN_INDEX              (4u)
N#define UART_1_SS2_PIN_INDEX              (5u)
N#define UART_1_SS3_PIN_INDEX              (6u)
N
N#define UART_1_INTCFG_TYPE_FALLING_EDGE   (0x02u)
N
N/* Pin DM defines */
N#define UART_1_PIN_DM_ALG_HIZ  (0u)
N#define UART_1_PIN_DM_DIG_HIZ  (1u)
N#define UART_1_PIN_DM_OD_LO    (4u)
N#define UART_1_PIN_DM_STRONG   (6u)
N
N
N/***************************************
N*          Macro Definitions
N***************************************/
N
N#define UART_1_SET_REGISTER_BITS(reg, mask, pos, mode) \
N                    do                                           \
N                    {                                            \
N                        /* Sets new bits-mask */                 \
N                        (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos)))); \
N                    }while(0)
X#define UART_1_SET_REGISTER_BITS(reg, mask, pos, mode)                     do                                                               {                                                                                                              (reg) = (((reg) & ((uint32) ~(uint32) (mask))) | ((uint32) ((uint32) (mode) << (pos))));                     }while(0)
N
N#define UART_1_SET_HSIOM_SEL(reg, mask, pos, sel) UART_1_SET_REGISTER_BITS(reg, mask, pos, sel)
N#define UART_1_SET_INCFG_TYPE(reg, mask, pos, intType) \
N                                                        UART_1_SET_REGISTER_BITS(reg, mask, pos, intType)
X#define UART_1_SET_INCFG_TYPE(reg, mask, pos, intType)                                                         UART_1_SET_REGISTER_BITS(reg, mask, pos, intType)
N
N
N/* UART_1_SET_I2C_SCL_DR(val) - Sets I2C SCL DR register.
N*  UART_1_SET_I2C_SCL_HSIOM_SEL(sel) - Sets I2C SCL HSIOM settings.
N*/
N/* Unconfigured SCB: scl singnal */
N#if(UART_1_MOSI_SCL_RX_WAKE_PIN)
X#if((0u == (1u)))
S    #define UART_1_SET_I2C_SCL_DR(val) \
S                            UART_1_spi_mosi_i2c_scl_uart_rx_wake_Write(val)
X    #define UART_1_SET_I2C_SCL_DR(val)                             UART_1_spi_mosi_i2c_scl_uart_rx_wake_Write(val)
S
S    #define UART_1_SET_I2C_SCL_HSIOM_SEL(sel) \
S                    UART_1_SET_HSIOM_SEL(UART_1_MOSI_SCL_RX_WAKE_HSIOM_REG,  \
S                                                   UART_1_MOSI_SCL_RX_WAKE_HSIOM_MASK, \
S                                                   UART_1_MOSI_SCL_RX_WAKE_HSIOM_POS,  \
S                                                   (sel))
X    #define UART_1_SET_I2C_SCL_HSIOM_SEL(sel)                     UART_1_SET_HSIOM_SEL(UART_1_MOSI_SCL_RX_WAKE_HSIOM_REG,                                                     UART_1_MOSI_SCL_RX_WAKE_HSIOM_MASK,                                                    UART_1_MOSI_SCL_RX_WAKE_HSIOM_POS,                                                     (sel))
S
S#elif(UART_1_MOSI_SCL_RX_PIN)
X#elif((0u == (1u)))
S    #define UART_1_SET_I2C_SCL_DR(val) \
S                            UART_1_spi_mosi_i2c_scl_uart_rx_Write(val)
X    #define UART_1_SET_I2C_SCL_DR(val)                             UART_1_spi_mosi_i2c_scl_uart_rx_Write(val)
S
S
S    #define UART_1_SET_I2C_SCL_HSIOM_SEL(sel) \
S                            UART_1_SET_HSIOM_SEL(UART_1_MOSI_SCL_RX_HSIOM_REG,  \
S                                                           UART_1_MOSI_SCL_RX_HSIOM_MASK, \
S                                                           UART_1_MOSI_SCL_RX_HSIOM_POS,  \
S                                                           (sel))
X    #define UART_1_SET_I2C_SCL_HSIOM_SEL(sel)                             UART_1_SET_HSIOM_SEL(UART_1_MOSI_SCL_RX_HSIOM_REG,                                                             UART_1_MOSI_SCL_RX_HSIOM_MASK,                                                            UART_1_MOSI_SCL_RX_HSIOM_POS,                                                             (sel))
N#else
N    #if(!UART_1_I2C_PINS)
X    #if(!(0u == (1u)))
N        #define UART_1_SET_I2C_SCL_DR(val) \
N                                                 do{ ; }while(0)
X        #define UART_1_SET_I2C_SCL_DR(val)                                                  do{ ; }while(0)
N        #define UART_1_SET_I2C_SCL_HSIOM_SEL(sel) \
N                                                        do{ ; }while(0)
X        #define UART_1_SET_I2C_SCL_HSIOM_SEL(sel)                                                         do{ ; }while(0)
N
N    #endif /* (!UART_1_I2C_PINS) */
N#endif /* (UART_1_MOSI_SCL_RX_PIN) */
N
N/* SCB I2C: scl singal */
N#if(UART_1_I2C_PINS)
X#if((0u == (1u)))
S    #define UART_1_SET_I2C_SCL_DR(val) UART_1_scl_Write(val)
S
S    #define UART_1_SET_I2C_SCL_HSIOM_SEL(sel) \
S                          UART_1_SET_HSIOM_SEL(UART_1_SCL_HSIOM_REG,  \
S                                                         UART_1_SCL_HSIOM_MASK, \
S                                                         UART_1_SCL_HSIOM_POS,  \
S                                                         (sel))
X    #define UART_1_SET_I2C_SCL_HSIOM_SEL(sel)                           UART_1_SET_HSIOM_SEL(UART_1_SCL_HSIOM_REG,                                                           UART_1_SCL_HSIOM_MASK,                                                          UART_1_SCL_HSIOM_POS,                                                           (sel))
S
N#endif /* (UART_1_I2C_PINS) */
N
N
N#endif /* (CY_SCB_PINS_UART_1_H) */
N
N
N/* [] END OF FILE */
L 81 ".\Generated_Source\PSoC4\UART_1.h" 2
N
N#if(UART_1_SCB_IRQ_INTERNAL)
X#if((0u == (1u)))
S    #include "UART_1_SCB_IRQ.h"
N#endif /* (UART_1_SCB_IRQ_INTERNAL) */
N
N#if(UART_1_UART_RX_WAKEUP_IRQ)
X#if((0u == (1u)))
S    #include "UART_1_RX_WAKEUP_IRQ.h"
N#endif /* (UART_1_UART_RX_WAKEUP_IRQ) */
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
Ntypedef struct
N{
N    uint8 enableState;
N} UART_1_BACKUP_STRUCT;
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/* Start and Stop APIs */
Nvoid UART_1_Init(void);
Nvoid UART_1_Enable(void);
Nvoid UART_1_Start(void);
Nvoid UART_1_Stop(void);
N
N/* Sleep and Wakeup APis */
Nvoid UART_1_Sleep(void);
Nvoid UART_1_Wakeup(void);
N
N/* Customer interrupt handler */
Nvoid UART_1_SetCustomInterruptHandler(cyisraddress func);
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_BTLDR_COMM_ENABLED)
X#if 0L && (((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)))
S
S    /* Bootloader Physical layer functions */
S    void UART_1_CyBtldrCommStart(void);
S    void UART_1_CyBtldrCommStop (void);
S    void UART_1_CyBtldrCommReset(void);
S    cystatus UART_1_CyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_1_CyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
S    #if(CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1)
S        #define CyBtldrCommStart    UART_1_CyBtldrCommStart
S        #define CyBtldrCommStop     UART_1_CyBtldrCommStop
S        #define CyBtldrCommReset    UART_1_CyBtldrCommReset
S        #define CyBtldrCommWrite    UART_1_CyBtldrCommWrite
S        #define CyBtldrCommRead     UART_1_CyBtldrCommRead
S    #endif /* (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) */
S
N#endif /*defined(CYDEV_BOOTLOADER_IO_COMP) && ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) || \
N                                                     (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)) */
X#endif  
N
N/* Interface to internal interrupt component */
N#if(UART_1_SCB_IRQ_INTERNAL)
X#if((0u == (1u)))
S    #define UART_1_EnableInt()    UART_1_SCB_IRQ_Enable()
S    #define UART_1_DisableInt()   UART_1_SCB_IRQ_Disable()
N#endif /* (UART_1_SCB_IRQ_INTERNAL) */
N
N/* Get interrupt cause */
N#define UART_1_GetInterruptCause()    (UART_1_INTR_CAUSE_REG)
N
N/* APIs to service INTR_RX register */
N#define UART_1_SetRxInterruptMode(interruptMask)     UART_1_WRITE_INTR_RX_MASK(interruptMask)
N#define UART_1_ClearRxInterruptSource(interruptMask) UART_1_CLEAR_INTR_RX(interruptMask)
N#define UART_1_SetRxInterrupt(interruptMask)         UART_1_SET_INTR_RX(interruptMask)
N#define UART_1_GetRxInterruptSource()                (UART_1_INTR_RX_REG)
N#define UART_1_GetRxInterruptMode()                  (UART_1_INTR_RX_MASK_REG)
N#define UART_1_GetRxInterruptSourceMasked()          (UART_1_INTR_RX_MASKED_REG)
N
N/* APIs to service INTR_TX register */
N#define UART_1_SetTxInterruptMode(interruptMask)     UART_1_WRITE_INTR_TX_MASK(interruptMask)
N#define UART_1_ClearTxInterruptSource(interruptMask) UART_1_CLEAR_INTR_TX(interruptMask)
N#define UART_1_SetTxInterrupt(interruptMask)         UART_1_SET_INTR_TX(interruptMask)
N#define UART_1_GetTxInterruptSource()                (UART_1_INTR_TX_REG)
N#define UART_1_GetTxInterruptMode()                  (UART_1_INTR_TX_MASK_REG)
N#define UART_1_GetTxInterruptSourceMasked()          (UART_1_INTR_TX_MASKED_REG)
N
N/* APIs to service INTR_MASTER register */
N#define UART_1_SetMasterInterruptMode(interruptMask)    UART_1_WRITE_INTR_MASTER_MASK(interruptMask)
N#define UART_1_ClearMasterInterruptSource(interruptMask) UART_1_CLEAR_INTR_MASTER(interruptMask)
N#define UART_1_SetMasterInterrupt(interruptMask)         UART_1_SET_INTR_MASTER(interruptMask)
N#define UART_1_GetMasterInterruptSource()                (UART_1_INTR_MASTER_REG)
N#define UART_1_GetMasterInterruptMode()                  (UART_1_INTR_MASTER_MASK_REG)
N#define UART_1_GetMasterInterruptSourceMasked()          (UART_1_INTR_MASTER_MASKED_REG)
N
N/* APIs to service INTR_SLAVE register */
N#define UART_1_SetSlaveInterruptMode(interruptMask)     UART_1_WRITE_INTR_SLAVE_MASK(interruptMask)
N#define UART_1_ClearSlaveInterruptSource(interruptMask) UART_1_CLEAR_INTR_SLAVE(interruptMask)
N#define UART_1_SetSlaveInterrupt(interruptMask)         UART_1_SET_INTR_SLAVE(interruptMask)
N#define UART_1_GetSlaveInterruptSource()                (UART_1_INTR_SLAVE_REG)
N#define UART_1_GetSlaveInterruptMode()                  (UART_1_INTR_SLAVE_MASK_REG)
N#define UART_1_GetSlaveInterruptSourceMasked()          (UART_1_INTR_SLAVE_MASKED_REG)
N
N
N/**********************************
N*     Vars with External Linkage
N**********************************/
N
Nextern uint8 UART_1_initVar;
N
N
N/***************************************
N*              Registers
N***************************************/
N
N#define UART_1_CTRL_REG               (*(reg32 *) UART_1_SCB__CTRL)
N#define UART_1_CTRL_PTR               ( (reg32 *) UART_1_SCB__CTRL)
N
N#define UART_1_STATUS_REG             (*(reg32 *) UART_1_SCB__STATUS)
N#define UART_1_STATUS_PTR             ( (reg32 *) UART_1_SCB__STATUS)
N
N#define UART_1_SPI_CTRL_REG           (*(reg32 *) UART_1_SCB__SPI_CTRL)
N#define UART_1_SPI_CTRL_PTR           ( (reg32 *) UART_1_SCB__SPI_CTRL)
N
N#define UART_1_SPI_STATUS_REG         (*(reg32 *) UART_1_SCB__SPI_STATUS)
N#define UART_1_SPI_STATUS_PTR         ( (reg32 *) UART_1_SCB__SPI_STATUS)
N
N#define UART_1_UART_CTRL_REG          (*(reg32 *) UART_1_SCB__UART_CTRL)
N#define UART_1_UART_CTRL_PTR          ( (reg32 *) UART_1_SCB__UART_CTRL)
N
N#define UART_1_UART_TX_CTRL_REG       (*(reg32 *) UART_1_SCB__UART_TX_CTRL)
N#define UART_1_UART_TX_CTRL_PTR       ( (reg32 *) UART_1_SCB__UART_RX_CTRL)
N
N#define UART_1_UART_RX_CTRL_REG       (*(reg32 *) UART_1_SCB__UART_RX_CTRL)
N#define UART_1_UART_RX_CTRL_PTR       ( (reg32 *) UART_1_SCB__UART_RX_CTRL)
N
N#define UART_1_UART_RX_STATUS_REG     (*(reg32 *) UART_1_SCB__UART_RX_STATUS)
N#define UART_1_UART_RX_STATUS_PTR     ( (reg32 *) UART_1_SCB__UART_RX_STATUS)
N
N#define UART_1_I2C_CTRL_REG           (*(reg32 *) UART_1_SCB__I2C_CTRL)
N#define UART_1_I2C_CTRL_PTR           ( (reg32 *) UART_1_SCB__I2C_CTRL)
N
N#define UART_1_I2C_STATUS_REG         (*(reg32 *) UART_1_SCB__I2C_STATUS)
N#define UART_1_I2C_STATUS_PTR         ( (reg32 *) UART_1_SCB__I2C_STATUS)
N
N#define UART_1_I2C_MASTER_CMD_REG     (*(reg32 *) UART_1_SCB__I2C_M_CMD)
N#define UART_1_I2C_MASTER_CMD_PTR     ( (reg32 *) UART_1_SCB__I2C_M_CMD)
N
N#define UART_1_I2C_SLAVE_CMD_REG      (*(reg32 *) UART_1_SCB__I2C_S_CMD)
N#define UART_1_I2C_SLAVE_CMD_PTR      ( (reg32 *) UART_1_SCB__I2C_S_CMD)
N
N#define UART_1_I2C_CFG_REG            (*(reg32 *) UART_1_SCB__I2C_CFG)
N#define UART_1_I2C_CFG_PTR            ( (reg32 *) UART_1_SCB__I2C_CFG)
N
N#define UART_1_TX_CTRL_REG            (*(reg32 *) UART_1_SCB__TX_CTRL)
N#define UART_1_TX_CTRL_PTR            ( (reg32 *) UART_1_SCB__TX_CTRL)
N
N#define UART_1_TX_FIFO_CTRL_REG       (*(reg32 *) UART_1_SCB__TX_FIFO_CTRL)
N#define UART_1_TX_FIFO_CTRL_PTR       ( (reg32 *) UART_1_SCB__TX_FIFO_CTRL)
N
N#define UART_1_TX_FIFO_STATUS_REG     (*(reg32 *) UART_1_SCB__TX_FIFO_STATUS)
N#define UART_1_TX_FIFO_STATUS_PTR     ( (reg32 *) UART_1_SCB__TX_FIFO_STATUS)
N
N#define UART_1_TX_FIFO_WR_REG         (*(reg32 *) UART_1_SCB__TX_FIFO_WR)
N#define UART_1_TX_FIFO_WR_PTR         ( (reg32 *) UART_1_SCB__TX_FIFO_WR)
N
N#define UART_1_RX_CTRL_REG            (*(reg32 *) UART_1_SCB__RX_CTRL)
N#define UART_1_RX_CTRL_PTR            ( (reg32 *) UART_1_SCB__RX_CTRL)
N
N#define UART_1_RX_FIFO_CTRL_REG       (*(reg32 *) UART_1_SCB__RX_FIFO_CTRL)
N#define UART_1_RX_FIFO_CTRL_PTR       ( (reg32 *) UART_1_SCB__RX_FIFO_CTRL)
N
N#define UART_1_RX_FIFO_STATUS_REG     (*(reg32 *) UART_1_SCB__RX_FIFO_STATUS)
N#define UART_1_RX_FIFO_STATUS_PTR     ( (reg32 *) UART_1_SCB__RX_FIFO_STATUS)
N
N#define UART_1_RX_MATCH_REG           (*(reg32 *) UART_1_SCB__RX_MATCH)
N#define UART_1_RX_MATCH_PTR           ( (reg32 *) UART_1_SCB__RX_MATCH)
N
N#define UART_1_RX_FIFO_RD_REG         (*(reg32 *) UART_1_SCB__RX_FIFO_RD)
N#define UART_1_RX_FIFO_RD_PTR         ( (reg32 *) UART_1_SCB__RX_FIFO_RD)
N
N#define UART_1_RX_FIFO_RD_SILENT_REG  (*(reg32 *) UART_1_SCB__RX_FIFO_RD_SILENT)
N#define UART_1_RX_FIFO_RD_SILENT_PTR  ( (reg32 *) UART_1_SCB__RX_FIFO_RD_SILENT)
N
N#define UART_1_EZBUF_DATA00_REG       (*(reg32 *) UART_1_SCB__EZ_DATA00)
N#define UART_1_EZBUF_DATA00_PTR       ( (reg32 *) UART_1_SCB__EZ_DATA00)
N
N#define UART_1_INTR_CAUSE_REG         (*(reg32 *) UART_1_SCB__INTR_CAUSE)
N#define UART_1_INTR_CAUSE_PTR         ( (reg32 *) UART_1_SCB__INTR_CAUSE)
N
N#define UART_1_INTR_I2C_EC_REG        (*(reg32 *) UART_1_SCB__INTR_I2C_EC)
N#define UART_1_INTR_I2C_EC_PTR        ( (reg32 *) UART_1_SCB__INTR_I2C_EC)
N
N#define UART_1_INTR_I2C_EC_MASK_REG   (*(reg32 *) UART_1_SCB__INTR_I2C_EC_MASK)
N#define UART_1_INTR_I2C_EC_MASK_PTR   ( (reg32 *) UART_1_SCB__INTR_I2C_EC_MASK)
N
N#define UART_1_INTR_I2C_EC_MASKED_REG (*(reg32 *) UART_1_SCB__INTR_I2C_EC_MASKED)
N#define UART_1_INTR_I2C_EC_MASKED_PTR ( (reg32 *) UART_1_SCB__INTR_I2C_EC_MASKED)
N
N#define UART_1_INTR_SPI_EC_REG        (*(reg32 *) UART_1_SCB__INTR_SPI_EC)
N#define UART_1_INTR_SPI_EC_PTR        ( (reg32 *) UART_1_SCB__INTR_SPI_EC)
N
N#define UART_1_INTR_SPI_EC_MASK_REG   (*(reg32 *) UART_1_SCB__INTR_SPI_EC_MASK)
N#define UART_1_INTR_SPI_EC_MASK_PTR   ( (reg32 *) UART_1_SCB__INTR_SPI_EC_MASK)
N
N#define UART_1_INTR_SPI_EC_MASKED_REG (*(reg32 *) UART_1_SCB__INTR_SPI_EC_MASKED)
N#define UART_1_INTR_SPI_EC_MASKED_PTR ( (reg32 *) UART_1_SCB__INTR_SPI_EC_MASKED)
N
N#define UART_1_INTR_MASTER_REG        (*(reg32 *) UART_1_SCB__INTR_M)
N#define UART_1_INTR_MASTER_PTR        ( (reg32 *) UART_1_SCB__INTR_M)
N
N#define UART_1_INTR_MASTER_SET_REG    (*(reg32 *) UART_1_SCB__INTR_M_SET)
N#define UART_1_INTR_MASTER_SET_PTR    ( (reg32 *) UART_1_SCB__INTR_M_SET)
N
N#define UART_1_INTR_MASTER_MASK_REG   (*(reg32 *) UART_1_SCB__INTR_M_MASK)
N#define UART_1_INTR_MASTER_MASK_PTR   ( (reg32 *) UART_1_SCB__INTR_M_MASK)
N
N#define UART_1_INTR_MASTER_MASKED_REG (*(reg32 *) UART_1_SCB__INTR_M_MASKED)
N#define UART_1_INTR_MASTER_MASKED_PTR ( (reg32 *) UART_1_SCB__INTR_M_MASKED)
N
N#define UART_1_INTR_SLAVE_REG         (*(reg32 *) UART_1_SCB__INTR_S)
N#define UART_1_INTR_SLAVE_PTR         ( (reg32 *) UART_1_SCB__INTR_S)
N
N#define UART_1_INTR_SLAVE_SET_REG     (*(reg32 *) UART_1_SCB__INTR_S_SET)
N#define UART_1_INTR_SLAVE_SET_PTR     ( (reg32 *) UART_1_SCB__INTR_S_SET)
N
N#define UART_1_INTR_SLAVE_MASK_REG    (*(reg32 *) UART_1_SCB__INTR_S_MASK)
N#define UART_1_INTR_SLAVE_MASK_PTR    ( (reg32 *) UART_1_SCB__INTR_S_MASK)
N
N#define UART_1_INTR_SLAVE_MASKED_REG  (*(reg32 *) UART_1_SCB__INTR_S_MASKED)
N#define UART_1_INTR_SLAVE_MASKED_PTR  ( (reg32 *) UART_1_SCB__INTR_S_MASKED)
N
N#define UART_1_INTR_TX_REG            (*(reg32 *) UART_1_SCB__INTR_TX)
N#define UART_1_INTR_TX_PTR            ( (reg32 *) UART_1_SCB__INTR_TX)
N
N#define UART_1_INTR_TX_SET_REG        (*(reg32 *) UART_1_SCB__INTR_TX_SET)
N#define UART_1_INTR_TX_SET_PTR        ( (reg32 *) UART_1_SCB__INTR_TX_SET)
N
N#define UART_1_INTR_TX_MASK_REG       (*(reg32 *) UART_1_SCB__INTR_TX_MASK)
N#define UART_1_INTR_TX_MASK_PTR       ( (reg32 *) UART_1_SCB__INTR_TX_MASK)
N
N#define UART_1_INTR_TX_MASKED_REG     (*(reg32 *) UART_1_SCB__INTR_TX_MASKED)
N#define UART_1_INTR_TX_MASKED_PTR     ( (reg32 *) UART_1_SCB__INTR_TX_MASKED)
N
N#define UART_1_INTR_RX_REG            (*(reg32 *) UART_1_SCB__INTR_RX)
N#define UART_1_INTR_RX_PTR            ( (reg32 *) UART_1_SCB__INTR_RX)
N
N#define UART_1_INTR_RX_SET_REG        (*(reg32 *) UART_1_SCB__INTR_RX_SET)
N#define UART_1_INTR_RX_SET_PTR        ( (reg32 *) UART_1_SCB__INTR_RX_SET)
N
N#define UART_1_INTR_RX_MASK_REG       (*(reg32 *) UART_1_SCB__INTR_RX_MASK)
N#define UART_1_INTR_RX_MASK_PTR       ( (reg32 *) UART_1_SCB__INTR_RX_MASK)
N
N#define UART_1_INTR_RX_MASKED_REG     (*(reg32 *) UART_1_SCB__INTR_RX_MASKED)
N#define UART_1_INTR_RX_MASKED_PTR     ( (reg32 *) UART_1_SCB__INTR_RX_MASKED)
N
N
N/***************************************
N*        Registers Constants
N***************************************/
N
N/* UART_1_CTRL */
N#define UART_1_CTRL_OVS_POS           (0u)  /* [3:0]   Oversampling factor                 */
N#define UART_1_CTRL_EC_AM_MODE_POS    (8u)  /* [8]     Externally clocked address match    */
N#define UART_1_CTRL_EC_OP_MODE_POS    (9u)  /* [9]     Externally clocked operation mode   */
N#define UART_1_CTRL_EZBUF_MODE_POS    (10u) /* [10]    EZ buffer is enabled                */
N#define UART_1_CTRL_ADDR_ACCEPT_POS   (16u) /* [16]    Put matched address in RX FIFO      */
N#define UART_1_CTRL_BLOCK_POS         (17u) /* [17]    Ext and Int logic to resolve colide */
N#define UART_1_CTRL_MODE_POS          (24u) /* [25:24] Operation mode                      */
N#define UART_1_CTRL_ENABLED_POS       (31u) /* [31]    Enable SCB block                    */
N#define UART_1_CTRL_OVS_MASK          ((uint32) 0x0Fu)
N#define UART_1_CTRL_EC_AM_MODE        ((uint32) ((uint32) 0x01u << UART_1_CTRL_EC_AM_MODE_POS))
N#define UART_1_CTRL_EC_OP_MODE        ((uint32) ((uint32) 0x01u << UART_1_CTRL_EC_OP_MODE_POS))
N#define UART_1_CTRL_EZBUF_MODE        ((uint32) ((uint32) 0x01u << UART_1_CTRL_EZBUF_MODE_POS))
N#define UART_1_CTRL_ADDR_ACCEPT       ((uint32) ((uint32) 0x01u << UART_1_CTRL_ADDR_ACCEPT_POS))
N#define UART_1_CTRL_BLOCK             ((uint32) ((uint32) 0x01u << UART_1_CTRL_BLOCK_POS))
N#define UART_1_CTRL_MODE_MASK         ((uint32) ((uint32) 0x03u << UART_1_CTRL_MODE_POS))
N#define UART_1_CTRL_MODE_I2C          ((uint32)  0x00u)
N#define UART_1_CTRL_MODE_SPI          ((uint32) ((uint32) 0x01u << UART_1_CTRL_MODE_POS))
N#define UART_1_CTRL_MODE_UART         ((uint32) ((uint32) 0x02u << UART_1_CTRL_MODE_POS))
N#define UART_1_CTRL_ENABLED           ((uint32) ((uint32) 0x01u << UART_1_CTRL_ENABLED_POS))
N
N
N/* UART_1_STATUS_REG */
N#define UART_1_STATUS_EC_BUSY_POS     (0u)  /* [0] Bus busy. Externaly clocked loigc access to EZ memory */
N#define UART_1_STATUS_EC_BUSY         ((uint32) 0x0Fu)
N
N
N/* UART_1_SPI_CTRL_REG  */
N#define UART_1_SPI_CTRL_CONTINUOUS_POS        (0u)  /* [0]     Continuous or Separated SPI data transfers */
N#define UART_1_SPI_CTRL_SELECT_PRECEDE_POS    (1u)  /* [1]     Precedes or coincides start of data frame  */
N#define UART_1_SPI_CTRL_CPHA_POS              (2u)  /* [2]     SCLK phase                                 */
N#define UART_1_SPI_CTRL_CPOL_POS              (3u)  /* [3]     SCLK polarity                              */
N#define UART_1_SPI_CTRL_LATE_MISO_SAMPLE_POS  (4u)  /* [4]     Late MISO sample enabled                   */
N#define UART_1_SPI_CTRL_LOOPBACK_POS          (16u) /* [16]    Local loopback control enabled             */
N#define UART_1_SPI_CTRL_MODE_POS              (24u) /* [25:24] Submode of SPI operation                   */
N#define UART_1_SPI_CTRL_SLAVE_SELECT_POS      (26u) /* [27:26] Selects SPI SS signal                      */
N#define UART_1_SPI_CTRL_MASTER_MODE_POS       (31u) /* [31]    Master mode enabled                        */
N#define UART_1_SPI_CTRL_CONTINUOUS            ((uint32) 0x01u)
N#define UART_1_SPI_CTRL_SELECT_PRECEDE        ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_SPI_CTRL_SELECT_PRECEDE_POS))
X#define UART_1_SPI_CTRL_SELECT_PRECEDE        ((uint32) ((uint32) 0x01u <<                                                                     UART_1_SPI_CTRL_SELECT_PRECEDE_POS))
N#define UART_1_SPI_CTRL_SCLK_MODE_MASK        ((uint32) ((uint32) 0x03u << \
N                                                                    UART_1_SPI_CTRL_CPHA_POS))
X#define UART_1_SPI_CTRL_SCLK_MODE_MASK        ((uint32) ((uint32) 0x03u <<                                                                     UART_1_SPI_CTRL_CPHA_POS))
N#define UART_1_SPI_CTRL_CPHA                  ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_SPI_CTRL_CPHA_POS))
X#define UART_1_SPI_CTRL_CPHA                  ((uint32) ((uint32) 0x01u <<                                                                     UART_1_SPI_CTRL_CPHA_POS))
N#define UART_1_SPI_CTRL_CPOL                  ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_SPI_CTRL_CPOL_POS))
X#define UART_1_SPI_CTRL_CPOL                  ((uint32) ((uint32) 0x01u <<                                                                     UART_1_SPI_CTRL_CPOL_POS))
N#define UART_1_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_SPI_CTRL_LATE_MISO_SAMPLE_POS))
X#define UART_1_SPI_CTRL_LATE_MISO_SAMPLE      ((uint32) ((uint32) 0x01u <<                                                                     UART_1_SPI_CTRL_LATE_MISO_SAMPLE_POS))
N#define UART_1_SPI_CTRL_LOOPBACK              ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_SPI_CTRL_LOOPBACK_POS))
X#define UART_1_SPI_CTRL_LOOPBACK              ((uint32) ((uint32) 0x01u <<                                                                     UART_1_SPI_CTRL_LOOPBACK_POS))
N#define UART_1_SPI_CTRL_MODE_MASK             ((uint32) ((uint32) 0x03u << \
N                                                                    UART_1_SPI_CTRL_MODE_POS))
X#define UART_1_SPI_CTRL_MODE_MASK             ((uint32) ((uint32) 0x03u <<                                                                     UART_1_SPI_CTRL_MODE_POS))
N#define UART_1_SPI_CTRL_MODE_MOTOROLA         ((uint32) 0x00u)
N#define UART_1_SPI_CTRL_MODE_TI               ((uint32) ((uint32) 0x01u << UART_1_CTRL_MODE_POS))
N#define UART_1_SPI_CTRL_MODE_NS               ((uint32) ((uint32) 0x02u << UART_1_CTRL_MODE_POS))
N#define UART_1_SPI_CTRL_SLAVE_SELECT_MASK     ((uint32) ((uint32) 0x03u << \
N                                                                    UART_1_SPI_CTRL_SLAVE_SELECT_POS))
X#define UART_1_SPI_CTRL_SLAVE_SELECT_MASK     ((uint32) ((uint32) 0x03u <<                                                                     UART_1_SPI_CTRL_SLAVE_SELECT_POS))
N#define UART_1_SPI_CTRL_SLAVE_SELECT0         ((uint32) 0x00u)
N#define UART_1_SPI_CTRL_SLAVE_SELECT1         ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_SPI_CTRL_SLAVE_SELECT_POS))
X#define UART_1_SPI_CTRL_SLAVE_SELECT1         ((uint32) ((uint32) 0x01u <<                                                                     UART_1_SPI_CTRL_SLAVE_SELECT_POS))
N#define UART_1_SPI_CTRL_SLAVE_SELECT2         ((uint32) ((uint32) 0x02u << \
N                                                                    UART_1_SPI_CTRL_SLAVE_SELECT_POS))
X#define UART_1_SPI_CTRL_SLAVE_SELECT2         ((uint32) ((uint32) 0x02u <<                                                                     UART_1_SPI_CTRL_SLAVE_SELECT_POS))
N#define UART_1_SPI_CTRL_SLAVE_SELECT3         ((uint32) ((uint32) 0x03u << \
N                                                                    UART_1_SPI_CTRL_SLAVE_SELECT_POS))
X#define UART_1_SPI_CTRL_SLAVE_SELECT3         ((uint32) ((uint32) 0x03u <<                                                                     UART_1_SPI_CTRL_SLAVE_SELECT_POS))
N#define UART_1_SPI_CTRL_MASTER                ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_SPI_CTRL_MASTER_MODE_POS))
X#define UART_1_SPI_CTRL_MASTER                ((uint32) ((uint32) 0x01u <<                                                                     UART_1_SPI_CTRL_MASTER_MODE_POS))
N#define UART_1_SPI_CTRL_SLAVE                 ((uint32) 0x00u)
N
N
N/* UART_1_SPI_STATUS_REG  */
N#define UART_1_SPI_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy - slave selected */
N#define UART_1_SPI_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EzAddress                 */
N#define UART_1_SPI_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define UART_1_SPI_STATUS_EZBUF_ADDR_MASK    ((uint32) ((uint32) 0xFFu << \
N                                                                    UART_1_I2C_STATUS_EZBUF_ADDR_POS))
X#define UART_1_SPI_STATUS_EZBUF_ADDR_MASK    ((uint32) ((uint32) 0xFFu <<                                                                     UART_1_I2C_STATUS_EZBUF_ADDR_POS))
N
N
N/* UART_1_UART_CTRL */
N#define UART_1_UART_CTRL_LOOPBACK_POS         (16u) /* [16] Loopback     */
N#define UART_1_UART_CTRL_MODE_POS             (24u) /* [24] UART subMode */
N#define UART_1_UART_CTRL_LOOPBACK             ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_UART_CTRL_LOOPBACK_POS))
X#define UART_1_UART_CTRL_LOOPBACK             ((uint32) ((uint32) 0x01u <<                                                                         UART_1_UART_CTRL_LOOPBACK_POS))
N#define UART_1_UART_CTRL_MODE_UART_STD        ((uint32) 0x00u)
N#define UART_1_UART_CTRL_MODE_UART_SMARTCARD  ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_UART_CTRL_MODE_POS))
X#define UART_1_UART_CTRL_MODE_UART_SMARTCARD  ((uint32) ((uint32) 0x01u <<                                                                         UART_1_UART_CTRL_MODE_POS))
N#define UART_1_UART_CTRL_MODE_UART_IRDA       ((uint32) ((uint32) 0x02u << \
N                                                                        UART_1_UART_CTRL_MODE_POS))
X#define UART_1_UART_CTRL_MODE_UART_IRDA       ((uint32) ((uint32) 0x02u <<                                                                         UART_1_UART_CTRL_MODE_POS))
N#define UART_1_UART_CTRL_MODE_MASK            ((uint32) ((uint32) 0x03u << \
N                                                                        UART_1_UART_CTRL_MODE_POS))
X#define UART_1_UART_CTRL_MODE_MASK            ((uint32) ((uint32) 0x03u <<                                                                         UART_1_UART_CTRL_MODE_POS))
N
N
N/* UART_1_UART_TX_CTRL */
N#define UART_1_UART_TX_CTRL_STOP_BITS_POS         (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 period */
N#define UART_1_UART_TX_CTRL_PARITY_POS            (4u)  /* [4]   Parity bit                              */
N#define UART_1_UART_TX_CTRL_PARITY_ENABLED_POS    (5u)  /* [5]   Parity enable                           */
N#define UART_1_UART_TX_CTRL_RETRY_ON_NACK_POS     (8u)  /* [8]   Smart Card: re-send frame on NACK       */
N#define UART_1_UART_TX_CTRL_ONE_STOP_BIT          ((uint32) 0x01u)
N#define UART_1_UART_TX_CTRL_ONE_HALF_STOP_BITS    ((uint32) 0x02u)
N#define UART_1_UART_TX_CTRL_TWO_STOP_BITS         ((uint32) 0x03u)
N#define UART_1_UART_TX_CTRL_STOP_BITS_MASK        ((uint32) 0x07u)
N#define UART_1_UART_TX_CTRL_PARITY                ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_UART_TX_CTRL_PARITY_POS))
X#define UART_1_UART_TX_CTRL_PARITY                ((uint32) ((uint32) 0x01u <<                                                                     UART_1_UART_TX_CTRL_PARITY_POS))
N#define UART_1_UART_TX_CTRL_PARITY_ENABLED        ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_UART_TX_CTRL_PARITY_ENABLED_POS))
X#define UART_1_UART_TX_CTRL_PARITY_ENABLED        ((uint32) ((uint32) 0x01u <<                                                                     UART_1_UART_TX_CTRL_PARITY_ENABLED_POS))
N#define UART_1_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_UART_TX_CTRL_RETRY_ON_NACK_POS))
X#define UART_1_UART_TX_CTRL_RETRY_ON_NACK         ((uint32) ((uint32) 0x01u <<                                                                     UART_1_UART_TX_CTRL_RETRY_ON_NACK_POS))
N
N
N/* UART_1_UART_RX_CTRL */
N#define UART_1_UART_RX_CTRL_STOP_BITS_POS             (0u)  /* [2:0] Stop bits: (Stop bits + 1) * 0.5 prd   */
N#define UART_1_UART_RX_CTRL_PARITY_POS                (4u)  /* [4]   Parity bit                             */
N#define UART_1_UART_RX_CTRL_PARITY_ENABLED_POS        (5u)  /* [5]   Parity enable                          */
N#define UART_1_UART_RX_CTRL_POLARITY_POS              (6u)  /* [6]   IrDA: inverts polarity of RX signal    */
N#define UART_1_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS    (8u)  /* [8]   Drop and lost RX FIFO on parity error  */
N#define UART_1_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS     (9u)  /* [9]   Drop and lost RX FIFO on frame error   */
N#define UART_1_UART_RX_CTRL_MP_MODE_POS               (10u) /* [10]  Multi-processor mode                   */
N#define UART_1_UART_RX_CTRL_LIN_MODE_POS              (12u) /* [12]  Lin mode: applicable for UART Standart */
N#define UART_1_UART_RX_CTRL_SKIP_START_POS            (13u) /* [13]  Skip start not: only for UART Standart */
N#define UART_1_UART_RX_CTRL_BREAK_WIDTH_POS           (16u) /* [19:16]  Break width: (Break width + 1)      */
N#define UART_1_UART_TX_CTRL_ONE_STOP_BIT              ((uint32) 0x01u)
N#define UART_1_UART_TX_CTRL_ONE_HALF_STOP_BITS        ((uint32) 0x02u)
N#define UART_1_UART_TX_CTRL_TWO_STOP_BITS             ((uint32) 0x03u)
N#define UART_1_UART_RX_CTRL_STOP_BITS_MASK            ((uint32) 0x07u)
N#define UART_1_UART_RX_CTRL_PARITY                    ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_UART_RX_CTRL_PARITY_POS))
X#define UART_1_UART_RX_CTRL_PARITY                    ((uint32) ((uint32) 0x01u <<                                                                     UART_1_UART_RX_CTRL_PARITY_POS))
N#define UART_1_UART_RX_CTRL_PARITY_ENABLED            ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_UART_RX_CTRL_PARITY_ENABLED_POS))
X#define UART_1_UART_RX_CTRL_PARITY_ENABLED            ((uint32) ((uint32) 0x01u <<                                                                     UART_1_UART_RX_CTRL_PARITY_ENABLED_POS))
N#define UART_1_UART_RX_CTRL_POLARITY                  ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_UART_RX_CTRL_POLARITY_POS))
X#define UART_1_UART_RX_CTRL_POLARITY                  ((uint32) ((uint32) 0x01u <<                                                                     UART_1_UART_RX_CTRL_POLARITY_POS))
N#define UART_1_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS))
X#define UART_1_UART_RX_CTRL_DROP_ON_PARITY_ERR        ((uint32) ((uint32) 0x01u <<                                                                 UART_1_UART_RX_CTRL_DROP_ON_PARITY_ERR_POS))
N#define UART_1_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS))
X#define UART_1_UART_RX_CTRL_DROP_ON_FRAME_ERR         ((uint32) ((uint32) 0x01u <<                                                                 UART_1_UART_RX_CTRL_DROP_ON_FRAME_ERR_POS))
N#define UART_1_UART_RX_CTRL_MP_MODE                   ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_UART_RX_CTRL_MP_MODE_POS))
X#define UART_1_UART_RX_CTRL_MP_MODE                   ((uint32) ((uint32) 0x01u <<                                                                     UART_1_UART_RX_CTRL_MP_MODE_POS))
N#define UART_1_UART_RX_CTRL_LIN_MODE                  ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_UART_RX_CTRL_LIN_MODE_POS))
X#define UART_1_UART_RX_CTRL_LIN_MODE                  ((uint32) ((uint32) 0x01u <<                                                                     UART_1_UART_RX_CTRL_LIN_MODE_POS))
N#define UART_1_UART_RX_CTRL_SKIP_START                ((uint32) ((uint32) 0x01u << \
N                                                                  UART_1_UART_RX_CTRL_SKIP_START_POS))
X#define UART_1_UART_RX_CTRL_SKIP_START                ((uint32) ((uint32) 0x01u <<                                                                   UART_1_UART_RX_CTRL_SKIP_START_POS))
N#define UART_1_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) ((uint32) 0x0Fu << \
N                                                                  UART_1_UART_RX_CTRL_BREAK_WIDTH_POS))
X#define UART_1_UART_RX_CTRL_BREAK_WIDTH_MASK          ((uint32) ((uint32) 0x0Fu <<                                                                   UART_1_UART_RX_CTRL_BREAK_WIDTH_POS))
N
N/* UART_1_UART_RX_STATUS_REG */
N#define UART_1_UART_RX_STATUS_BR_COUNTER_POS     (0u)  /* [11:0] Baute Rate counter */
N#define UART_1_UART_RX_STATUS_BR_COUNTER_MASK    ((uint32) 0xFFFu)
N
N
N/* UART_1_I2C_CTRL */
N#define UART_1_I2C_CTRL_HIGH_PHASE_OVS_POS           (0u)   /* [3:0] Oversampling factor high: masrer only */
N#define UART_1_I2C_CTRL_LOW_PHASE_OVS_POS            (4u)   /* [7:4] Oversampling factor low:  masrer only */
N#define UART_1_I2C_CTRL_M_READY_DATA_ACK_POS         (8u)   /* [8]   Master ACKs data wgile RX FIFO != FULL*/
N#define UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK_POS    (9u)   /* [9]   Master NACKs data if RX FIFO ==  FULL */
N#define UART_1_I2C_CTRL_S_GENERAL_IGNORE_POS         (11u)  /* [11]  Slave ignores General call            */
N#define UART_1_I2C_CTRL_S_READY_ADDR_ACK_POS         (12u)  /* [12]  Slave ACKs Address if RX FIFO != FULL */
N#define UART_1_I2C_CTRL_S_READY_DATA_ACK_POS         (13u)  /* [13]  Slave ACKs data while RX FIFO == FULL */
N#define UART_1_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS    (14u)  /* [14]  Slave NACKs address if RX FIFO == FULL*/
N#define UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK_POS    (15u)  /* [15]  Slave NACKs data if RX FIFO is  FULL  */
N#define UART_1_I2C_CTRL_LOOPBACK_POS                 (16u)  /* [16]  Loopback                              */
N#define UART_1_I2C_CTRL_SLAVE_MODE_POS               (30u)  /* [30]  Slave mode enabled                    */
N#define UART_1_I2C_CTRL_MASTER_MODE_POS              (31u)  /* [31]  Master mode enabled                   */
N#define UART_1_I2C_CTRL_HIGH_PHASE_OVS_MASK  ((uint32) 0x0Fu)
N#define UART_1_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) ((uint32) 0x0Fu << \
N                                                                UART_1_I2C_CTRL_LOW_PHASE_OVS_POS))
X#define UART_1_I2C_CTRL_LOW_PHASE_OVS_MASK   ((uint32) ((uint32) 0x0Fu <<                                                                 UART_1_I2C_CTRL_LOW_PHASE_OVS_POS))
N#define UART_1_I2C_CTRL_M_READY_DATA_ACK      ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_M_READY_DATA_ACK_POS))
X#define UART_1_I2C_CTRL_M_READY_DATA_ACK      ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_M_READY_DATA_ACK_POS))
N#define UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK_POS))
X#define UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK_POS))
N#define UART_1_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_S_GENERAL_IGNORE_POS))
X#define UART_1_I2C_CTRL_S_GENERAL_IGNORE      ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_S_GENERAL_IGNORE_POS))
N#define UART_1_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_S_READY_ADDR_ACK_POS))
X#define UART_1_I2C_CTRL_S_READY_ADDR_ACK      ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_S_READY_ADDR_ACK_POS))
N#define UART_1_I2C_CTRL_S_READY_DATA_ACK      ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_S_READY_DATA_ACK_POS))
X#define UART_1_I2C_CTRL_S_READY_DATA_ACK      ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_S_READY_DATA_ACK_POS))
N#define UART_1_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS))
X#define UART_1_I2C_CTRL_S_NOT_READY_ADDR_NACK ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_S_NOT_READY_ADDR_NACK_POS))
N#define UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK_POS))
X#define UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK_POS))
N#define UART_1_I2C_CTRL_LOOPBACK              ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_LOOPBACK_POS))
X#define UART_1_I2C_CTRL_LOOPBACK              ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_LOOPBACK_POS))
N#define UART_1_I2C_CTRL_SLAVE_MODE            ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_SLAVE_MODE_POS))
X#define UART_1_I2C_CTRL_SLAVE_MODE            ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_SLAVE_MODE_POS))
N#define UART_1_I2C_CTRL_MASTER_MODE           ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CTRL_MASTER_MODE_POS))
X#define UART_1_I2C_CTRL_MASTER_MODE           ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CTRL_MASTER_MODE_POS))
N#define UART_1_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) ((uint32) 0x03u << \
N                                                                UART_1_I2C_CTRL_SLAVE_MODE_POS))
X#define UART_1_I2C_CTRL_SLAVE_MASTER_MODE_MASK    ((uint32) ((uint32) 0x03u <<                                                                 UART_1_I2C_CTRL_SLAVE_MODE_POS))
N
N
N/* UART_1_I2C_STATUS_REG  */
N#define UART_1_I2C_STATUS_BUS_BUSY_POS    (0u)  /* [0]    Bus busy: internally clocked */
N#define UART_1_I2C_STATUS_S_READ_POS      (4u)  /* [4]    Slave is read by master      */
N#define UART_1_I2C_STATUS_M_READ_POS      (5u)  /* [5]    Master reads Slave           */
N#define UART_1_I2C_STATUS_EZBUF_ADDR_POS  (8u)  /* [15:8] EZAddress                    */
N#define UART_1_I2C_STATUS_BUS_BUSY        ((uint32) 0x01u)
N#define UART_1_I2C_STATUS_S_READ          ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_I2C_STATUS_S_READ_POS))
X#define UART_1_I2C_STATUS_S_READ          ((uint32) ((uint32) 0x01u <<                                                                     UART_1_I2C_STATUS_S_READ_POS))
N#define UART_1_I2C_STATUS_M_READ          ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_I2C_STATUS_M_READ_POS))
X#define UART_1_I2C_STATUS_M_READ          ((uint32) ((uint32) 0x01u <<                                                                     UART_1_I2C_STATUS_M_READ_POS))
N#define UART_1_I2C_STATUS_EZBUF_ADDR_MASK ((uint32) ((uint32) 0xFFu << \
N                                                                    UART_1_I2C_STATUS_EZBUF_ADDR_POS))
X#define UART_1_I2C_STATUS_EZBUF_ADDR_MASK ((uint32) ((uint32) 0xFFu <<                                                                     UART_1_I2C_STATUS_EZBUF_ADDR_POS))
N
N
N/* UART_1_I2C_MASTER_CMD_REG */
N#define UART_1_I2C_MASTER_CMD_M_START_POS             (0u)  /* [0] Master generate Start                */
N#define UART_1_I2C_MASTER_CMD_M_START_ON_IDLE_POS     (1u)  /* [1] Master generate Start if bus is free */
N#define UART_1_I2C_MASTER_CMD_M_ACK_POS               (2u)  /* [2] Master generate ACK                  */
N#define UART_1_I2C_MASTER_CMD_M_NACK_POS              (3u)  /* [3] Master generate NACK                 */
N#define UART_1_I2C_MASTER_CMD_M_STOP_POS              (4u)  /* [4] Master generate Stop                 */
N#define UART_1_I2C_MASTER_CMD_M_START         ((uint32) 0x01u)
N#define UART_1_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) ((uint32) 0x01u << \
N                                                                   UART_1_I2C_MASTER_CMD_M_START_ON_IDLE_POS))
X#define UART_1_I2C_MASTER_CMD_M_START_ON_IDLE ((uint32) ((uint32) 0x01u <<                                                                    UART_1_I2C_MASTER_CMD_M_START_ON_IDLE_POS))
N#define UART_1_I2C_MASTER_CMD_M_ACK           ((uint32) ((uint32) 0x01u << \
N                                                                   UART_1_I2C_MASTER_CMD_M_ACK_POS))
X#define UART_1_I2C_MASTER_CMD_M_ACK           ((uint32) ((uint32) 0x01u <<                                                                    UART_1_I2C_MASTER_CMD_M_ACK_POS))
N#define UART_1_I2C_MASTER_CMD_M_NACK          ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_I2C_MASTER_CMD_M_NACK_POS))
X#define UART_1_I2C_MASTER_CMD_M_NACK          ((uint32) ((uint32) 0x01u <<                                                                     UART_1_I2C_MASTER_CMD_M_NACK_POS))
N#define UART_1_I2C_MASTER_CMD_M_STOP          ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_I2C_MASTER_CMD_M_STOP_POS))
X#define UART_1_I2C_MASTER_CMD_M_STOP          ((uint32) ((uint32) 0x01u <<                                                                     UART_1_I2C_MASTER_CMD_M_STOP_POS))
N
N
N/* UART_1_I2C_SLAVE_CMD_REG  */
N#define UART_1_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define UART_1_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define UART_1_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define UART_1_I2C_SLAVE_CMD_S_NACK       ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_SLAVE_CMD_S_NACK_POS))
X#define UART_1_I2C_SLAVE_CMD_S_NACK       ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_SLAVE_CMD_S_NACK_POS))
N
N#define UART_1_I2C_SLAVE_CMD_S_ACK_POS    (0u)  /* [0] Slave generate ACK  */
N#define UART_1_I2C_SLAVE_CMD_S_NACK_POS   (1u)  /* [1] Slave generate NACK */
N#define UART_1_I2C_SLAVE_CMD_S_ACK        ((uint32) 0x01u)
N#define UART_1_I2C_SLAVE_CMD_S_NACK       ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_SLAVE_CMD_S_NACK_POS))
X#define UART_1_I2C_SLAVE_CMD_S_NACK       ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_SLAVE_CMD_S_NACK_POS))
N/* UART_1_I2C_CFG  */
N#define UART_1_I2C_CFG_SDA_FILT_HYS_POS           (0u)  /* [1:0]   Trim bits for the I2C SDA filter         */
N#define UART_1_I2C_CFG_SDA_FILT_TRIM_POS          (2u)  /* [3:2]   Trim bits for the I2C SDA filter         */
N#define UART_1_I2C_CFG_SCL_FILT_HYS_POS           (4u)  /* [5:4]   Trim bits for the I2C SCL filter         */
N#define UART_1_I2C_CFG_SCL_FILT_TRIM_POS          (6u)  /* [7:6]   Trim bits for the I2C SCL filter         */
N#define UART_1_I2C_CFG_SDA_FILT_OUT_HYS_POS       (8u)  /* [9:8]   Trim bits for I2C SDA filter output path */
N#define UART_1_I2C_CFG_SDA_FILT_OUT_TRIM_POS      (10u) /* [11:10] Trim bits for I2C SDA filter output path */
N#define UART_1_I2C_CFG_SDA_FILT_HS_POS            (16u) /* [16]    '0': 50 ns filter, '1': 10 ns filter     */
N#define UART_1_I2C_CFG_SDA_FILT_ENABLED_POS       (17u) /* [17]    I2C SDA filter enabled                   */
N#define UART_1_I2C_CFG_SCL_FILT_HS_POS            (24u) /* [24]    '0': 50 ns filter, '1': 10 ns filter     */
N#define UART_1_I2C_CFG_SCL_FILT_ENABLED_POS       (25u) /* [25]    I2C SCL filter enabled                   */
N#define UART_1_I2C_CFG_SDA_FILT_OUT_HS_POS        (26u) /* [26]    '0': 50ns filter, '1': 10 ns filter      */
N#define UART_1_I2C_CFG_SDA_FILT_OUT_ENABLED_POS   (27u) /* [27]    I2C SDA output delay filter enabled      */
N#define UART_1_I2C_CFG_SDA_FILT_HYS_MASK          ((uint32) 0x00u)
N#define UART_1_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) ((uint32) 0x03u << \
N                                                                UART_1_I2C_CFG_SDA_FILT_TRIM_POS))
X#define UART_1_I2C_CFG_SDA_FILT_TRIM_MASK         ((uint32) ((uint32) 0x03u <<                                                                 UART_1_I2C_CFG_SDA_FILT_TRIM_POS))
N#define UART_1_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) ((uint32) 0x03u << \
N                                                                UART_1_I2C_CFG_SCL_FILT_HYS_POS))
X#define UART_1_I2C_CFG_SCL_FILT_HYS_MASK          ((uint32) ((uint32) 0x03u <<                                                                 UART_1_I2C_CFG_SCL_FILT_HYS_POS))
N#define UART_1_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) ((uint32) 0x03u << \
N                                                                UART_1_I2C_CFG_SCL_FILT_TRIM_POS))
X#define UART_1_I2C_CFG_SCL_FILT_TRIM_MASK         ((uint32) ((uint32) 0x03u <<                                                                 UART_1_I2C_CFG_SCL_FILT_TRIM_POS))
N#define UART_1_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) ((uint32) 0x03u << \
N                                                                UART_1_I2C_CFG_SDA_FILT_OUT_HYS_POS))
X#define UART_1_I2C_CFG_SDA_FILT_OUT_HYS_MASK      ((uint32) ((uint32) 0x03u <<                                                                 UART_1_I2C_CFG_SDA_FILT_OUT_HYS_POS))
N#define UART_1_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) ((uint32) 0x03u << \
N                                                                UART_1_I2C_CFG_SDA_FILT_OUT_TRIM_POS))
X#define UART_1_I2C_CFG_SDA_FILT_OUT_TRIM_MASK     ((uint32) ((uint32) 0x03u <<                                                                 UART_1_I2C_CFG_SDA_FILT_OUT_TRIM_POS))
N#define UART_1_I2C_CFG_SDA_FILT_HS                ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CFG_SDA_FILT_HS_POS))
X#define UART_1_I2C_CFG_SDA_FILT_HS                ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CFG_SDA_FILT_HS_POS))
N#define UART_1_I2C_CFG_SDA_FILT_ENABLED           ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CFG_SDA_FILT_ENABLED_POS))
X#define UART_1_I2C_CFG_SDA_FILT_ENABLED           ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CFG_SDA_FILT_ENABLED_POS))
N#define UART_1_I2C_CFG_SCL_FILT_HS                ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CFG_SCL_FILT_HS_POS))
X#define UART_1_I2C_CFG_SCL_FILT_HS                ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CFG_SCL_FILT_HS_POS))
N#define UART_1_I2C_CFG_SCL_FILT_ENABLED           ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CFG_SCL_FILT_ENABLED_POS))
X#define UART_1_I2C_CFG_SCL_FILT_ENABLED           ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CFG_SCL_FILT_ENABLED_POS))
N#define UART_1_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CFG_SDA_FILT_OUT_HS_POS))
X#define UART_1_I2C_CFG_SDA_FILT_OUT_HS            ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CFG_SDA_FILT_OUT_HS_POS))
N#define UART_1_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) ((uint32) 0x01u << \
N                                                                UART_1_I2C_CFG_SDA_FILT_OUT_ENABLED_POS))
X#define UART_1_I2C_CFG_SDA_FILT_OUT_ENABLED       ((uint32) ((uint32) 0x01u <<                                                                 UART_1_I2C_CFG_SDA_FILT_OUT_ENABLED_POS))
N
N
N/* UART_1_TX_CTRL_REG */
N#define UART_1_TX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Dataframe width: (Data width - 1) */
N#define UART_1_TX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define UART_1_TX_CTRL_ENABLED_POS        (31u) /* [31]  Transmitter enabled               */
N#define UART_1_TX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define UART_1_TX_CTRL_MSB_FIRST          ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_TX_CTRL_MSB_FIRST_POS))
X#define UART_1_TX_CTRL_MSB_FIRST          ((uint32) ((uint32) 0x01u <<                                                                         UART_1_TX_CTRL_MSB_FIRST_POS))
N#define UART_1_TX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define UART_1_TX_CTRL_ENABLED            ((uint32) ((uint32) 0x01u << UART_1_TX_CTRL_ENABLED_POS))
N
N
N/* UART_1_TX_CTRL_FIFO_REG */
N#define UART_1_TX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)  /* [2:0] Trigger level                              */
N#define UART_1_TX_FIFO_CTRL_CLEAR_POS             (16u) /* [16]  Clear TX FIFO: claared after set           */
N#define UART_1_TX_FIFO_CTRL_FREEZE_POS            (17u) /* [17]  Freeze TX FIFO: HW do not inc read pointer */
N#define UART_1_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) 0x07u)
N#define UART_1_TX_FIFO_CTRL_CLEAR                 ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_TX_FIFO_CTRL_CLEAR_POS))
X#define UART_1_TX_FIFO_CTRL_CLEAR                 ((uint32) ((uint32) 0x01u <<                                                                     UART_1_TX_FIFO_CTRL_CLEAR_POS))
N#define UART_1_TX_FIFO_CTRL_FREEZE                ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_TX_FIFO_CTRL_FREEZE_POS))
X#define UART_1_TX_FIFO_CTRL_FREEZE                ((uint32) ((uint32) 0x01u <<                                                                     UART_1_TX_FIFO_CTRL_FREEZE_POS))
N
N
N/* UART_1_TX_FIFO_STATUS_REG */
N#define UART_1_TX_FIFO_STATUS_USED_POS    (0u)  /* [3:0]   Amount of entries in TX FIFO */
N#define UART_1_TX_FIFO_SR_VALID_POS       (15u) /* [15]    Shifter status of TX FIFO    */
N#define UART_1_TX_FIFO_STATUS_RD_PTR_POS  (16u) /* [18:16] TX FIFO read pointer         */
N#define UART_1_TX_FIFO_STATUS_WR_PTR_POS  (24u) /* [26:24] TX FIFO write pointer        */
N#define UART_1_TX_FIFO_STATUS_USED_MASK   ((uint32) 0x0Fu)
N#define UART_1_TX_FIFO_SR_VALID           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_TX_FIFO_SR_VALID_POS))
X#define UART_1_TX_FIFO_SR_VALID           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_TX_FIFO_SR_VALID_POS))
N#define UART_1_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) ((uint32) 0x07u << \
N                                                                    UART_1_TX_FIFO_STATUS_RD_PTR_POS))
X#define UART_1_TX_FIFO_STATUS_RD_PTR_MASK ((uint32) ((uint32) 0x07u <<                                                                     UART_1_TX_FIFO_STATUS_RD_PTR_POS))
N#define UART_1_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) ((uint32) 0x07u << \
N                                                                    UART_1_TX_FIFO_STATUS_WR_PTR_POS))
X#define UART_1_TX_FIFO_STATUS_WR_PTR_MASK ((uint32) ((uint32) 0x07u <<                                                                     UART_1_TX_FIFO_STATUS_WR_PTR_POS))
N
N
N/* UART_1_TX_FIFO_WR_REG */
N#define UART_1_TX_FIFO_WR_POS    (0u)  /* [15:0] Data written into TX FIFO */
N#define UART_1_TX_FIFO_WR_MASK   ((uint32) 0xFFu)
N
N
N/* UART_1_RX_CTRL_REG */
N#define UART_1_RX_CTRL_DATA_WIDTH_POS     (0u)  /* [3:0] Dataframe width: (Data width - 1) */
N#define UART_1_RX_CTRL_MSB_FIRST_POS      (8u)  /* [8]   MSB first shifter-out             */
N#define UART_1_RX_CTRL_MEDIAN_POS         (9u)  /* [9]   Median filter                     */
N#define UART_1_RX_CTRL_ENABLED_POS        (31u) /* [31]  Receiver enabled                  */
N#define UART_1_RX_CTRL_DATA_WIDTH_MASK    ((uint32) 0x0Fu)
N#define UART_1_RX_CTRL_MSB_FIRST          ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_RX_CTRL_MSB_FIRST_POS))
X#define UART_1_RX_CTRL_MSB_FIRST          ((uint32) ((uint32) 0x01u <<                                                                         UART_1_RX_CTRL_MSB_FIRST_POS))
N#define UART_1_RX_CTRL_LSB_FIRST          ((uint32) 0x00u)
N#define UART_1_RX_CTRL_MEDIAN             ((uint32) ((uint32) 0x01u << UART_1_RX_CTRL_MEDIAN_POS))
N#define UART_1_RX_CTRL_ENABLED            ((uint32) ((uint32) 0x01u << UART_1_RX_CTRL_ENABLED_POS))
N
N
N/* UART_1_RX_FIFO_CTRL_REG */
N#define UART_1_RX_FIFO_CTRL_TRIGGER_LEVEL_POS     (0u)   /* [2:0] Trigger level                            */
N#define UART_1_RX_FIFO_CTRL_CLEAR_POS             (16u)  /* [16]  Clear RX FIFO: claar after set           */
N#define UART_1_RX_FIFO_CTRL_FREEZE_POS            (17u)  /* [17]  Freeze RX FIFO: HW writes has not effect */
N#define UART_1_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK    ((uint32) 0x07u)
N#define UART_1_RX_FIFO_CTRL_CLEAR                 ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_RX_FIFO_CTRL_CLEAR_POS))
X#define UART_1_RX_FIFO_CTRL_CLEAR                 ((uint32) ((uint32) 0x01u <<                                                                     UART_1_RX_FIFO_CTRL_CLEAR_POS))
N#define UART_1_RX_FIFO_CTRL_FREEZE                ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_RX_FIFO_CTRL_FREEZE_POS))
X#define UART_1_RX_FIFO_CTRL_FREEZE                ((uint32) ((uint32) 0x01u <<                                                                     UART_1_RX_FIFO_CTRL_FREEZE_POS))
N
N
N/* UART_1_RX_FIFO_STATUS_REG */
N#define UART_1_RX_FIFO_STATUS_USED_POS    (0u)   /* [3:0]   Amount of entries in RX FIFO */
N#define UART_1_RX_FIFO_SR_VALID_POS       (15u)  /* [15]    Shifter status of RX FIFO    */
N#define UART_1_RX_FIFO_STATUS_RD_PTR_POS  (16u)  /* [18:16] RX FIFO read pointer         */
N#define UART_1_RX_FIFO_STATUS_WR_PTR_POS  (24u)  /* [26:24] RX FIFO write pointer        */
N#define UART_1_RX_FIFO_STATUS_USED_MASK   ((uint32) 0x0Fu)
N#define UART_1_RX_FIFO_SR_VALID           ((uint32) ((uint32) 0x01u << \
N                                                                  UART_1_RX_FIFO_SR_VALID_POS))
X#define UART_1_RX_FIFO_SR_VALID           ((uint32) ((uint32) 0x01u <<                                                                   UART_1_RX_FIFO_SR_VALID_POS))
N#define UART_1_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) ((uint32) 0x07u << \
N                                                                  UART_1_RX_FIFO_STATUS_RD_PTR_POS))
X#define UART_1_RX_FIFO_STATUS_RD_PTR_MASK ((uint32) ((uint32) 0x07u <<                                                                   UART_1_RX_FIFO_STATUS_RD_PTR_POS))
N#define UART_1_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) ((uint32) 0x07u << \
N                                                                  UART_1_RX_FIFO_STATUS_WR_PTR_POS))
X#define UART_1_RX_FIFO_STATUS_WR_PTR_MASK ((uint32) ((uint32) 0x07u <<                                                                   UART_1_RX_FIFO_STATUS_WR_PTR_POS))
N
N
N/* UART_1_RX_MATCH_REG */
N#define UART_1_RX_MATCH_ADDR_POS     (0u)  /* [7:0]   Slave address                        */
N#define UART_1_RX_MATCH_MASK_POS     (16u) /* [23:16] Slave address mask: 0 - doesn't care */
N#define UART_1_RX_MATCH_ADDR_MASK    ((uint32) 0xFFu)
N#define UART_1_RX_MATCH_MASK_MASK    ((uint32) ((uint32) 0xFFu << UART_1_RX_MATCH_MASK_POS))
N
N
N/* UART_1_RX_FIFO_WR_REG */
N#define UART_1_RX_FIFO_RD_POS    (0u)  /* [15:0] Data read from RX FIFO */
N#define UART_1_RX_FIFO_RD_MASK   ((uint32) 0xFFu)
N
N
N/* UART_1_RX_FIFO_RD_SILENT_REG */
N#define UART_1_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define UART_1_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* UART_1_RX_FIFO_RD_SILENT_REG */
N#define UART_1_RX_FIFO_RD_SILENT_POS     (0u)  /* [15:0] Data read from RX FIFO: not remove data from FIFO */
N#define UART_1_RX_FIFO_RD_SILENT_MASK    ((uint32) 0xFFu)
N
N/* UART_1_EZBUF_DATA_REG */
N#define UART_1_EZBUF_DATA_POS   (0u)  /* [7:0] Data from Ez Memory */
N#define UART_1_EZBUF_DATA_MASK  ((uint32) 0xFFu)
N
N/*  UART_1_INTR_CAUSE_REG */
N#define UART_1_INTR_CAUSE_MASTER_POS  (0u)  /* [0] Master interrupt active                 */
N#define UART_1_INTR_CAUSE_SLAVE_POS   (1u)  /* [1] Slave interrupt active                  */
N#define UART_1_INTR_CAUSE_TX_POS      (2u)  /* [2] Transmitter interrupt active            */
N#define UART_1_INTR_CAUSE_RX_POS      (3u)  /* [3] Receiver interrupt active               */
N#define UART_1_INTR_CAUSE_I2C_EC_POS  (4u)  /* [4] Externally clock I2C interrupt active   */
N#define UART_1_INTR_CAUSE_SPI_EC_POS  (5u)  /* [5] Externally clocked SPI interrupt active */
N#define UART_1_INTR_CAUSE_MASTER      ((uint32) 0x01u)
N#define UART_1_INTR_CAUSE_SLAVE       ((uint32) ((uint32) 0x01u << UART_1_INTR_CAUSE_SLAVE_POS))
N#define UART_1_INTR_CAUSE_TX          ((uint32) ((uint32) 0x01u << UART_1_INTR_CAUSE_TX_POS))
N#define UART_1_INTR_CAUSE_RX          ((uint32) ((uint32) 0x01u << UART_1_INTR_CAUSE_RX_POS))
N#define UART_1_INTR_CAUSE_I2C_EC      ((uint32) ((uint32) 0x01u << UART_1_INTR_CAUSE_I2C_EC_POS))
N#define UART_1_INTR_CAUSE_SPI_EC      ((uint32) ((uint32) 0x01u << UART_1_INTR_CAUSE_SPI_EC_POS))
N
N
N/* UART_1_INTR_SPI_EC_REG, UART_1_INTR_SPI_EC_MASK_REG, UART_1_INTR_SPI_EC_MASKED_REG */
N#define UART_1_INTR_SPI_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define UART_1_INTR_SPI_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define UART_1_INTR_SPI_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define UART_1_INTR_SPI_EC_WAKE_UP              ((uint32) 0x01u)
N#define UART_1_INTR_SPI_EC_EZBUF_STOP           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SPI_EC_EZBUF_STOP_POS))
X#define UART_1_INTR_SPI_EC_EZBUF_STOP           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SPI_EC_EZBUF_STOP_POS))
N#define UART_1_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SPI_EC_EZBUF_WRITE_STOP_POS))
X#define UART_1_INTR_SPI_EC_EZBUF_WRITE_STOP     ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SPI_EC_EZBUF_WRITE_STOP_POS))
N
N
N/* UART_1_INTR_I2C_EC, UART_1_INTR_I2C_EC_MASK, UART_1_INTR_I2C_EC_MASKED */
N#define UART_1_INTR_I2C_EC_WAKE_UP_POS          (0u)  /* [0] Address match: triggers wakeup of chip */
N#define UART_1_INTR_I2C_EC_EZBUF_STOP_POS       (1u)  /* [1] Externally clocked Stop detected       */
N#define UART_1_INTR_I2C_EC_EZBUF_WRITE_STOP_POS (2u)  /* [2] Externally clocked Write Stop detected */
N#define UART_1_INTR_I2C_EC_WAKE_UP              ((uint32) 0x01u)
N#define UART_1_INTR_I2C_EC_EZBUF_STOP           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_I2C_EC_EZBUF_STOP_POS))
X#define UART_1_INTR_I2C_EC_EZBUF_STOP           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_I2C_EC_EZBUF_STOP_POS))
N#define UART_1_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_I2C_EC_EZBUF_WRITE_STOP_POS))
X#define UART_1_INTR_I2C_EC_EZBUF_WRITE_STOP     ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_I2C_EC_EZBUF_WRITE_STOP_POS))
N
N
N/* UART_1_INTR_MASTER, UART_1_INTR_MASTER_SET,
N   UART_1_INTR_MASTER_MASK, UART_1_INTR_MASTER_MASKED */
N#define UART_1_INTR_MASTER_I2C_ARB_LOST_POS   (0u)  /* [0] Master lost arbitration                          */
N#define UART_1_INTR_MASTER_I2C_NACK_POS       (1u)  /* [1] Master receives NACK: address or write to slave  */
N#define UART_1_INTR_MASTER_I2C_ACK_POS        (2u)  /* [2] Master receives NACK: address or write to slave  */
N#define UART_1_INTR_MASTER_I2C_STOP_POS       (4u)  /* [4] Master detects the Stop: only self generated Stop*/
N#define UART_1_INTR_MASTER_I2C_BUS_ERROR_POS  (8u)  /* [8] Master detects bus error: misplaced Start or Stop*/
N#define UART_1_INTR_MASTER_SPI_DONE_POS       (9u)  /* [9] Master complete trasfer: Only for SPI            */
N#define UART_1_INTR_MASTER_I2C_ARB_LOST       ((uint32) 0x01u)
N#define UART_1_INTR_MASTER_I2C_NACK           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_MASTER_I2C_NACK_POS))
X#define UART_1_INTR_MASTER_I2C_NACK           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_MASTER_I2C_NACK_POS))
N#define UART_1_INTR_MASTER_I2C_ACK            ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_MASTER_I2C_ACK_POS))
X#define UART_1_INTR_MASTER_I2C_ACK            ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_MASTER_I2C_ACK_POS))
N#define UART_1_INTR_MASTER_I2C_STOP           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_MASTER_I2C_STOP_POS))
X#define UART_1_INTR_MASTER_I2C_STOP           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_MASTER_I2C_STOP_POS))
N#define UART_1_INTR_MASTER_I2C_BUS_ERROR      ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_MASTER_I2C_BUS_ERROR_POS))
X#define UART_1_INTR_MASTER_I2C_BUS_ERROR      ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_MASTER_I2C_BUS_ERROR_POS))
N#define UART_1_INTR_MASTER_SPI_DONE           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_MASTER_SPI_DONE_POS))
X#define UART_1_INTR_MASTER_SPI_DONE           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_MASTER_SPI_DONE_POS))
N
N/*
N* UART_1_INTR_SLAVE, UART_1_INTR_SLAVE_SET,
N* UART_1_INTR_SLAVE_MASK, UART_1_INTR_SLAVE_MASKED
N*/
N#define UART_1_INTR_SLAVE_I2C_ARB_LOST_POS         (0u)  /* [0]  Slave lost arbitration                   */
N#define UART_1_INTR_SLAVE_I2C_NACK_POS             (1u)  /* [1]  Slave receives NACK: master reads data   */
N#define UART_1_INTR_SLAVE_I2C_ACK_POS              (2u)  /* [2]  Slave receives ACK: master reads data    */
N#define UART_1_INTR_SLAVE_I2C_WRITE_STOP_POS       (3u)  /* [3]  Slave detects end of write transaction   */
N#define UART_1_INTR_SLAVE_I2C_STOP_POS             (4u)  /* [4]  Slave detects end of transaction intened */
N#define UART_1_INTR_SLAVE_I2C_START_POS            (5u)  /* [5]  Slave detects Start                      */
N#define UART_1_INTR_SLAVE_I2C_ADDR_MATCH_POS       (6u)  /* [6]  Slave address matches                    */
N#define UART_1_INTR_SLAVE_I2C_GENERAL_POS          (7u)  /* [7]  General call received                    */
N#define UART_1_INTR_SLAVE_I2C_BUS_ERROR_POS        (8u)  /* [8]  Slave detects bus error                  */
N#define UART_1_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS (9u)  /* [9]  Slave write complete: Only for SPI       */
N#define UART_1_INTR_SLAVE_SPI_EZBUF_STOP_POS       (10u) /* [10] Slave end of transaciton: Only for SPI   */
N#define UART_1_INTR_SLAVE_SPI_BUS_ERROR_POS        (11u) /* [11] Slave detects bus error: Only for SPI    */
N#define UART_1_INTR_SLAVE_I2C_ARB_LOST             ((uint32) 0x01u)
N#define UART_1_INTR_SLAVE_I2C_NACK                 ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_I2C_NACK_POS))
X#define UART_1_INTR_SLAVE_I2C_NACK                 ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_I2C_NACK_POS))
N#define UART_1_INTR_SLAVE_I2C_ACK                  ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_I2C_ACK_POS))
X#define UART_1_INTR_SLAVE_I2C_ACK                  ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_I2C_ACK_POS))
N#define UART_1_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_I2C_WRITE_STOP_POS))
X#define UART_1_INTR_SLAVE_I2C_WRITE_STOP           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_I2C_WRITE_STOP_POS))
N#define UART_1_INTR_SLAVE_I2C_STOP                 ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_I2C_STOP_POS))
X#define UART_1_INTR_SLAVE_I2C_STOP                 ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_I2C_STOP_POS))
N#define UART_1_INTR_SLAVE_I2C_START                ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_I2C_START_POS))
X#define UART_1_INTR_SLAVE_I2C_START                ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_I2C_START_POS))
N#define UART_1_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_I2C_ADDR_MATCH_POS))
X#define UART_1_INTR_SLAVE_I2C_ADDR_MATCH           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_I2C_ADDR_MATCH_POS))
N#define UART_1_INTR_SLAVE_I2C_GENERAL              ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_I2C_GENERAL_POS))
X#define UART_1_INTR_SLAVE_I2C_GENERAL              ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_I2C_GENERAL_POS))
N#define UART_1_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_I2C_BUS_ERROR_POS))
X#define UART_1_INTR_SLAVE_I2C_BUS_ERROR            ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_I2C_BUS_ERROR_POS))
N#define UART_1_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS))
X#define UART_1_INTR_SLAVE_SPI_EZBUF_WRITE_STOP     ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_SPI_EZBUF_WRITE_STOP_POS))
N#define UART_1_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_SPI_EZBUF_STOP_POS))
X#define UART_1_INTR_SLAVE_SPI_EZBUF_STOP           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_SPI_EZBUF_STOP_POS))
N#define UART_1_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) ((uint32) 0x01u << \
N                                                                    UART_1_INTR_SLAVE_SPI_BUS_ERROR_POS))
X#define UART_1_INTR_SLAVE_SPI_BUS_ERROR           ((uint32) ((uint32) 0x01u <<                                                                     UART_1_INTR_SLAVE_SPI_BUS_ERROR_POS))
N
N
N/*
N* UART_1_INTR_TX, UART_1_INTR_TX_SET,
N* UART_1_INTR_TX_MASK, UART_1_INTR_TX_MASKED
N*/
N#define UART_1_INTR_TX_TRIGGER_POS        (0u)  /* [0]  Trigger on TX FIFO entires                       */
N#define UART_1_INTR_TX_NOT_FULL_POS       (1u)  /* [1]  TX FIFO is not full                              */
N#define UART_1_INTR_TX_EMPTY_POS          (4u)  /* [4]  TX FIFO is empty                                 */
N#define UART_1_INTR_TX_OVERFLOW_POS       (5u)  /* [5]  Attempt to write to a full TX FIFO               */
N#define UART_1_INTR_TX_UNDERFLOW_POS      (6u)  /* [6]  Attempt to read from an empty TX FIFO            */
N#define UART_1_INTR_TX_BLOCKED_POS        (7u)  /* [7]  No access to the EZ memory                       */
N#define UART_1_INTR_TX_UART_NACK_POS      (8u)  /* [8]  UART transmitter received a NACK: SmartCard mode */
N#define UART_1_INTR_TX_UART_DONE_POS      (9u)  /* [9]  UART transmitter done even                       */
N#define UART_1_INTR_TX_UART_ARB_LOST_POS  (10u) /* [10] UART lost arbitration: LIN or SmartCard          */
N#define UART_1_INTR_TX_TRIGGER            ((uint32) 0x01u)
N#define UART_1_INTR_TX_NOT_FULL           ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_TX_NOT_FULL_POS))
X#define UART_1_INTR_TX_NOT_FULL           ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_TX_NOT_FULL_POS))
N#define UART_1_INTR_TX_EMPTY              ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_TX_EMPTY_POS))
X#define UART_1_INTR_TX_EMPTY              ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_TX_EMPTY_POS))
N#define UART_1_INTR_TX_OVERFLOW           ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_TX_OVERFLOW_POS))
X#define UART_1_INTR_TX_OVERFLOW           ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_TX_OVERFLOW_POS))
N#define UART_1_INTR_TX_UNDERFLOW          ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_TX_UNDERFLOW_POS))
X#define UART_1_INTR_TX_UNDERFLOW          ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_TX_UNDERFLOW_POS))
N#define UART_1_INTR_TX_BLOCKED            ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_TX_BLOCKED_POS))
X#define UART_1_INTR_TX_BLOCKED            ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_TX_BLOCKED_POS))
N#define UART_1_INTR_TX_UART_NACK          ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_TX_UART_NACK_POS))
X#define UART_1_INTR_TX_UART_NACK          ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_TX_UART_NACK_POS))
N#define UART_1_INTR_TX_UART_DONE          ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_TX_UART_DONE_POS))
X#define UART_1_INTR_TX_UART_DONE          ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_TX_UART_DONE_POS))
N#define UART_1_INTR_TX_UART_ARB_LOST      ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_TX_UART_ARB_LOST_POS))
X#define UART_1_INTR_TX_UART_ARB_LOST      ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_TX_UART_ARB_LOST_POS))
N
N
N/*
N* UART_1_INTR_RX, UART_1_INTR_RX_SET,
N* UART_1_INTR_RX_MASK, UART_1_INTR_RX_MASKED
N*/
N#define UART_1_INTR_RX_TRIGGER_POS        (0u)   /* [0]  Trigger on RX FIFO entires            */
N#define UART_1_INTR_RX_NOT_EMPTY_POS      (2u)   /* [2]  RX FIFO is not empty                  */
N#define UART_1_INTR_RX_FULL_POS           (3u)   /* [3]  RX FIFO is full                       */
N#define UART_1_INTR_RX_OVERFLOW_POS       (5u)   /* [5]  Attempt to write to a full RX FIFO    */
N#define UART_1_INTR_RX_UNDERFLOW_POS      (6u)   /* [6]  Attempt to read from an empty RX FIFO */
N#define UART_1_INTR_RX_BLOCKED_POS        (7u)   /* [7]  No access to the EZ memory            */
N#define UART_1_INTR_RX_FRAME_ERROR_POS    (8u)   /* [8]  Frame error in received data frame    */
N#define UART_1_INTR_RX_PARITY_ERROR_POS   (9u)   /* [9]  Parity error in received data frame   */
N#define UART_1_INTR_RX_BAUD_DETECT_POS    (10u)  /* [10] LIN baudrate detection is completed   */
N#define UART_1_INTR_RX_BREAK_DETECT_POS   (11u)  /* [11] Break detection is successful         */
N#define UART_1_INTR_RX_TRIGGER            ((uint32) 0x01u)
N#define UART_1_INTR_RX_NOT_EMPTY          ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_NOT_EMPTY_POS))
X#define UART_1_INTR_RX_NOT_EMPTY          ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_NOT_EMPTY_POS))
N#define UART_1_INTR_RX_FULL               ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_FULL_POS))
X#define UART_1_INTR_RX_FULL               ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_FULL_POS))
N#define UART_1_INTR_RX_OVERFLOW           ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_OVERFLOW_POS))
X#define UART_1_INTR_RX_OVERFLOW           ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_OVERFLOW_POS))
N#define UART_1_INTR_RX_UNDERFLOW          ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_UNDERFLOW_POS))
X#define UART_1_INTR_RX_UNDERFLOW          ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_UNDERFLOW_POS))
N#define UART_1_INTR_RX_BLOCKED            ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_BLOCKED_POS))
X#define UART_1_INTR_RX_BLOCKED            ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_BLOCKED_POS))
N#define UART_1_INTR_RX_FRAME_ERROR        ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_FRAME_ERROR_POS))
X#define UART_1_INTR_RX_FRAME_ERROR        ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_FRAME_ERROR_POS))
N#define UART_1_INTR_RX_PARITY_ERROR       ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_PARITY_ERROR_POS))
X#define UART_1_INTR_RX_PARITY_ERROR       ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_PARITY_ERROR_POS))
N#define UART_1_INTR_RX_BAUD_DETECT        ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_BAUD_DETECT_POS))
X#define UART_1_INTR_RX_BAUD_DETECT        ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_BAUD_DETECT_POS))
N#define UART_1_INTR_RX_BREAK_DETECT       ((uint32) ((uint32) 0x01u << \
N                                                                        UART_1_INTR_RX_BREAK_DETECT_POS))
X#define UART_1_INTR_RX_BREAK_DETECT       ((uint32) ((uint32) 0x01u <<                                                                         UART_1_INTR_RX_BREAK_DETECT_POS))
N
N
N/* Define all interupt soureces */
N#define UART_1_INTR_I2C_EC_ALL    (UART_1_INTR_I2C_EC_WAKE_UP    | \
N                                             UART_1_INTR_I2C_EC_EZBUF_STOP | \
N                                             UART_1_INTR_I2C_EC_EZBUF_WRITE_STOP)
X#define UART_1_INTR_I2C_EC_ALL    (UART_1_INTR_I2C_EC_WAKE_UP    |                                              UART_1_INTR_I2C_EC_EZBUF_STOP |                                              UART_1_INTR_I2C_EC_EZBUF_WRITE_STOP)
N
N#define UART_1_INTR_SPI_EC_ALL    (UART_1_INTR_SPI_EC_WAKE_UP    | \
N                                             UART_1_INTR_SPI_EC_EZBUF_STOP | \
N                                             UART_1_INTR_SPI_EC_EZBUF_WRITE_STOP)
X#define UART_1_INTR_SPI_EC_ALL    (UART_1_INTR_SPI_EC_WAKE_UP    |                                              UART_1_INTR_SPI_EC_EZBUF_STOP |                                              UART_1_INTR_SPI_EC_EZBUF_WRITE_STOP)
N
N#define UART_1_INTR_MASTER_ALL    (UART_1_INTR_MASTER_I2C_ARB_LOST  | \
N                                             UART_1_INTR_MASTER_I2C_NACK      | \
N                                             UART_1_INTR_MASTER_I2C_ACK       | \
N                                             UART_1_INTR_MASTER_I2C_STOP      | \
N                                             UART_1_INTR_MASTER_I2C_BUS_ERROR | \
N                                             UART_1_INTR_MASTER_SPI_DONE )
X#define UART_1_INTR_MASTER_ALL    (UART_1_INTR_MASTER_I2C_ARB_LOST  |                                              UART_1_INTR_MASTER_I2C_NACK      |                                              UART_1_INTR_MASTER_I2C_ACK       |                                              UART_1_INTR_MASTER_I2C_STOP      |                                              UART_1_INTR_MASTER_I2C_BUS_ERROR |                                              UART_1_INTR_MASTER_SPI_DONE )
N
N#define UART_1_INTR_SLAVE_ALL     (UART_1_INTR_SLAVE_I2C_ARB_LOST      | \
N                                             UART_1_INTR_SLAVE_I2C_NACK          | \
N                                             UART_1_INTR_SLAVE_I2C_ACK           | \
N                                             UART_1_INTR_SLAVE_I2C_WRITE_STOP    | \
N                                             UART_1_INTR_SLAVE_I2C_STOP          | \
N                                             UART_1_INTR_SLAVE_I2C_START         | \
N                                             UART_1_INTR_SLAVE_I2C_ADDR_MATCH    | \
N                                             UART_1_INTR_SLAVE_I2C_GENERAL       | \
N                                             UART_1_INTR_SLAVE_I2C_BUS_ERROR     | \
N                                             UART_1_INTR_SLAVE_SPI_EZBUF_WRITE_STOP | \
N                                             UART_1_INTR_SLAVE_SPI_EZBUF_STOP       | \
N                                             UART_1_INTR_SLAVE_SPI_BUS_ERROR)
X#define UART_1_INTR_SLAVE_ALL     (UART_1_INTR_SLAVE_I2C_ARB_LOST      |                                              UART_1_INTR_SLAVE_I2C_NACK          |                                              UART_1_INTR_SLAVE_I2C_ACK           |                                              UART_1_INTR_SLAVE_I2C_WRITE_STOP    |                                              UART_1_INTR_SLAVE_I2C_STOP          |                                              UART_1_INTR_SLAVE_I2C_START         |                                              UART_1_INTR_SLAVE_I2C_ADDR_MATCH    |                                              UART_1_INTR_SLAVE_I2C_GENERAL       |                                              UART_1_INTR_SLAVE_I2C_BUS_ERROR     |                                              UART_1_INTR_SLAVE_SPI_EZBUF_WRITE_STOP |                                              UART_1_INTR_SLAVE_SPI_EZBUF_STOP       |                                              UART_1_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define UART_1_INTR_TX_ALL        (UART_1_INTR_TX_TRIGGER   | \
N                                             UART_1_INTR_TX_NOT_FULL  | \
N                                             UART_1_INTR_TX_EMPTY     | \
N                                             UART_1_INTR_TX_OVERFLOW  | \
N                                             UART_1_INTR_TX_UNDERFLOW | \
N                                             UART_1_INTR_TX_BLOCKED   | \
N                                             UART_1_INTR_TX_UART_NACK | \
N                                             UART_1_INTR_TX_UART_DONE | \
N                                             UART_1_INTR_TX_UART_ARB_LOST)
X#define UART_1_INTR_TX_ALL        (UART_1_INTR_TX_TRIGGER   |                                              UART_1_INTR_TX_NOT_FULL  |                                              UART_1_INTR_TX_EMPTY     |                                              UART_1_INTR_TX_OVERFLOW  |                                              UART_1_INTR_TX_UNDERFLOW |                                              UART_1_INTR_TX_BLOCKED   |                                              UART_1_INTR_TX_UART_NACK |                                              UART_1_INTR_TX_UART_DONE |                                              UART_1_INTR_TX_UART_ARB_LOST)
N
N#define UART_1_INTR_RX_ALL        (UART_1_INTR_RX_TRIGGER      | \
N                                             UART_1_INTR_RX_NOT_EMPTY    | \
N                                             UART_1_INTR_RX_FULL         | \
N                                             UART_1_INTR_RX_OVERFLOW     | \
N                                             UART_1_INTR_RX_UNDERFLOW    | \
N                                             UART_1_INTR_RX_BLOCKED      | \
N                                             UART_1_INTR_RX_FRAME_ERROR  | \
N                                             UART_1_INTR_RX_PARITY_ERROR | \
N                                             UART_1_INTR_RX_BAUD_DETECT  | \
N                                             UART_1_INTR_RX_BREAK_DETECT)
X#define UART_1_INTR_RX_ALL        (UART_1_INTR_RX_TRIGGER      |                                              UART_1_INTR_RX_NOT_EMPTY    |                                              UART_1_INTR_RX_FULL         |                                              UART_1_INTR_RX_OVERFLOW     |                                              UART_1_INTR_RX_UNDERFLOW    |                                              UART_1_INTR_RX_BLOCKED      |                                              UART_1_INTR_RX_FRAME_ERROR  |                                              UART_1_INTR_RX_PARITY_ERROR |                                              UART_1_INTR_RX_BAUD_DETECT  |                                              UART_1_INTR_RX_BREAK_DETECT)
N
N/* General usage HW definitions */
N#define UART_1_ONE_BYTE_WIDTH (8u)   /* Number of bits in one byte           */
N#define UART_1_FIFO_SIZE      (8u)   /* Size of TX or RX FIFO: defined by HW */
N#define UART_1_EZBUFFER_SIZE  (32u)  /* EZ Buffer size: defined by HW        */
N
N/* I2C and EZI2C slave address defines */
N#define UART_1_I2C_SLAVE_ADDR_POS    (0x01u)    /* 7-bit address shift */
N#define UART_1_I2C_SLAVE_ADDR_MASK   (0xFEu)    /* 8-bit address mask */
N
N/* OVS constants for IrDA Low Power operation */
N#define UART_1_CTRL_OVS_IRDA_LP_OVS16     (0x00u)
N#define UART_1_CTRL_OVS_IRDA_LP_OVS32     (0x01u)
N#define UART_1_CTRL_OVS_IRDA_LP_OVS48     (0x02u)
N#define UART_1_CTRL_OVS_IRDA_LP_OVS96     (0x03u)
N#define UART_1_CTRL_OVS_IRDA_LP_OVS192    (0x04u)
N#define UART_1_CTRL_OVS_IRDA_LP_OVS768    (0x05u)
N#define UART_1_CTRL_OVS_IRDA_LP_OVS1536   (0x06u)
N
N/* OVS constant for IrDA */
N#define UART_1_CTRL_OVS_IRDA_OVS16        (UART_1_UART_IRDA_LP_OVS16)
N
N
N/***************************************
N*    SCB Common Macro Definitions
N***************************************/
N
N/*
N* Re-enables SCB IP: this cause partial reset of IP: state, status, TX and RX FIFOs.
N* The triggered interrupts remains set.
N*/
N#define UART_1_SCB_SW_RESET \
N                        do{ \
N                            UART_1_CTRL_REG &= ((uint32) ~UART_1_CTRL_ENABLED ); \
N                            UART_1_CTRL_REG |= ((uint32)  UART_1_CTRL_ENABLED ); \
N                        }while(0)
X#define UART_1_SCB_SW_RESET                         do{                             UART_1_CTRL_REG &= ((uint32) ~UART_1_CTRL_ENABLED );                             UART_1_CTRL_REG |= ((uint32)  UART_1_CTRL_ENABLED );                         }while(0)
N
N/* TX FIFO macro */
N#define UART_1_CLEAR_TX_FIFO \
N                            do{        \
N                                UART_1_TX_FIFO_CTRL_REG |= ((uint32)  UART_1_TX_FIFO_CTRL_CLEAR); \
N                                UART_1_TX_FIFO_CTRL_REG &= ((uint32) ~UART_1_TX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define UART_1_CLEAR_TX_FIFO                             do{                                        UART_1_TX_FIFO_CTRL_REG |= ((uint32)  UART_1_TX_FIFO_CTRL_CLEAR);                                 UART_1_TX_FIFO_CTRL_REG &= ((uint32) ~UART_1_TX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define UART_1_GET_TX_FIFO_ENTRIES    (UART_1_TX_FIFO_STATUS_REG & \
N                                                 UART_1_TX_FIFO_STATUS_USED_MASK)
X#define UART_1_GET_TX_FIFO_ENTRIES    (UART_1_TX_FIFO_STATUS_REG &                                                  UART_1_TX_FIFO_STATUS_USED_MASK)
N
N#define UART_1_GET_TX_FIFO_SR_VALID   ((0u != (UART_1_TX_FIFO_STATUS_REG & \
N                                                         UART_1_TX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define UART_1_GET_TX_FIFO_SR_VALID   ((0u != (UART_1_TX_FIFO_STATUS_REG &                                                          UART_1_TX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* RX FIFO macro */
N#define UART_1_CLEAR_RX_FIFO \
N                            do{        \
N                                UART_1_RX_FIFO_CTRL_REG |= ((uint32)  UART_1_RX_FIFO_CTRL_CLEAR); \
N                                UART_1_RX_FIFO_CTRL_REG &= ((uint32) ~UART_1_RX_FIFO_CTRL_CLEAR); \
N                            }while(0)
X#define UART_1_CLEAR_RX_FIFO                             do{                                        UART_1_RX_FIFO_CTRL_REG |= ((uint32)  UART_1_RX_FIFO_CTRL_CLEAR);                                 UART_1_RX_FIFO_CTRL_REG &= ((uint32) ~UART_1_RX_FIFO_CTRL_CLEAR);                             }while(0)
N
N#define UART_1_GET_RX_FIFO_ENTRIES    (UART_1_RX_FIFO_STATUS_REG & \
N                                                    UART_1_RX_FIFO_STATUS_USED_MASK)
X#define UART_1_GET_RX_FIFO_ENTRIES    (UART_1_RX_FIFO_STATUS_REG &                                                     UART_1_RX_FIFO_STATUS_USED_MASK)
N
N#define UART_1_GET_RX_FIFO_SR_VALID   ((0u != (UART_1_RX_FIFO_STATUS_REG & \
N                                                         UART_1_RX_FIFO_SR_VALID)) ? (1u) : (0u))
X#define UART_1_GET_RX_FIFO_SR_VALID   ((0u != (UART_1_RX_FIFO_STATUS_REG &                                                          UART_1_RX_FIFO_SR_VALID)) ? (1u) : (0u))
N
N/* Writes interrupt source: set sourceMask bits in UART_1_INTR_X_MASK_REG */
N#define UART_1_WRITE_INTR_I2C_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_1_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_WRITE_INTR_I2C_EC_MASK(sourceMask)                                                 do{                                                             UART_1_INTR_I2C_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_WRITE_INTR_SPI_EC_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_1_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_WRITE_INTR_SPI_EC_MASK(sourceMask)                                                 do{                                                             UART_1_INTR_SPI_EC_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_WRITE_INTR_MASTER_MASK(sourceMask) \
N                                                do{         \
N                                                    UART_1_INTR_MASTER_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_WRITE_INTR_MASTER_MASK(sourceMask)                                                 do{                                                             UART_1_INTR_MASTER_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_WRITE_INTR_SLAVE_MASK(sourceMask)  \
N                                                do{         \
N                                                    UART_1_INTR_SLAVE_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_WRITE_INTR_SLAVE_MASK(sourceMask)                                                  do{                                                             UART_1_INTR_SLAVE_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_WRITE_INTR_TX_MASK(sourceMask)     \
N                                                do{         \
N                                                    UART_1_INTR_TX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_WRITE_INTR_TX_MASK(sourceMask)                                                     do{                                                             UART_1_INTR_TX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_WRITE_INTR_RX_MASK(sourceMask)     \
N                                                do{         \
N                                                    UART_1_INTR_RX_MASK_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_WRITE_INTR_RX_MASK(sourceMask)                                                     do{                                                             UART_1_INTR_RX_MASK_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Enables interrupt source: set sourceMask bits in UART_1_INTR_X_MASK_REG */
N#define UART_1_ENABLE_INTR_I2C_EC(sourceMask) \
N                                                do{     \
N                                                    UART_1_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_ENABLE_INTR_I2C_EC(sourceMask)                                                 do{                                                         UART_1_INTR_I2C_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_ENABLE_INTR_SPI_EC(sourceMask) \
N                                                do{     \
N                                                    UART_1_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_ENABLE_INTR_SPI_EC(sourceMask)                                                 do{                                                         UART_1_INTR_SPI_EC_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_ENABLE_INTR_MASTER(sourceMask) \
N                                                do{     \
N                                                    UART_1_INTR_MASTER_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_ENABLE_INTR_MASTER(sourceMask)                                                 do{                                                         UART_1_INTR_MASTER_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_ENABLE_INTR_SLAVE(sourceMask)  \
N                                                do{     \
N                                                    UART_1_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_ENABLE_INTR_SLAVE(sourceMask)                                                  do{                                                         UART_1_INTR_SLAVE_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_ENABLE_INTR_TX(sourceMask)     \
N                                                do{     \
N                                                    UART_1_INTR_TX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_ENABLE_INTR_TX(sourceMask)                                                     do{                                                         UART_1_INTR_TX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_ENABLE_INTR_RX(sourceMask)     \
N                                                do{     \
N                                                    UART_1_INTR_RX_MASK_REG |= (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_ENABLE_INTR_RX(sourceMask)                                                     do{                                                         UART_1_INTR_RX_MASK_REG |= (uint32) (sourceMask);                                                 }while(0)
N
N/* Disables interrupt source: clear sourceMask bits in UART_1_INTR_X_MASK_REG */
N#define UART_1_DISABLE_INTR_I2C_EC(sourceMask) \
N                                do{                      \
N                                    UART_1_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_1_DISABLE_INTR_I2C_EC(sourceMask)                                 do{                                                          UART_1_INTR_I2C_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_1_DISABLE_INTR_SPI_EC(sourceMask) \
N                                do{                      \
N                                    UART_1_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X#define UART_1_DISABLE_INTR_SPI_EC(sourceMask)                                 do{                                                          UART_1_INTR_SPI_EC_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N
N#define UART_1_DISABLE_INTR_MASTER(sourceMask) \
N                                do{                      \
N                                UART_1_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_1_DISABLE_INTR_MASTER(sourceMask)                                 do{                                                      UART_1_INTR_MASTER_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_1_DISABLE_INTR_SLAVE(sourceMask) \
N                                do{                     \
N                                    UART_1_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_1_DISABLE_INTR_SLAVE(sourceMask)                                 do{                                                         UART_1_INTR_SLAVE_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N#define UART_1_DISABLE_INTR_TX(sourceMask)    \
N                                do{                     \
N                                    UART_1_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                 }while(0)
X#define UART_1_DISABLE_INTR_TX(sourceMask)                                    do{                                                         UART_1_INTR_TX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                  }while(0)
N
N#define UART_1_DISABLE_INTR_RX(sourceMask)    \
N                                do{                     \
N                                    UART_1_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask))); \
N                                }while(0)
X#define UART_1_DISABLE_INTR_RX(sourceMask)                                    do{                                                         UART_1_INTR_RX_MASK_REG &= ((uint32) ~((uint32) (sourceMask)));                                 }while(0)
N
N/* Sets interrupt sources: write sourceMask bits in UART_1_INTR_X_SET_REG */
N#define UART_1_SET_INTR_MASTER(sourceMask)    \
N                                                do{     \
N                                                    UART_1_INTR_MASTER_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_SET_INTR_MASTER(sourceMask)                                                    do{                                                         UART_1_INTR_MASTER_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_SET_INTR_SLAVE(sourceMask) \
N                                                do{ \
N                                                    UART_1_INTR_SLAVE_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_SET_INTR_SLAVE(sourceMask)                                                 do{                                                     UART_1_INTR_SLAVE_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_SET_INTR_TX(sourceMask)    \
N                                                do{ \
N                                                    UART_1_INTR_TX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_SET_INTR_TX(sourceMask)                                                    do{                                                     UART_1_INTR_TX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_SET_INTR_RX(sourceMask)    \
N                                                do{ \
N                                                    UART_1_INTR_RX_SET_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_SET_INTR_RX(sourceMask)                                                    do{                                                     UART_1_INTR_RX_SET_REG = (uint32) (sourceMask);                                                 }while(0)
N
N/* Clears interrupt sources: write sourceMask bits in UART_1_INTR_X_REG */
N#define UART_1_CLEAR_INTR_I2C_EC(sourceMask)  \
N                                                do{     \
N                                                    UART_1_INTR_I2C_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_CLEAR_INTR_I2C_EC(sourceMask)                                                  do{                                                         UART_1_INTR_I2C_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_CLEAR_INTR_SPI_EC(sourceMask)  \
N                                                do{     \
N                                                    UART_1_INTR_SPI_EC_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_CLEAR_INTR_SPI_EC(sourceMask)                                                  do{                                                         UART_1_INTR_SPI_EC_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_CLEAR_INTR_MASTER(sourceMask)  \
N                                                do{     \
N                                                    UART_1_INTR_MASTER_REG = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_CLEAR_INTR_MASTER(sourceMask)                                                  do{                                                         UART_1_INTR_MASTER_REG = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_CLEAR_INTR_SLAVE(sourceMask)   \
N                                                do{     \
N                                                    UART_1_INTR_SLAVE_REG  = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_CLEAR_INTR_SLAVE(sourceMask)                                                   do{                                                         UART_1_INTR_SLAVE_REG  = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_CLEAR_INTR_TX(sourceMask)      \
N                                                do{     \
N                                                    UART_1_INTR_TX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_CLEAR_INTR_TX(sourceMask)                                                      do{                                                         UART_1_INTR_TX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N#define UART_1_CLEAR_INTR_RX(sourceMask)      \
N                                                do{     \
N                                                    UART_1_INTR_RX_REG     = (uint32) (sourceMask); \
N                                                }while(0)
X#define UART_1_CLEAR_INTR_RX(sourceMask)                                                      do{                                                         UART_1_INTR_RX_REG     = (uint32) (sourceMask);                                                 }while(0)
N
N/* Return true if sourceMask is set in UART_1_INTR_CAUSE_REG */
N#define UART_1_CHECK_CAUSE_INTR(sourceMask)    (0u != (UART_1_INTR_CAUSE_REG & (sourceMask)))
N
N/* Return true if sourceMask is set in  INTR_X_MASKED_REG */
N#define UART_1_CHECK_INTR_EC_I2C(sourceMask)  (0u != (UART_1_INTR_I2C_EC_REG & (sourceMask)))
N#define UART_1_CHECK_INTR_EC_SPI(sourceMask)  (0u != (UART_1_INTR_SPI_EC_REG & (sourceMask)))
N#define UART_1_CHECK_INTR_MASTER(sourceMask)  (0u != (UART_1_INTR_MASTER_REG & (sourceMask)))
N#define UART_1_CHECK_INTR_SLAVE(sourceMask)   (0u != (UART_1_INTR_SLAVE_REG  & (sourceMask)))
N#define UART_1_CHECK_INTR_TX(sourceMask)      (0u != (UART_1_INTR_TX_REG     & (sourceMask)))
N#define UART_1_CHECK_INTR_RX(sourceMask)      (0u != (UART_1_INTR_RX_REG     & (sourceMask)))
N
N/* Return true if sourceMask is set in UART_1_INTR_X_MASKED_REG */
N#define UART_1_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (UART_1_INTR_I2C_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_1_CHECK_INTR_I2C_EC_MASKED(sourceMask)   (0u != (UART_1_INTR_I2C_EC_MASKED_REG &                                                                        (sourceMask)))
N#define UART_1_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (UART_1_INTR_SPI_EC_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_1_CHECK_INTR_SPI_EC_MASKED(sourceMask)   (0u != (UART_1_INTR_SPI_EC_MASKED_REG &                                                                        (sourceMask)))
N#define UART_1_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (UART_1_INTR_MASTER_MASKED_REG & \
N                                                                       (sourceMask)))
X#define UART_1_CHECK_INTR_MASTER_MASKED(sourceMask)   (0u != (UART_1_INTR_MASTER_MASKED_REG &                                                                        (sourceMask)))
N#define UART_1_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (UART_1_INTR_SLAVE_MASKED_REG  & \
N                                                                       (sourceMask)))
X#define UART_1_CHECK_INTR_SLAVE_MASKED(sourceMask)    (0u != (UART_1_INTR_SLAVE_MASKED_REG  &                                                                        (sourceMask)))
N#define UART_1_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (UART_1_INTR_TX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define UART_1_CHECK_INTR_TX_MASKED(sourceMask)       (0u != (UART_1_INTR_TX_MASKED_REG     &                                                                        (sourceMask)))
N#define UART_1_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (UART_1_INTR_RX_MASKED_REG     & \
N                                                                       (sourceMask)))
X#define UART_1_CHECK_INTR_RX_MASKED(sourceMask)       (0u != (UART_1_INTR_RX_MASKED_REG     &                                                                        (sourceMask)))
N
N/* Return true if sourceMask is set in UART_1_CTRL_REG: generaly is used to check enable bit */
N#define UART_1_GET_CTRL_ENABLED    (0u != (UART_1_CTRL_REG & UART_1_CTRL_ENABLED))
N
N#define UART_1_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (UART_1_I2C_CTRL_REG & \
N                                                                UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK))
X#define UART_1_CHECK_SLAVE_AUTO_ADDR_NACK     (0u != (UART_1_I2C_CTRL_REG &                                                                 UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK))
N
N
N/***************************************
N*      I2C Macro Definitions
N***************************************/
N
N/* Enable auto ACK/NACK */
N#define UART_1_ENABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                      \
N                                UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_ENABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                      UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_1_ENABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                     \
N                                UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define UART_1_ENABLE_SLAVE_AUTO_DATA_ACK                             do{                                                     UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define UART_1_ENABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                      \
N                                UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_ENABLE_SLAVE_AUTO_DATA_NACK                             do{                                                      UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_1_ENABLE_MASTER_AUTO_DATA_ACK \
N                            do{                      \
N                                UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define UART_1_ENABLE_MASTER_AUTO_DATA_ACK                             do{                                                      UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define UART_1_ENABLE_MASTER_AUTO_DATA_NACK \
N                            do{                       \
N                                UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_ENABLE_MASTER_AUTO_DATA_NACK                             do{                                                       UART_1_I2C_CTRL_REG |= UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Disable auto ACK/NACK */
N#define UART_1_DISABLE_SLAVE_AUTO_ADDR_NACK \
N                            do{                       \
N                                UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_DISABLE_SLAVE_AUTO_ADDR_NACK                             do{                                                       UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_1_DISABLE_SLAVE_AUTO_DATA_ACK \
N                            do{                      \
N                                UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_S_READY_DATA_ACK; \
N                            }while(0)
X#define UART_1_DISABLE_SLAVE_AUTO_DATA_ACK                             do{                                                      UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_S_READY_DATA_ACK;                             }while(0)
N
N#define UART_1_DISABLE_SLAVE_AUTO_DATA_NACK \
N                            do{                       \
N                                UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_DISABLE_SLAVE_AUTO_DATA_NACK                             do{                                                       UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK;                             }while(0)
N
N#define UART_1_DISABLE_MASTER_AUTO_DATA_ACK \
N                            do{                       \
N                                UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_M_READY_DATA_ACK; \
N                            }while(0)
X#define UART_1_DISABLE_MASTER_AUTO_DATA_ACK                             do{                                                       UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_M_READY_DATA_ACK;                             }while(0)
N
N#define UART_1_DISABLE_MASTER_AUTO_DATA_NACK \
N                            do{                        \
N                                UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK; \
N                            }while(0)
X#define UART_1_DISABLE_MASTER_AUTO_DATA_NACK                             do{                                                        UART_1_I2C_CTRL_REG &= ~UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK;                             }while(0)
N
N/* Enable Slave autoACK/NACK Data */
N#define UART_1_ENABLE_SLAVE_AUTO_DATA \
N                            do{                 \
N                                UART_1_I2C_CTRL_REG |= (UART_1_I2C_CTRL_S_READY_DATA_ACK |      \
N                                                                  UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK); \
N                            }while(0)
X#define UART_1_ENABLE_SLAVE_AUTO_DATA                             do{                                                 UART_1_I2C_CTRL_REG |= (UART_1_I2C_CTRL_S_READY_DATA_ACK |                                                                        UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK);                             }while(0)
N
N/* Disable Slave autoACK/NACK Data */
N#define UART_1_DISABLE_SLAVE_AUTO_DATA \
N                            do{                  \
N                                UART_1_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(UART_1_I2C_CTRL_S_READY_DATA_ACK |       \
N                                                                    UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define UART_1_DISABLE_SLAVE_AUTO_DATA                             do{                                                  UART_1_I2C_CTRL_REG &= ((uint32)                                                                   ~(UART_1_I2C_CTRL_S_READY_DATA_ACK |                                                                           UART_1_I2C_CTRL_S_NOT_READY_DATA_NACK));                             }while(0)
N
N/* Disable Master autoACK/NACK Data */
N#define UART_1_DISABLE_MASTER_AUTO_DATA \
N                            do{                   \
N                                UART_1_I2C_CTRL_REG &= ((uint32) \
N                                                                  ~(UART_1_I2C_CTRL_M_READY_DATA_ACK |       \
N                                                                    UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK)); \
N                            }while(0)
X#define UART_1_DISABLE_MASTER_AUTO_DATA                             do{                                                   UART_1_I2C_CTRL_REG &= ((uint32)                                                                   ~(UART_1_I2C_CTRL_M_READY_DATA_ACK |                                                                           UART_1_I2C_CTRL_M_NOT_READY_DATA_NACK));                             }while(0)
N
N/* Master commands */
N#define UART_1_I2C_MASTER_GENERATE_START \
N                            do{                    \
N                                UART_1_I2C_MASTER_CMD_REG = UART_1_I2C_MASTER_CMD_M_START_ON_IDLE; \
N                            }while(0)
X#define UART_1_I2C_MASTER_GENERATE_START                             do{                                                    UART_1_I2C_MASTER_CMD_REG = UART_1_I2C_MASTER_CMD_M_START_ON_IDLE;                             }while(0)
N
N#define UART_1_I2C_MASTER_CLEAR_START \
N                            do{                 \
N                                UART_1_I2C_MASTER_CMD_REG =  ((uint32) 0u); \
N                            }while(0)
X#define UART_1_I2C_MASTER_CLEAR_START                             do{                                                 UART_1_I2C_MASTER_CMD_REG =  ((uint32) 0u);                             }while(0)
N
N#define UART_1_I2C_MASTER_GENERATE_RESTART UART_1_I2CReStartGeneration()
N
N#define UART_1_I2C_MASTER_GENERATE_STOP \
N                            do{                   \
N                                UART_1_I2C_MASTER_CMD_REG =                                            \
N                                    (UART_1_I2C_MASTER_CMD_M_STOP |                                    \
N                                        (UART_1_CHECK_I2C_STATUS(UART_1_I2C_STATUS_M_READ) ? \
N                                            (UART_1_I2C_MASTER_CMD_M_NACK) : (0u)));                   \
N                            }while(0)
X#define UART_1_I2C_MASTER_GENERATE_STOP                             do{                                                   UART_1_I2C_MASTER_CMD_REG =                                                                                (UART_1_I2C_MASTER_CMD_M_STOP |                                                                            (UART_1_CHECK_I2C_STATUS(UART_1_I2C_STATUS_M_READ) ?                                             (UART_1_I2C_MASTER_CMD_M_NACK) : (0u)));                                               }while(0)
N
N#define UART_1_I2C_MASTER_GENERATE_ACK \
N                            do{                  \
N                                UART_1_I2C_MASTER_CMD_REG = UART_1_I2C_MASTER_CMD_M_ACK; \
N                            }while(0)
X#define UART_1_I2C_MASTER_GENERATE_ACK                             do{                                                  UART_1_I2C_MASTER_CMD_REG = UART_1_I2C_MASTER_CMD_M_ACK;                             }while(0)
N
N#define UART_1_I2C_MASTER_GENERATE_NACK \
N                            do{                   \
N                                UART_1_I2C_MASTER_CMD_REG = UART_1_I2C_MASTER_CMD_M_NACK; \
N                            }while(0)
X#define UART_1_I2C_MASTER_GENERATE_NACK                             do{                                                   UART_1_I2C_MASTER_CMD_REG = UART_1_I2C_MASTER_CMD_M_NACK;                             }while(0)
N
N/* Slave comamnds */
N#define UART_1_I2C_SLAVE_GENERATE_ACK \
N                            do{                 \
N                                UART_1_I2C_SLAVE_CMD_REG = UART_1_I2C_SLAVE_CMD_S_ACK; \
N                            }while(0)
X#define UART_1_I2C_SLAVE_GENERATE_ACK                             do{                                                 UART_1_I2C_SLAVE_CMD_REG = UART_1_I2C_SLAVE_CMD_S_ACK;                             }while(0)
N
N#define UART_1_I2C_SLAVE_GENERATE_NACK \
N                            do{                  \
N                                UART_1_I2C_SLAVE_CMD_REG = UART_1_I2C_SLAVE_CMD_S_NACK; \
N                            }while(0)
X#define UART_1_I2C_SLAVE_GENERATE_NACK                             do{                                                  UART_1_I2C_SLAVE_CMD_REG = UART_1_I2C_SLAVE_CMD_S_NACK;                             }while(0)
N
N
N/* Return 8-bit address. The input address should be 7-bits */
N#define UART_1_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) << \
N                                                                    UART_1_I2C_SLAVE_ADDR_POS)) & \
N                                                                        UART_1_I2C_SLAVE_ADDR_MASK)
X#define UART_1_GET_I2C_8BIT_ADDRESS(addr) (((uint32) ((uint32) (addr) <<                                                                     UART_1_I2C_SLAVE_ADDR_POS)) &                                                                         UART_1_I2C_SLAVE_ADDR_MASK)
N
N#define UART_1_GET_I2C_7BIT_ADDRESS(addr) ((uint32) (addr) >> UART_1_I2C_SLAVE_ADDR_POS)
N
N
N/* Adjust SDA filter Trim settings */
N#define UART_1_DEFAULT_I2C_CFG_SDA_FILT_TRIM  (0x02u)
N#define UART_1_EC_AM_I2C_CFG_SDA_FILT_TRIM    (0x03u)
N
N#define UART_1_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim) \
N        do{                                                 \
N            UART_1_I2C_CFG_REG =                  \
N                            ((UART_1_I2C_CFG_REG & (uint32) ~UART_1_I2C_CFG_SDA_FILT_TRIM_MASK) | \
N                             ((uint32) ((uint32) (sdaTrim) <<UART_1_I2C_CFG_SDA_FILT_TRIM_POS)));           \
N        }while(0)
X#define UART_1_SET_I2C_CFG_SDA_FILT_TRIM(sdaTrim)         do{                                                             UART_1_I2C_CFG_REG =                                              ((UART_1_I2C_CFG_REG & (uint32) ~UART_1_I2C_CFG_SDA_FILT_TRIM_MASK) |                              ((uint32) ((uint32) (sdaTrim) <<UART_1_I2C_CFG_SDA_FILT_TRIM_POS)));                   }while(0)
N
N/* Returns slave select number in SPI_CTRL */
N#define UART_1_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) << \
N                                                                    UART_1_SPI_CTRL_SLAVE_SELECT_POS)) & \
N                                                                        UART_1_SPI_CTRL_SLAVE_SELECT_MASK)
X#define UART_1_GET_SPI_CTRL_SS(activeSelect) (((uint32) ((uint32) (activeSelect) <<                                                                     UART_1_SPI_CTRL_SLAVE_SELECT_POS)) &                                                                         UART_1_SPI_CTRL_SLAVE_SELECT_MASK)
N
N/* Returns true if bit is set in UART_1_I2C_STATUS_REG */
N#define UART_1_CHECK_I2C_STATUS(sourceMask)   (0u != (UART_1_I2C_STATUS_REG & (sourceMask)))
N
N/* Returns true if bit is set in UART_1_SPI_STATUS_REG */
N#define UART_1_CHECK_SPI_STATUS(sourceMask)   (0u != (UART_1_SPI_STATUS_REG & (sourceMask)))
N
N
N/***************************************
N*       SCB Init Macros Definitions
N***************************************/
N
N/* UART_1_CTRL */
N#define UART_1_GET_CTRL_OVS(oversample)   ((((uint32) (oversample)) - 1u) & UART_1_CTRL_OVS_MASK)
N
N#define UART_1_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ? \
N                                                                (UART_1_CTRL_EC_OP_MODE)  : (0u))
X#define UART_1_GET_CTRL_EC_OP_MODE(opMode)        ((0u != (opMode)) ?                                                                 (UART_1_CTRL_EC_OP_MODE)  : (0u))
N
N#define UART_1_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ? \
N                                                                (UART_1_CTRL_EC_AM_MODE)  : (0u))
X#define UART_1_GET_CTRL_EC_AM_MODE(amMode)        ((0u != (amMode)) ?                                                                 (UART_1_CTRL_EC_AM_MODE)  : (0u))
N
N#define UART_1_GET_CTRL_BLOCK(block)              ((0u != (block))  ? \
N                                                                (UART_1_CTRL_BLOCK)       : (0u))
X#define UART_1_GET_CTRL_BLOCK(block)              ((0u != (block))  ?                                                                 (UART_1_CTRL_BLOCK)       : (0u))
N
N#define UART_1_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ? \
N                                                                (UART_1_CTRL_ADDR_ACCEPT) : (0u))
X#define UART_1_GET_CTRL_ADDR_ACCEPT(acceptAddr)   ((0u != (acceptAddr)) ?                                                                 (UART_1_CTRL_ADDR_ACCEPT) : (0u))
N
N/* UART_1_I2C_CTRL */
N#define UART_1_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) & \
N                                                                        UART_1_I2C_CTRL_HIGH_PHASE_OVS_MASK)
X#define UART_1_GET_I2C_CTRL_HIGH_PHASE_OVS(oversampleHigh) (((uint32) (oversampleHigh) - 1u) &                                                                         UART_1_I2C_CTRL_HIGH_PHASE_OVS_MASK)
N
N#define UART_1_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)   (((uint32) (((uint32) (oversampleLow) - 1u) << \
N                                                                    UART_1_I2C_CTRL_LOW_PHASE_OVS_POS)) &  \
N                                                                    UART_1_I2C_CTRL_LOW_PHASE_OVS_MASK)
X#define UART_1_GET_I2C_CTRL_LOW_PHASE_OVS(oversampleLow)   (((uint32) (((uint32) (oversampleLow) - 1u) <<                                                                     UART_1_I2C_CTRL_LOW_PHASE_OVS_POS)) &                                                                      UART_1_I2C_CTRL_LOW_PHASE_OVS_MASK)
N
N#define UART_1_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ? \
N                                                            (UART_1_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
X#define UART_1_GET_I2C_CTRL_S_NOT_READY_ADDR_NACK(wakeNack) ((0u != (wakeNack)) ?                                                             (UART_1_I2C_CTRL_S_NOT_READY_ADDR_NACK) : (0u))
N
N#define UART_1_GET_I2C_CTRL_SL_MSTR_MODE(mode)    ((uint32) ((uint32)(mode) << \
N                                                                    UART_1_I2C_CTRL_SLAVE_MODE_POS))
X#define UART_1_GET_I2C_CTRL_SL_MSTR_MODE(mode)    ((uint32) ((uint32)(mode) <<                                                                     UART_1_I2C_CTRL_SLAVE_MODE_POS))
N
N/* UART_1_SPI_CTRL */
N#define UART_1_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ? \
N                                                                (UART_1_SPI_CTRL_CONTINUOUS) : (0u))
X#define UART_1_GET_SPI_CTRL_CONTINUOUS(separate)  ((0u != (separate)) ?                                                                 (UART_1_SPI_CTRL_CONTINUOUS) : (0u))
N
N#define UART_1_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ? \
N                                                                      (UART_1_SPI_CTRL_SELECT_PRECEDE) : (0u))
X#define UART_1_GET_SPI_CTRL_SELECT_PRECEDE(mode)  ((0u != (mode)) ?                                                                       (UART_1_SPI_CTRL_SELECT_PRECEDE) : (0u))
N
N#define UART_1_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) ((uint32) (mode) << \
N                                                                        UART_1_SPI_CTRL_CPHA_POS)) & \
N                                                                        UART_1_SPI_CTRL_SCLK_MODE_MASK)
X#define UART_1_GET_SPI_CTRL_SCLK_MODE(mode)       (((uint32) ((uint32) (mode) <<                                                                         UART_1_SPI_CTRL_CPHA_POS)) &                                                                         UART_1_SPI_CTRL_SCLK_MODE_MASK)
N
N#define UART_1_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ? \
N                                                                    (UART_1_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
X#define UART_1_GET_SPI_CTRL_LATE_MISO_SAMPLE(lateMiso) ((0u != (lateMiso)) ?                                                                     (UART_1_SPI_CTRL_LATE_MISO_SAMPLE) : (0u))
N
N#define UART_1_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (((uint32) (mode)) << \
N                                                                        UART_1_SPI_CTRL_MODE_POS)) & \
N                                                                        UART_1_SPI_CTRL_MODE_MASK)
X#define UART_1_GET_SPI_CTRL_SUB_MODE(mode)        (((uint32) (((uint32) (mode)) <<                                                                         UART_1_SPI_CTRL_MODE_POS)) &                                                                         UART_1_SPI_CTRL_MODE_MASK)
N
N#define UART_1_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) ((uint32) (select) << \
N                                                                      UART_1_SPI_CTRL_SLAVE_SELECT_POS)) & \
N                                                                      UART_1_SPI_CTRL_SLAVE_SELECT_MASK)
X#define UART_1_GET_SPI_CTRL_SLAVE_SELECT(select)  (((uint32) ((uint32) (select) <<                                                                       UART_1_SPI_CTRL_SLAVE_SELECT_POS)) &                                                                       UART_1_SPI_CTRL_SLAVE_SELECT_MASK)
N
N#define UART_1_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ? \
N                                                                (UART_1_SPI_CTRL_MASTER) : (0u))
X#define UART_1_GET_SPI_CTRL_MASTER_MODE(mode)     ((0u != (mode)) ?                                                                 (UART_1_SPI_CTRL_MASTER) : (0u))
N
N/* UART_1_UART_CTRL */
N#define UART_1_GET_UART_CTRL_MODE(mode)           (((uint32) ((uint32) (mode) << \
N                                                                            UART_1_UART_CTRL_MODE_POS)) & \
N                                                                                UART_1_UART_CTRL_MODE_MASK)
X#define UART_1_GET_UART_CTRL_MODE(mode)           (((uint32) ((uint32) (mode) <<                                                                             UART_1_UART_CTRL_MODE_POS)) &                                                                                 UART_1_UART_CTRL_MODE_MASK)
N
N/* UART_1_UART_RX_CTRL */
N#define UART_1_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                        UART_1_UART_RX_CTRL_STOP_BITS_MASK)
X#define UART_1_GET_UART_RX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                         UART_1_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define UART_1_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                                    (UART_1_UART_RX_CTRL_PARITY) : (0u))
X#define UART_1_GET_UART_RX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                     (UART_1_UART_RX_CTRL_PARITY) : (0u))
N
N#define UART_1_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ? \
N                                                                    (UART_1_UART_RX_CTRL_POLARITY) : (0u))
X#define UART_1_GET_UART_RX_CTRL_POLARITY(polarity)    ((0u != (polarity)) ?                                                                     (UART_1_UART_RX_CTRL_POLARITY) : (0u))
N
N#define UART_1_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (UART_1_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
X#define UART_1_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(dropErr) ((0u != (dropErr)) ?                                                         (UART_1_UART_RX_CTRL_DROP_ON_PARITY_ERR) : (0u))
N
N#define UART_1_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ? \
N                                                        (UART_1_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
X#define UART_1_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(dropErr) ((0u != (dropErr)) ?                                                         (UART_1_UART_RX_CTRL_DROP_ON_FRAME_ERR) : (0u))
N
N#define UART_1_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ? \
N                                                        (UART_1_UART_RX_CTRL_MP_MODE) : (0u))
X#define UART_1_GET_UART_RX_CTRL_MP_MODE(mpMode)   ((0u != (mpMode)) ?                                                         (UART_1_UART_RX_CTRL_MP_MODE) : (0u))
N
N/* UART_1_UART_TX_CTRL */
N#define UART_1_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) & \
N                                                                UART_1_UART_RX_CTRL_STOP_BITS_MASK)
X#define UART_1_GET_UART_TX_CTRL_MODE(stopBits)    (((uint32) (stopBits) - 1u) &                                                                 UART_1_UART_RX_CTRL_STOP_BITS_MASK)
N
N#define UART_1_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ? \
N                                                               (UART_1_UART_TX_CTRL_PARITY) : (0u))
X#define UART_1_GET_UART_TX_CTRL_PARITY(parity)    ((0u != (parity)) ?                                                                (UART_1_UART_TX_CTRL_PARITY) : (0u))
N
N#define UART_1_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ? \
N                                                               (UART_1_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
X#define UART_1_GET_UART_TX_CTRL_RETRY_NACK(nack)  ((0u != (nack)) ?                                                                (UART_1_UART_TX_CTRL_RETRY_ON_NACK) : (0u))
N
N/* UART_1_RX_CTRL */
N#define UART_1_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                UART_1_RX_CTRL_DATA_WIDTH_MASK)
X#define UART_1_GET_RX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 UART_1_RX_CTRL_DATA_WIDTH_MASK)
N
N#define UART_1_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (UART_1_RX_CTRL_MSB_FIRST) : (0u))
X#define UART_1_GET_RX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (UART_1_RX_CTRL_MSB_FIRST) : (0u))
N
N#define UART_1_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ? \
N                                                                (UART_1_RX_CTRL_MEDIAN) : (0u))
X#define UART_1_GET_RX_CTRL_MEDIAN(filterEn)       ((0u != (filterEn)) ?                                                                 (UART_1_RX_CTRL_MEDIAN) : (0u))
N
N/* UART_1_RX_MATCH */
N#define UART_1_GET_RX_MATCH_ADDR(addr)    ((uint32) (addr) & UART_1_RX_MATCH_ADDR_MASK)
N#define UART_1_GET_RX_MATCH_MASK(mask)    (((uint32) ((uint32) (mask) << \
N                                                            UART_1_RX_MATCH_MASK_POS)) & \
N                                                            UART_1_RX_MATCH_MASK_MASK)
X#define UART_1_GET_RX_MATCH_MASK(mask)    (((uint32) ((uint32) (mask) <<                                                             UART_1_RX_MATCH_MASK_POS)) &                                                             UART_1_RX_MATCH_MASK_MASK)
N
N/* UART_1_RX_FIFO_CTRL */
N#define UART_1_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    UART_1_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define UART_1_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     UART_1_RX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* UART_1_TX_CTRL */
N#define UART_1_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) & \
N                                                                UART_1_RX_CTRL_DATA_WIDTH_MASK)
X#define UART_1_GET_TX_CTRL_DATA_WIDTH(dataWidth)  (((uint32) (dataWidth) - 1u) &                                                                 UART_1_RX_CTRL_DATA_WIDTH_MASK)
N
N#define UART_1_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ? \
N                                                                (UART_1_TX_CTRL_MSB_FIRST) : (0u))
X#define UART_1_GET_TX_CTRL_BIT_ORDER(bitOrder)    ((0u != (bitOrder)) ?                                                                 (UART_1_TX_CTRL_MSB_FIRST) : (0u))
N
N/* UART_1_TX_FIFO_CTRL */
N#define UART_1_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) & \
N                                                                    UART_1_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
X#define UART_1_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(level)  ((uint32) (level) &                                                                     UART_1_TX_FIFO_CTRL_TRIGGER_LEVEL_MASK)
N
N/* Clears register: config and interrupt mask */
N#define UART_1_CLEAR_REG          ((uint32) (0u))
N#define UART_1_NO_INTR_SOURCES    ((uint32) (0u))
N#define UART_1_DUMMY_PARAM        ((uint32) (0u))
N#define UART_1_SUBMODE_SPI_SLAVE  ((uint32) (0u))
N
N/* Return in case I2C read error */
N#define UART_1_I2C_INVALID_BYTE   ((uint32) 0xFFFFFFFFu)
N#define UART_1_CHECK_VALID_BYTE   ((uint32) 0x80000000u)
N
N#endif /* (CY_SCB_UART_1_H) */
N
N
N/* [] END OF FILE */
L 23 ".\Generated_Source\PSoC4\UART_1_PVT.h" 2
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
N/* APIs to service INTR_I2C_EC register */
N#define UART_1_SetI2CExtClkInterruptMode(interruptMask) UART_1_WRITE_INTR_I2C_EC_MASK(interruptMask)
N#define UART_1_ClearI2CExtClkInterruptSource(interruptMask) UART_1_CLEAR_INTR_I2C_EC(interruptMask)
N#define UART_1_GetI2CExtClkInterruptSource()                (UART_1_INTR_I2C_EC_REG)
N#define UART_1_GetI2CExtClkInterruptMode()                  (UART_1_INTR_I2C_EC_MASK_REG)
N#define UART_1_GetI2CExtClkInterruptSourceMasked()          (UART_1_INTR_I2C_EC_MASKED_REG)
N
N/* APIs to service INTR_SPI_EC register */
N#define UART_1_SetSpiExtClkInterruptMode(interruptMask) UART_1_WRITE_INTR_SPI_EC_MASK(interruptMask)
N#define UART_1_ClearSpiExtClkInterruptSource(interruptMask) UART_1_CLEAR_INTR_SPI_EC(interruptMask)
N#define UART_1_GetExtSpiClkInterruptSource()                 (UART_1_INTR_SPI_EC_REG)
N#define UART_1_GetExtSpiClkInterruptMode()                   (UART_1_INTR_SPI_EC_MASK_REG)
N#define UART_1_GetExtSpiClkInterruptSourceMasked()           (UART_1_INTR_SPI_EC_MASKED_REG)
N
N#if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    extern void UART_1_SetPins(uint32 mode, uint32 subMode, uint32 uartTxRx);
N#endif /* (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
N
Nvoid UART_1_DisableTxPinsInputBuffer(void);
Nvoid UART_1_EnableTxPinsInputBuffer(void);
N
N
N/**********************************
N*     Vars with External Linkage
N**********************************/
N
Nextern cyisraddress UART_1_customIntrHandler;
Nextern UART_1_BACKUP_STRUCT UART_1_backup;
N
N#if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* Common config vars */
S    extern uint8 UART_1_scbMode;
S    extern uint8 UART_1_scbEnableWake;
S    extern uint8 UART_1_scbEnableIntr;
S
S    /* I2C config vars */
S    extern uint8 UART_1_mode;
S    extern uint8 UART_1_acceptAddr;
S
S    /* SPI/UART config vars */
S    extern volatile uint8 * UART_1_rxBuffer;
S    extern uint8   UART_1_rxDataBits;
S    extern uint32  UART_1_rxBufferSize;
S
S    extern volatile uint8 * UART_1_txBuffer;
S    extern uint8   UART_1_txDataBits;
S    extern uint32  UART_1_txBufferSize;
S
S    /* EZI2C config vars */
S    extern uint8 UART_1_numberOfAddr;
S    extern uint8 UART_1_subAddrSize;
N#endif /* (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#endif /* (CY_SCB_PVT_UART_1_H) */
N
N
N/* [] END OF FILE */
L 19 ".\Generated_Source\PSoC4\UART_1_UART.c" 2
N#include "UART_1_SPI_UART_PVT.h"
L 1 ".\Generated_Source\PSoC4\UART_1_SPI_UART_PVT.h" 1
N/*******************************************************************************
N* File Name: UART_1_SPI_UART_PVT.h
N* Version 1.10
N*
N* Description:
N*  This private file provides constants and parameter values for the
N*  SCB Component in SPI and UART modes.
N*  Please do not use this file or its content in your project.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2013, Cypress Semiconductor Corporation. All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_PVT_UART_1_H)
X#if !0L
N#define CY_SCB_SPI_UART_PVT_UART_1_H
N
N#include "UART_1_SPI_UART.h"
L 1 ".\Generated_Source\PSoC4\UART_1_SPI_UART.h" 1
N/*******************************************************************************
N* File Name: UART_1_SPI_UART.h
N* Version 1.10
N*
N* Description:
N*  This file provides constants and parameter values for the SCB Component in
N*  SPI and UART modes.
N*
N* Note:
N*
N********************************************************************************
N* Copyright 2013, Cypress Semiconductor Corporation.  All rights reserved.
N* You may use this file only in accordance with the license, terms, conditions,
N* disclaimers, and limitations in the end user license agreement accompanying
N* the software package with which this file was provided.
N*******************************************************************************/
N
N#if !defined(CY_SCB_SPI_UART_UART_1_H)
X#if !0L
N#define CY_SCB_SPI_UART_UART_1_H
N
N#include "UART_1.h"
N
N
N/***************************************
N*   SPI Initial Parameter Constants
N****************************************/
N
N#define UART_1_SPI_MODE                   (0u)
N#define UART_1_SPI_SUB_MODE               (0u)
N#define UART_1_SPI_CLOCK_MODE             (0u)
N#define UART_1_SPI_OVS_FACTOR             (16u)
N#define UART_1_SPI_MEDIAN_FILTER_ENABLE   (0u)
N#define UART_1_SPI_LATE_MISO_SAMPLE_ENABLE (0u)
N#define UART_1_SPI_RX_DATA_BITS_NUM       (8u)
N#define UART_1_SPI_TX_DATA_BITS_NUM       (8u)
N#define UART_1_SPI_WAKE_ENABLE            (0u)
N#define UART_1_SPI_BITS_ORDER             (1u)
N#define UART_1_SPI_TRANSFER_SEPARATION    (1u)
N#define UART_1_SPI_NUMBER_OF_SS_LINES     (1u)
N#define UART_1_SPI_RX_BUFFER_SIZE         (8u)
N#define UART_1_SPI_TX_BUFFER_SIZE         (8u)
N
N#define UART_1_SPI_INTERRUPT_MODE         (0u)
N
N#define UART_1_SPI_INTR_RX_MASK           (0u)
N#define UART_1_SPI_INTR_TX_MASK           (0u)
N
N#define UART_1_SPI_RX_TRIGGER_LEVEL       (7u)
N#define UART_1_SPI_TX_TRIGGER_LEVEL       (0u)
N
N
N/***************************************
N*   UART Initial Parameter Constants
N****************************************/
N
N#define UART_1_UART_SUB_MODE              (0u)
N#define UART_1_UART_DIRECTION             (3u)
N#define UART_1_UART_DATA_BITS_NUM         (8u)
N#define UART_1_UART_PARITY_TYPE           (2u)
N#define UART_1_UART_STOP_BITS_NUM         (2u)
N#define UART_1_UART_OVS_FACTOR            (12u)
N#define UART_1_UART_IRDA_LOW_POWER        (0u)
N#define UART_1_UART_MEDIAN_FILTER_ENABLE  (0u)
N#define UART_1_UART_RETRY_ON_NACK         (0u)
N#define UART_1_UART_IRDA_POLARITY         (0u)
N#define UART_1_UART_DROP_ON_FRAME_ERR     (0u)
N#define UART_1_UART_DROP_ON_PARITY_ERR    (0u)
N#define UART_1_UART_WAKE_ENABLE           (0u)
N#define UART_1_UART_RX_BUFFER_SIZE        (8u)
N#define UART_1_UART_TX_BUFFER_SIZE        (8u)
N#define UART_1_UART_MP_MODE_ENABLE        (0u)
N#define UART_1_UART_MP_ACCEPT_ADDRESS     (0u)
N#define UART_1_UART_MP_RX_ADDRESS         (2u)
N#define UART_1_UART_MP_RX_ADDRESS_MASK    (255u)
N
N#define UART_1_UART_INTERRUPT_MODE        (0u)
N
N#define UART_1_UART_INTR_RX_MASK          (0u)
N#define UART_1_UART_INTR_TX_MASK          (0u)
N
N#define UART_1_UART_RX_TRIGGER_LEVEL      (7u)
N#define UART_1_UART_TX_TRIGGER_LEVEL      (0u)
N
N/* Sources of RX errors */
N#define UART_1_INTR_RX_ERR        (UART_1_INTR_RX_OVERFLOW    | \
N                                             UART_1_INTR_RX_UNDERFLOW   | \
N                                             UART_1_INTR_RX_FRAME_ERROR | \
N                                             UART_1_INTR_RX_PARITY_ERROR)
X#define UART_1_INTR_RX_ERR        (UART_1_INTR_RX_OVERFLOW    |                                              UART_1_INTR_RX_UNDERFLOW   |                                              UART_1_INTR_RX_FRAME_ERROR |                                              UART_1_INTR_RX_PARITY_ERROR)
N
N/* UART direction enum */
N#define UART_1_UART_RX    (1u)
N#define UART_1_UART_TX    (2u)
N#define UART_1_UART_TX_RX (3u)
N
N
N/***************************************
N*   Conditional Compilation Parameters
N****************************************/
N
N#if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S
S    /* Direction */
S    #define UART_1_RX_DIRECTION           (1u)
S    #define UART_1_TX_DIRECTION           (1u)
S    #define UART_1_UART_RX_DIRECTION      (1u)
S    #define UART_1_UART_TX_DIRECTION      (1u)
S
S    /* Only external RX and TX buffer for uncofigured mode */
S    #define UART_1_INTERNAL_RX_SW_BUFFER   (0u)
S    #define UART_1_INTERNAL_TX_SW_BUFFER   (0u)
S
S    /* Get RX and TX buffer size */
S    #define UART_1_RX_BUFFER_SIZE (UART_1_rxBufferSize)
S    #define UART_1_TX_BUFFER_SIZE (UART_1_txBufferSize)
S
S    /* Return true if buffer is provided */
S    #define UART_1_CHECK_RX_SW_BUFFER (NULL != UART_1_rxBuffer)
S    #define UART_1_CHECK_TX_SW_BUFFER (NULL != UART_1_txBuffer)
S
S    /* Alwasy provde global variables to support RX and TX buffers */
S    #define UART_1_INTERNAL_RX_SW_BUFFER_CONST    (1u)
S    #define UART_1_INTERNAL_TX_SW_BUFFER_CONST    (1u)
S
S    /* Get wakeup enable option */
S    #define UART_1_SPI_WAKE_ENABLE_CONST  (1u)
S    #define UART_1_CHECK_SPI_WAKE_ENABLE  (0u != UART_1_scbEnableWake)
S    #define UART_1_UART_WAKE_ENABLE_CONST (1u)
S
N#else
N
N    /* SPI internal RX and TX buffers */
N    #define UART_1_INTERNAL_SPI_RX_SW_BUFFER  (UART_1_SPI_RX_BUFFER_SIZE > \
N                                                                                            UART_1_FIFO_SIZE)
X    #define UART_1_INTERNAL_SPI_RX_SW_BUFFER  (UART_1_SPI_RX_BUFFER_SIZE >                                                                                             UART_1_FIFO_SIZE)
N    #define UART_1_INTERNAL_SPI_TX_SW_BUFFER  (UART_1_SPI_TX_BUFFER_SIZE > \
N                                                                                            UART_1_FIFO_SIZE)
X    #define UART_1_INTERNAL_SPI_TX_SW_BUFFER  (UART_1_SPI_TX_BUFFER_SIZE >                                                                                             UART_1_FIFO_SIZE)
N
N    /* UART internal RX and TX buffers */
N    #define UART_1_INTERNAL_UART_RX_SW_BUFFER  (UART_1_UART_RX_BUFFER_SIZE > \
N                                                                                            UART_1_FIFO_SIZE)
X    #define UART_1_INTERNAL_UART_RX_SW_BUFFER  (UART_1_UART_RX_BUFFER_SIZE >                                                                                             UART_1_FIFO_SIZE)
N    #define UART_1_INTERNAL_UART_TX_SW_BUFFER  (UART_1_UART_TX_BUFFER_SIZE > \
N                                                                                            UART_1_FIFO_SIZE)
X    #define UART_1_INTERNAL_UART_TX_SW_BUFFER  (UART_1_UART_TX_BUFFER_SIZE >                                                                                             UART_1_FIFO_SIZE)
N
N    /* SPI Direction */
N    #define UART_1_SPI_RX_DIRECTION (1u)
N    #define UART_1_SPI_TX_DIRECTION (1u)
N
N    /* UART Direction */
N    #define UART_1_UART_RX_DIRECTION (0u != (UART_1_UART_DIRECTION & UART_1_UART_RX))
N    #define UART_1_UART_TX_DIRECTION (0u != (UART_1_UART_DIRECTION & UART_1_UART_TX))
N
N    /* Direction */
N    #define UART_1_RX_DIRECTION ((UART_1_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (UART_1_SPI_RX_DIRECTION) : (UART_1_UART_RX_DIRECTION))
X    #define UART_1_RX_DIRECTION ((UART_1_SCB_MODE_SPI_CONST_CFG) ?                                             (UART_1_SPI_RX_DIRECTION) : (UART_1_UART_RX_DIRECTION))
N
N    #define UART_1_TX_DIRECTION ((UART_1_SCB_MODE_SPI_CONST_CFG) ? \
N                                            (UART_1_SPI_TX_DIRECTION) : (UART_1_UART_TX_DIRECTION))
X    #define UART_1_TX_DIRECTION ((UART_1_SCB_MODE_SPI_CONST_CFG) ?                                             (UART_1_SPI_TX_DIRECTION) : (UART_1_UART_TX_DIRECTION))
N
N    /* Internal RX and TX buffer: for SPI or UART */
N    #if(UART_1_SCB_MODE_SPI_CONST_CFG)
X    #if(((0x02u) == (4u)))
S
S        /* Internal SPI RX and TX buffer */
S        #define UART_1_INTERNAL_RX_SW_BUFFER  (UART_1_INTERNAL_SPI_RX_SW_BUFFER)
S        #define UART_1_INTERNAL_TX_SW_BUFFER  (UART_1_INTERNAL_SPI_TX_SW_BUFFER)
S
S        /* Internal SPI RX and TX buffer size */
S        #define UART_1_RX_BUFFER_SIZE         (UART_1_SPI_RX_BUFFER_SIZE + 1u)
S        #define UART_1_TX_BUFFER_SIZE         (UART_1_SPI_TX_BUFFER_SIZE)
S        
S        /* Get wakeup enable option */
S        #define UART_1_SPI_WAKE_ENABLE_CONST  (0u != UART_1_SPI_WAKE_ENABLE)
S        #define UART_1_UART_WAKE_ENABLE_CONST (0u)
S
N    #else
N
N        /* Internal UART RX and TX buffer */
N        #define UART_1_INTERNAL_RX_SW_BUFFER  (UART_1_INTERNAL_UART_RX_SW_BUFFER)
N        #define UART_1_INTERNAL_TX_SW_BUFFER  (UART_1_INTERNAL_UART_TX_SW_BUFFER)
N
N        /* Internal UART RX and TX buffer size */
N        #define UART_1_RX_BUFFER_SIZE         (UART_1_UART_RX_BUFFER_SIZE + 1u)
N        #define UART_1_TX_BUFFER_SIZE         (UART_1_UART_TX_BUFFER_SIZE)
N        
N        /* Get wakeup enable option */
N        #define UART_1_SPI_WAKE_ENABLE_CONST  (0u)
N        #define UART_1_UART_WAKE_ENABLE_CONST (0u != UART_1_UART_WAKE_ENABLE)
N    #endif /* (UART_1_SCB_MODE_SPI_CONST_CFG) */
N
N    /* Internal RX and TX buffer: for SPI or UART. Used in conditional compilation check */
N    #define UART_1_CHECK_RX_SW_BUFFER (UART_1_INTERNAL_RX_SW_BUFFER)
N    #define UART_1_CHECK_TX_SW_BUFFER (UART_1_INTERNAL_TX_SW_BUFFER)
N
N    /* Provide global variables to support RX and TX buffers */
N    #define UART_1_INTERNAL_RX_SW_BUFFER_CONST    (UART_1_INTERNAL_RX_SW_BUFFER)
N    #define UART_1_INTERNAL_TX_SW_BUFFER_CONST    (UART_1_INTERNAL_TX_SW_BUFFER)
N    
N    /* Wakeup for SPI */
N    #define UART_1_CHECK_SPI_WAKE_ENABLE  (UART_1_SPI_WAKE_ENABLE_CONST)
N
N#endif /* End (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N/* Bootloader communication interface enable: NOT supported yet */
N#define UART_1_SPI_BTLDR_COMM_ENABLED   ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) || \
N                                                    (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
X#define UART_1_SPI_BTLDR_COMM_ENABLED   ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) ||                                                     (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
N
N#define UART_1_UART_BTLDR_COMM_ENABLED   ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) || \
N                                                    (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
X#define UART_1_UART_BTLDR_COMM_ENABLED   ((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) ||                                                     (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface))
N
N
N/***************************************
N*       Type Definitions
N***************************************/
N
N/* UART_1_SPI_INIT_STRUCT */
Ntypedef struct
N{
N    uint32 mode;
N    uint32 submode;
N    uint32 sclkMode;
N    uint32 oversample;
N    uint32 enableMedianFilter;
N    uint32 enableLateSampling;
N    uint32 enableWake;
N    uint32 rxDataBits;
N    uint32 txDataBits;
N    uint32 bitOrder;
N    uint32 transferSeperation;
N    uint32 rxBufferSize;
N    uint8* rxBuffer;
N    uint32 txBufferSize;
N    uint8* txBuffer;
N    uint32 enableInterrupt;
N    uint32 rxInterruptMask;
N    uint32 rxTriggerLevel;
N    uint32 txInterruptMask;
N    uint32 txTriggerLevel;
N} UART_1_SPI_INIT_STRUCT;
N
N/* UART_1_UART_INIT_STRUCT */
Ntypedef struct
N{
N    uint32 mode;
N    uint32 direction;
N    uint32 dataBits;
N    uint32 parity;
N    uint32 stopBits;
N    uint32 oversample;
N    uint32 enableIrdaLowPower;
N    uint32 enableMedianFilter;
N    uint32 enableRetryNack;
N    uint32 enableInvertedRx;
N    uint32 dropOnParityErr;
N    uint32 dropOnFrameErr;
N    uint32 enableWake;
N    uint32 rxBufferSize;
N    uint8* rxBuffer;
N    uint32 txBufferSize;
N    uint8* txBuffer;
N    uint32 enableMultiproc;
N    uint32 multiprocAcceptAddr;
N    uint32 multiprocAddr;
N    uint32 multiprocAddrMask;
N    uint32 enableInterrupt;
N    uint32 rxInterruptMask;
N    uint32 rxTriggerLevel;
N    uint32 txInterruptMask;
N    uint32 txTriggerLevel;
N} UART_1_UART_INIT_STRUCT;
N
N
N/***************************************
N*        Function Prototypes
N***************************************/
N
N/* SPI specific functions */
N#if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    void UART_1_SpiInit(const UART_1_SPI_INIT_STRUCT *config);
N#endif /* (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if(UART_1_SCB_MODE_SPI_INC)
X#if((0u !=((0x02u) & (4u))))
S    void UART_1_SpiSetActiveSlaveSelect(uint32 activeSelect);
N#endif /* (UART_1_SCB_MODE_SPI_INC) */
N
N/* UART specific functions */
N#if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    void UART_1_UartInit(const UART_1_UART_INIT_STRUCT *config);
N#endif /* (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N#if(UART_1_SCB_MODE_UART_INC)
X#if((0u !=((0x04u) & (4u))))
N    void UART_1_UartSetRxAddress(uint32 address);
N    void UART_1_UartSetRxAddressMask(uint32 addressMask);
N#endif /* (UART_1_SCB_MODE_UART_INC) */
N
N/* UART RX direction APIs */
N#if(UART_1_UART_RX_DIRECTION)
X#if((0u != ((3u) & (1u))))
N    uint32 UART_1_UartGetChar(void);
N    uint32 UART_1_UartGetByte(void);
N#endif /* (UART_1_UART_RX_DIRECTION) */
N
N/* UART TX direction APIs */
N#if(UART_1_UART_TX_DIRECTION)
X#if((0u != ((3u) & (2u))))
N    #define UART_1_UartPutChar(ch)    UART_1_SpiUartWriteTxData((uint32)(ch))
N    void UART_1_UartPutString(const char8 string[]);
N    void UART_1_UartPutCRLF(uint32 txDataByte);
N#endif /* (UART_1_UART_TX_DIRECTION) */
N
N/* Common APIs Rx direction */
N#if(UART_1_RX_DIRECTION)
X#if(((((0x02u) == (4u))) ? ((1u)) : ((0u != ((3u) & (1u))))))
N    uint32 UART_1_SpiUartReadRxData(void);
N    uint32 UART_1_SpiUartGetRxBufferSize(void);
N    void   UART_1_SpiUartClearRxBuffer(void);
N#endif /* (UART_1_RX_DIRECTION) */
N
N/* Common APIs Tx direction */
N#if(UART_1_TX_DIRECTION)
X#if(((((0x02u) == (4u))) ? ((1u)) : ((0u != ((3u) & (2u))))))
N    void   UART_1_SpiUartWriteTxData(uint32 txDataByte);
N    void   UART_1_SpiUartPutArray(const uint8 wrBuf[], uint32 count);
N    void   UART_1_SpiUartClearTxBuffer(void);
N    uint32 UART_1_SpiUartGetTxBufferSize(void);
N#endif /* (UART_1_TX_DIRECTION) */
N
NCY_ISR_PROTO(UART_1_SPI_UART_ISR);
Xvoid UART_1_SPI_UART_ISR (void);
N
N#if(UART_1_UART_RX_WAKEUP_IRQ)
X#if((0u == (1u)))
S    CY_ISR_PROTO(UART_1_UART_WAKEUP_ISR);
N#endif /* (UART_1_UART_RX_WAKEUP_IRQ) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_SPI_BTLDR_COMM_ENABLED)
X#if 0L && (((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)))
S    /* SPI Bootloader physical layer functions */
S    void UART_1_SpiCyBtldrCommStart(void);
S    void UART_1_SpiCyBtldrCommStop (void);
S    void UART_1_SpiCyBtldrCommReset(void);
S    cystatus UART_1_SpiCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_1_SpiCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_SPI_BTLDR_COMM_ENABLED) */
N
N#if defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_UART_BTLDR_COMM_ENABLED)
X#if 0L && (((CYDEV_BOOTLOADER_IO_COMP == CyBtldr_UART_1) || (CYDEV_BOOTLOADER_IO_COMP == CyBtldr_Custom_Interface)))
S    /* UART Bootloader physical layer functions */
S    void UART_1_UartCyBtldrCommStart(void);
S    void UART_1_UartCyBtldrCommStop (void);
S    void UART_1_UartCyBtldrCommReset(void);
S    cystatus UART_1_UartCyBtldrCommRead       (uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S    cystatus UART_1_UartCyBtldrCommWrite(const uint8 pData[], uint16 size, uint16 * count, uint8 timeOut);
S
N#endif /* defined(CYDEV_BOOTLOADER_IO_COMP) && (UART_1_UART_BTLDR_COMM_ENABLED) */
N
N
N/***************************************
N*     Buffer Access Macro Definitions
N***************************************/
N
N#if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    /* RX direction */
S    void   UART_1_PutWordInRxBuffer  (uint32 idx, uint32 rxDataByte);
S    uint32 UART_1_GetWordFromRxBuffer(uint32 idx);
S
S    /* TX direction */
S    void   UART_1_PutWordInTxBuffer  (uint32 idx, uint32 txDataByte);
S    uint32 UART_1_GetWordFromTxBuffer(uint32 idx);
S
N#else
N
N    /* RX direction */
N    #if(UART_1_INTERNAL_RX_SW_BUFFER_CONST)
X    #if(((((8u) > (8u)))))
S        #define UART_1_PutWordInRxBuffer(idx, rxDataByte) \
S                do{                                                 \
S                    UART_1_rxBufferInternal[(idx)] = ((uint8) (rxDataByte)); \
S                }while(0)
X        #define UART_1_PutWordInRxBuffer(idx, rxDataByte)                 do{                                                                     UART_1_rxBufferInternal[(idx)] = ((uint8) (rxDataByte));                 }while(0)
S
S        #define UART_1_GetWordFromRxBuffer(idx) UART_1_rxBufferInternal[(idx)]
S
N    #endif /* (UART_1_INTERNAL_RX_SW_BUFFER_CONST) */
N
N    /* TX direction */
N    #if(UART_1_INTERNAL_TX_SW_BUFFER_CONST)
X    #if(((((8u) > (8u)))))
S        #define UART_1_PutWordInTxBuffer(idx, txDataByte) \
S                    do{                                             \
S                        UART_1_txBufferInternal[(idx)] = ((uint8) (txDataByte)); \
S                    }while(0)
X        #define UART_1_PutWordInTxBuffer(idx, txDataByte)                     do{                                                                     UART_1_txBufferInternal[(idx)] = ((uint8) (txDataByte));                     }while(0)
S
S        #define UART_1_GetWordFromTxBuffer(idx) UART_1_txBufferInternal[(idx)]
S
N    #endif /* (UART_1_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#endif /* (UART_1_TX_SW_BUFFER_ENABLE) */
N
N
N/***************************************
N*         SPI API Constants
N***************************************/
N
N/* SPI mode enum */
N#define UART_1_SPI_SLAVE  (0u)
N#define UART_1_SPI_MASTER (1u)
N
N/* SPI sub mode enum */
N#define UART_1_SPI_MODE_MOTOROLA      (0x00u)
N#define UART_1_SPI_MODE_TI_COINCIDES  (0x01u)
N#define UART_1_SPI_MODE_TI_PRECEDES   (0x11u)
N#define UART_1_SPI_MODE_NATIONAL      (0x02u)
N#define UART_1_SPI_MODE_MASK          (0x03u)
N#define UART_1_SPI_MODE_TI_PRECEDES_MASK  (0x10u)
N
N/* SPI phase and polarity mode enum */
N#define UART_1_SPI_SCLK_CPHA0_CPOL0   (0x00u)
N#define UART_1_SPI_SCLK_CPHA0_CPOL1   (0x02u)
N#define UART_1_SPI_SCLK_CPHA1_CPOL0   (0x01u)
N#define UART_1_SPI_SCLK_CPHA1_CPOL1   (0x03u)
N
N/* SPI bits order enum */
N#define UART_1_BITS_ORDER_LSB_FIRST   (0u)
N#define UART_1_BITS_ORDER_MSB_FIRST   (1u)
N
N/* SPI transfer separation enum */
N#define UART_1_SPI_TRANSFER_SEPARATED     (0u)
N#define UART_1_SPI_TRANSFER_CONTINUOUS    (1u)
N
N/* "activeSS" constants for SpiSetActiveSlaveSelect() function */
N#define UART_1_SPIM_ACTIVE_SS0    (0x00u)
N#define UART_1_SPIM_ACTIVE_SS1    (0x01u)
N#define UART_1_SPIM_ACTIVE_SS2    (0x02u)
N#define UART_1_SPIM_ACTIVE_SS3    (0x03u)
N
N
N/***************************************
N*         UART API Constants
N***************************************/
N
N/* UART sub-modes enum */
N#define UART_1_UART_MODE_STD          (0u)
N#define UART_1_UART_MODE_SMARTCARD    (1u)
N#define UART_1_UART_MODE_IRDA         (2u)
N
N/* UART direction enum */
N#define UART_1_UART_RX    (1u)
N#define UART_1_UART_TX    (2u)
N#define UART_1_UART_TX_RX (3u)
N
N/* UART parity enum */
N#define UART_1_UART_PARITY_EVEN   (0u)
N#define UART_1_UART_PARITY_ODD    (1u)
N#define UART_1_UART_PARITY_NONE   (2u)
N
N/* UART stop bits enum */
N#define UART_1_UART_STOP_BITS_1   (1u)
N#define UART_1_UART_STOP_BITS_1_5 (2u)
N#define UART_1_UART_STOP_BITS_2   (3u)
N
N/* UART IrDA low power OVS enum */
N#define UART_1_UART_IRDA_LP_OVS16     (16u)
N#define UART_1_UART_IRDA_LP_OVS32     (32u)
N#define UART_1_UART_IRDA_LP_OVS48     (48u)
N#define UART_1_UART_IRDA_LP_OVS96     (96u)
N#define UART_1_UART_IRDA_LP_OVS192    (192u)
N#define UART_1_UART_IRDA_LP_OVS768    (768u)
N#define UART_1_UART_IRDA_LP_OVS1536   (1536u)
N
N/* Uart MP: mark (address) and space (data) bit definitions */
N#define UART_1_UART_MP_MARK       (0x100u)
N#define UART_1_UART_MP_SPACE      (0x000u)
N
N
N/***************************************
N*     Vars with External Linkage
N***************************************/
N
N#if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S    extern const UART_1_SPI_INIT_STRUCT  UART_1_configSpi;
S    extern const UART_1_UART_INIT_STRUCT UART_1_configUart;
N#endif /* (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/***************************************
N*    Specific SPI Macro Definitions
N***************************************/
N
N#define UART_1_GET_SPI_INTR_SLAVE_MASK(sourceMask)  ((sourceMask) & UART_1_INTR_SLAVE_SPI_BUS_ERROR)
N#define UART_1_GET_SPI_INTR_MASTER_MASK(sourceMask) ((sourceMask) & UART_1_INTR_MASTER_SPI_DONE)
N#define UART_1_GET_SPI_INTR_RX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~UART_1_INTR_SLAVE_SPI_BUS_ERROR)
X#define UART_1_GET_SPI_INTR_RX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~UART_1_INTR_SLAVE_SPI_BUS_ERROR)
N
N#define UART_1_GET_SPI_INTR_TX_MASK(sourceMask) \
N                                             ((sourceMask) & (uint32) ~UART_1_INTR_MASTER_SPI_DONE)
X#define UART_1_GET_SPI_INTR_TX_MASK(sourceMask)                                              ((sourceMask) & (uint32) ~UART_1_INTR_MASTER_SPI_DONE)
N
N
N/***************************************
N*    Specific UART Macro Definitions
N***************************************/
N
N#define UART_1_UART_GET_CTRL_OVS_IRDA_LP(oversample) \
N        ((UART_1_UART_IRDA_LP_OVS16   == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS16 : \
N         ((UART_1_UART_IRDA_LP_OVS32   == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS32 : \
N          ((UART_1_UART_IRDA_LP_OVS48   == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS48 : \
N           ((UART_1_UART_IRDA_LP_OVS96   == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS96 : \
N            ((UART_1_UART_IRDA_LP_OVS192  == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS192 : \
N             ((UART_1_UART_IRDA_LP_OVS768  == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS768 : \
N              ((UART_1_UART_IRDA_LP_OVS1536 == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS1536 : \
N                                                                          UART_1_CTRL_OVS_IRDA_LP_OVS16)))))))
X#define UART_1_UART_GET_CTRL_OVS_IRDA_LP(oversample)         ((UART_1_UART_IRDA_LP_OVS16   == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS16 :          ((UART_1_UART_IRDA_LP_OVS32   == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS32 :           ((UART_1_UART_IRDA_LP_OVS48   == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS48 :            ((UART_1_UART_IRDA_LP_OVS96   == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS96 :             ((UART_1_UART_IRDA_LP_OVS192  == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS192 :              ((UART_1_UART_IRDA_LP_OVS768  == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS768 :               ((UART_1_UART_IRDA_LP_OVS1536 == (oversample)) ? UART_1_CTRL_OVS_IRDA_LP_OVS1536 :                                                                           UART_1_CTRL_OVS_IRDA_LP_OVS16)))))))
N
N#define UART_1_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (UART_1_UART_RX & (direction))) ? \
N                                                                    (UART_1_RX_CTRL_ENABLED) : (0u))
X#define UART_1_GET_UART_RX_CTRL_ENABLED(direction) ((0u != (UART_1_UART_RX & (direction))) ?                                                                     (UART_1_RX_CTRL_ENABLED) : (0u))
N
N#define UART_1_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (UART_1_UART_TX & (direction))) ? \
N                                                                    (UART_1_TX_CTRL_ENABLED) : (0u))
X#define UART_1_GET_UART_TX_CTRL_ENABLED(direction) ((0u != (UART_1_UART_TX & (direction))) ?                                                                     (UART_1_TX_CTRL_ENABLED) : (0u))
N
N
N/***************************************
N*        SPI Register Settings
N***************************************/
N
N#define UART_1_CTRL_SPI      (UART_1_CTRL_MODE_SPI)
N#define UART_1_SPI_RX_CTRL   (UART_1_RX_CTRL_ENABLED)
N#define UART_1_SPI_TX_CTRL   (UART_1_TX_CTRL_ENABLED)
N
N
N/***************************************
N*       SPI Init Register Settings
N***************************************/
N
N#if(UART_1_SCB_MODE_SPI_CONST_CFG)
X#if(((0x02u) == (4u)))
S
S    /* SPI Configuration */
S    #define UART_1_SPI_DEFAULT_CTRL \
S                    (UART_1_GET_CTRL_OVS(UART_1_SPI_OVS_FACTOR)         | \
S                     UART_1_GET_CTRL_EC_AM_MODE(UART_1_SPI_WAKE_ENABLE) | \
S                     UART_1_CTRL_SPI)
X    #define UART_1_SPI_DEFAULT_CTRL                     (UART_1_GET_CTRL_OVS(UART_1_SPI_OVS_FACTOR)         |                      UART_1_GET_CTRL_EC_AM_MODE(UART_1_SPI_WAKE_ENABLE) |                      UART_1_CTRL_SPI)
S
S    #define UART_1_SPI_DEFAULT_SPI_CTRL \
S                    (UART_1_GET_SPI_CTRL_CONTINUOUS    (UART_1_SPI_TRANSFER_SEPARATION)       | \
S                     UART_1_GET_SPI_CTRL_SELECT_PRECEDE(UART_1_SPI_SUB_MODE &                   \
S                                                                  UART_1_SPI_MODE_TI_PRECEDES_MASK)     | \
S                     UART_1_GET_SPI_CTRL_SCLK_MODE     (UART_1_SPI_CLOCK_MODE)                | \
S                     UART_1_GET_SPI_CTRL_LATE_MISO_SAMPLE(UART_1_SPI_LATE_MISO_SAMPLE_ENABLE) | \
S                     UART_1_GET_SPI_CTRL_SUB_MODE      (UART_1_SPI_SUB_MODE)                  | \
S                     UART_1_GET_SPI_CTRL_MASTER_MODE   (UART_1_SPI_MODE))
X    #define UART_1_SPI_DEFAULT_SPI_CTRL                     (UART_1_GET_SPI_CTRL_CONTINUOUS    (UART_1_SPI_TRANSFER_SEPARATION)       |                      UART_1_GET_SPI_CTRL_SELECT_PRECEDE(UART_1_SPI_SUB_MODE &                                                                                     UART_1_SPI_MODE_TI_PRECEDES_MASK)     |                      UART_1_GET_SPI_CTRL_SCLK_MODE     (UART_1_SPI_CLOCK_MODE)                |                      UART_1_GET_SPI_CTRL_LATE_MISO_SAMPLE(UART_1_SPI_LATE_MISO_SAMPLE_ENABLE) |                      UART_1_GET_SPI_CTRL_SUB_MODE      (UART_1_SPI_SUB_MODE)                  |                      UART_1_GET_SPI_CTRL_MASTER_MODE   (UART_1_SPI_MODE))
S
S    /* RX direction */
S    #define UART_1_SPI_DEFAULT_RX_CTRL \
S                    (UART_1_GET_RX_CTRL_DATA_WIDTH(UART_1_SPI_RX_DATA_BITS_NUM)     | \
S                     UART_1_GET_RX_CTRL_BIT_ORDER (UART_1_SPI_BITS_ORDER)           | \
S                     UART_1_GET_RX_CTRL_MEDIAN    (UART_1_SPI_MEDIAN_FILTER_ENABLE) | \
S                     UART_1_SPI_RX_CTRL)
X    #define UART_1_SPI_DEFAULT_RX_CTRL                     (UART_1_GET_RX_CTRL_DATA_WIDTH(UART_1_SPI_RX_DATA_BITS_NUM)     |                      UART_1_GET_RX_CTRL_BIT_ORDER (UART_1_SPI_BITS_ORDER)           |                      UART_1_GET_RX_CTRL_MEDIAN    (UART_1_SPI_MEDIAN_FILTER_ENABLE) |                      UART_1_SPI_RX_CTRL)
S
S    #define UART_1_SPI_DEFAULT_RX_FIFO_CTRL \
S                    UART_1_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_SPI_RX_TRIGGER_LEVEL)
X    #define UART_1_SPI_DEFAULT_RX_FIFO_CTRL                     UART_1_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_SPI_RX_TRIGGER_LEVEL)
S
S    /* TX direction */
S    #define UART_1_SPI_DEFAULT_TX_CTRL \
S                    (UART_1_GET_TX_CTRL_DATA_WIDTH(UART_1_SPI_TX_DATA_BITS_NUM) | \
S                     UART_1_GET_TX_CTRL_BIT_ORDER (UART_1_SPI_BITS_ORDER)       | \
S                     UART_1_SPI_TX_CTRL)
X    #define UART_1_SPI_DEFAULT_TX_CTRL                     (UART_1_GET_TX_CTRL_DATA_WIDTH(UART_1_SPI_TX_DATA_BITS_NUM) |                      UART_1_GET_TX_CTRL_BIT_ORDER (UART_1_SPI_BITS_ORDER)       |                      UART_1_SPI_TX_CTRL)
S
S    #define UART_1_SPI_DEFAULT_TX_FIFO_CTRL \
S                    UART_1_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_SPI_TX_TRIGGER_LEVEL)
X    #define UART_1_SPI_DEFAULT_TX_FIFO_CTRL                     UART_1_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_SPI_TX_TRIGGER_LEVEL)
S
S    /* Interrupt sources */
S    #define UART_1_SPI_DEFAULT_INTR_SPI_EC_MASK   (UART_1_NO_INTR_SOURCES)
S
S    #define UART_1_SPI_DEFAULT_INTR_I2C_EC_MASK   (UART_1_NO_INTR_SOURCES)
S    #define UART_1_SPI_DEFAULT_INTR_SLAVE_MASK \
S                    (UART_1_SPI_INTR_RX_MASK & UART_1_INTR_SLAVE_SPI_BUS_ERROR)
X    #define UART_1_SPI_DEFAULT_INTR_SLAVE_MASK                     (UART_1_SPI_INTR_RX_MASK & UART_1_INTR_SLAVE_SPI_BUS_ERROR)
S
S    #define UART_1_SPI_DEFAULT_INTR_MASTER_MASK \
S                    (UART_1_SPI_INTR_TX_MASK & UART_1_INTR_MASTER_SPI_DONE)
X    #define UART_1_SPI_DEFAULT_INTR_MASTER_MASK                     (UART_1_SPI_INTR_TX_MASK & UART_1_INTR_MASTER_SPI_DONE)
S
S    #define UART_1_SPI_DEFAULT_INTR_RX_MASK \
S                    (UART_1_SPI_INTR_RX_MASK & (uint32) ~UART_1_INTR_SLAVE_SPI_BUS_ERROR)
X    #define UART_1_SPI_DEFAULT_INTR_RX_MASK                     (UART_1_SPI_INTR_RX_MASK & (uint32) ~UART_1_INTR_SLAVE_SPI_BUS_ERROR)
S
S    #define UART_1_SPI_DEFAULT_INTR_TX_MASK \
S                    (UART_1_SPI_INTR_TX_MASK & (uint32) ~UART_1_INTR_MASTER_SPI_DONE)
X    #define UART_1_SPI_DEFAULT_INTR_TX_MASK                     (UART_1_SPI_INTR_TX_MASK & (uint32) ~UART_1_INTR_MASTER_SPI_DONE)
S
N#endif /* (UART_1_SCB_MODE_SPI_CONST_CFG) */
N
N
N/***************************************
N*        UART Register Settings
N***************************************/
N
N#define UART_1_CTRL_UART      (UART_1_CTRL_MODE_UART)
N#define UART_1_UART_RX_CTRL   (UART_1_RX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N#define UART_1_UART_TX_CTRL   (UART_1_TX_CTRL_LSB_FIRST) /* LSB for UART goes first */
N
N
N/***************************************
N*      UART Init Register Settings
N***************************************/
N
N#if(UART_1_SCB_MODE_UART_CONST_CFG)
X#if(((0x04u) == (4u)))
N
N    /* UART configuration */
N    #if(UART_1_UART_MODE_IRDA == UART_1_UART_SUB_MODE)
X    #if((2u) == (0u))
S
S        #define UART_1_DEFAULT_CTRL_OVS   ((0u != UART_1_UART_IRDA_LOW_POWER) ?              \
S                                (UART_1_UART_GET_CTRL_OVS_IRDA_LP(UART_1_UART_OVS_FACTOR)) : \
S                                (UART_1_CTRL_OVS_IRDA_OVS16))
X        #define UART_1_DEFAULT_CTRL_OVS   ((0u != UART_1_UART_IRDA_LOW_POWER) ?                                              (UART_1_UART_GET_CTRL_OVS_IRDA_LP(UART_1_UART_OVS_FACTOR)) :                                 (UART_1_CTRL_OVS_IRDA_OVS16))
S
N    #else
N
N        #define UART_1_DEFAULT_CTRL_OVS   UART_1_GET_CTRL_OVS(UART_1_UART_OVS_FACTOR)
N
N    #endif /* (UART_1_UART_MODE_IRDA == UART_1_UART_SUB_MODE) */
N
N    #define UART_1_UART_DEFAULT_CTRL \
N                                (UART_1_GET_CTRL_ADDR_ACCEPT(UART_1_UART_MP_ACCEPT_ADDRESS) | \
N                                 UART_1_DEFAULT_CTRL_OVS                                              | \
N                                 UART_1_CTRL_UART)
X    #define UART_1_UART_DEFAULT_CTRL                                 (UART_1_GET_CTRL_ADDR_ACCEPT(UART_1_UART_MP_ACCEPT_ADDRESS) |                                  UART_1_DEFAULT_CTRL_OVS                                              |                                  UART_1_CTRL_UART)
N
N    #define UART_1_UART_DEFAULT_UART_CTRL \
N                                    (UART_1_GET_UART_CTRL_MODE(UART_1_UART_SUB_MODE))
X    #define UART_1_UART_DEFAULT_UART_CTRL                                     (UART_1_GET_UART_CTRL_MODE(UART_1_UART_SUB_MODE))
N
N    /* RX direction */
N    #define UART_1_UART_DEFAULT_RX_CTRL_PARITY \
N                                ((UART_1_UART_PARITY_NONE != UART_1_UART_PARITY_TYPE) ?      \
N                                  (UART_1_GET_UART_RX_CTRL_PARITY(UART_1_UART_PARITY_TYPE) | \
N                                   UART_1_UART_RX_CTRL_PARITY_ENABLED) : (0u))
X    #define UART_1_UART_DEFAULT_RX_CTRL_PARITY                                 ((UART_1_UART_PARITY_NONE != UART_1_UART_PARITY_TYPE) ?                                        (UART_1_GET_UART_RX_CTRL_PARITY(UART_1_UART_PARITY_TYPE) |                                    UART_1_UART_RX_CTRL_PARITY_ENABLED) : (0u))
N
N    #define UART_1_UART_DEFAULT_UART_RX_CTRL \
N                    (UART_1_GET_UART_RX_CTRL_MODE(UART_1_UART_STOP_BITS_NUM)                    | \
N                     UART_1_GET_UART_RX_CTRL_POLARITY(UART_1_UART_IRDA_POLARITY)                | \
N                     UART_1_GET_UART_RX_CTRL_MP_MODE(UART_1_UART_MP_MODE_ENABLE)                | \
N                     UART_1_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(UART_1_UART_DROP_ON_PARITY_ERR) | \
N                     UART_1_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(UART_1_UART_DROP_ON_FRAME_ERR)   | \
N                     UART_1_UART_DEFAULT_RX_CTRL_PARITY)
X    #define UART_1_UART_DEFAULT_UART_RX_CTRL                     (UART_1_GET_UART_RX_CTRL_MODE(UART_1_UART_STOP_BITS_NUM)                    |                      UART_1_GET_UART_RX_CTRL_POLARITY(UART_1_UART_IRDA_POLARITY)                |                      UART_1_GET_UART_RX_CTRL_MP_MODE(UART_1_UART_MP_MODE_ENABLE)                |                      UART_1_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(UART_1_UART_DROP_ON_PARITY_ERR) |                      UART_1_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(UART_1_UART_DROP_ON_FRAME_ERR)   |                      UART_1_UART_DEFAULT_RX_CTRL_PARITY)
N
N    #define UART_1_UART_DEFAULT_RX_CTRL \
N                                (UART_1_GET_RX_CTRL_DATA_WIDTH(UART_1_UART_DATA_BITS_NUM)        | \
N                                 UART_1_GET_RX_CTRL_MEDIAN    (UART_1_UART_MEDIAN_FILTER_ENABLE) | \
N                                 UART_1_GET_UART_RX_CTRL_ENABLED(UART_1_UART_DIRECTION))
X    #define UART_1_UART_DEFAULT_RX_CTRL                                 (UART_1_GET_RX_CTRL_DATA_WIDTH(UART_1_UART_DATA_BITS_NUM)        |                                  UART_1_GET_RX_CTRL_MEDIAN    (UART_1_UART_MEDIAN_FILTER_ENABLE) |                                  UART_1_GET_UART_RX_CTRL_ENABLED(UART_1_UART_DIRECTION))
N
N    #define UART_1_UART_DEFAULT_RX_FIFO_CTRL \
N                                UART_1_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_UART_RX_TRIGGER_LEVEL)
X    #define UART_1_UART_DEFAULT_RX_FIFO_CTRL                                 UART_1_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_UART_RX_TRIGGER_LEVEL)
N
N    #define UART_1_UART_DEFAULT_RX_MATCH_REG  ((0u != UART_1_UART_MP_MODE_ENABLE) ?          \
N                                (UART_1_GET_RX_MATCH_ADDR(UART_1_UART_MP_RX_ADDRESS) | \
N                                 UART_1_GET_RX_MATCH_MASK(UART_1_UART_MP_RX_ADDRESS_MASK)) : (0u))
X    #define UART_1_UART_DEFAULT_RX_MATCH_REG  ((0u != UART_1_UART_MP_MODE_ENABLE) ?                                          (UART_1_GET_RX_MATCH_ADDR(UART_1_UART_MP_RX_ADDRESS) |                                  UART_1_GET_RX_MATCH_MASK(UART_1_UART_MP_RX_ADDRESS_MASK)) : (0u))
N
N    /* TX direction */
N    #define UART_1_UART_DEFAULT_TX_CTRL_PARITY (UART_1_UART_DEFAULT_RX_CTRL_PARITY)
N
N    #define UART_1_UART_DEFAULT_UART_TX_CTRL \
N                                (UART_1_GET_UART_TX_CTRL_MODE(UART_1_UART_STOP_BITS_NUM)       | \
N                                 UART_1_GET_UART_TX_CTRL_RETRY_NACK(UART_1_UART_RETRY_ON_NACK) | \
N                                 UART_1_UART_DEFAULT_TX_CTRL_PARITY)
X    #define UART_1_UART_DEFAULT_UART_TX_CTRL                                 (UART_1_GET_UART_TX_CTRL_MODE(UART_1_UART_STOP_BITS_NUM)       |                                  UART_1_GET_UART_TX_CTRL_RETRY_NACK(UART_1_UART_RETRY_ON_NACK) |                                  UART_1_UART_DEFAULT_TX_CTRL_PARITY)
N
N    #define UART_1_UART_DEFAULT_TX_CTRL \
N                                (UART_1_GET_TX_CTRL_DATA_WIDTH(UART_1_UART_DATA_BITS_NUM) | \
N                                 UART_1_GET_UART_TX_CTRL_ENABLED(UART_1_UART_DIRECTION))
X    #define UART_1_UART_DEFAULT_TX_CTRL                                 (UART_1_GET_TX_CTRL_DATA_WIDTH(UART_1_UART_DATA_BITS_NUM) |                                  UART_1_GET_UART_TX_CTRL_ENABLED(UART_1_UART_DIRECTION))
N
N    #define UART_1_UART_DEFAULT_TX_FIFO_CTRL \
N                                UART_1_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_UART_TX_TRIGGER_LEVEL)
X    #define UART_1_UART_DEFAULT_TX_FIFO_CTRL                                 UART_1_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(UART_1_UART_TX_TRIGGER_LEVEL)
N
N    /* Interrupt sources */
N    #define UART_1_UART_DEFAULT_INTR_I2C_EC_MASK  (UART_1_NO_INTR_SOURCES)
N    #define UART_1_UART_DEFAULT_INTR_SPI_EC_MASK  (UART_1_NO_INTR_SOURCES)
N    #define UART_1_UART_DEFAULT_INTR_SLAVE_MASK   (UART_1_NO_INTR_SOURCES)
N    #define UART_1_UART_DEFAULT_INTR_MASTER_MASK  (UART_1_NO_INTR_SOURCES)
N    #define UART_1_UART_DEFAULT_INTR_RX_MASK      (UART_1_UART_INTR_RX_MASK)
N    #define UART_1_UART_DEFAULT_INTR_TX_MASK      (UART_1_UART_INTR_TX_MASK)
N
N#endif /* (UART_1_SCB_MODE_UART_CONST_CFG) */
N
N#endif /* CY_SCB_SPI_UART_UART_1_H */
N
N
N/* [] END OF FILE */
L 23 ".\Generated_Source\PSoC4\UART_1_SPI_UART_PVT.h" 2
N
N
N/***************************************
N*     Internal Global Vars
N***************************************/
N
N#if(UART_1_INTERNAL_RX_SW_BUFFER_CONST)
X#if(((((8u) > (8u)))))
S    extern volatile uint32  UART_1_rxBufferHead;
S    extern volatile uint32  UART_1_rxBufferTail;
S    extern volatile uint8   UART_1_rxBufferOverflow;
N#endif /* (UART_1_INTERNAL_RX_SW_BUFFER_CONST) */
N
N#if(UART_1_INTERNAL_TX_SW_BUFFER_CONST)
X#if(((((8u) > (8u)))))
S    extern volatile uint32  UART_1_txBufferHead;
S    extern volatile uint32  UART_1_txBufferTail;
N#endif /* (UART_1_INTERNAL_TX_SW_BUFFER_CONST) */
N
N#if(UART_1_INTERNAL_RX_SW_BUFFER)
X#if((((8u) > (8u))))
S    extern volatile uint8 UART_1_rxBufferInternal[UART_1_RX_BUFFER_SIZE];
N#endif /* (UART_1_INTERNAL_RX_SW_BUFFER) */
N
N#if(UART_1_INTERNAL_TX_SW_BUFFER)
X#if((((8u) > (8u))))
S    extern volatile uint8 UART_1_txBufferInternal[UART_1_TX_BUFFER_SIZE];
N#endif /* (UART_1_INTERNAL_TX_SW_BUFFER) */
N
N
N/***************************************
N*     Private Function Prototypes
N***************************************/
N
N#if(UART_1_SCB_MODE_SPI_CONST_CFG)
X#if(((0x02u) == (4u)))
S    void UART_1_SpiInit(void);
N#endif /* (UART_1_SCB_MODE_SPI_CONST_CFG) */
N
N#if(UART_1_SPI_WAKE_ENABLE_CONST)
X#if((0u))
S    void UART_1_SpiSaveConfig(void);
S    void UART_1_SpiRestoreConfig(void);
N#endif /* (UART_1_SPI_WAKE_ENABLE_CONST) */
N
N#if(UART_1_SCB_MODE_UART_CONST_CFG)
X#if(((0x04u) == (4u)))
N    void UART_1_UartInit(void);
N#endif /* (UART_1_SCB_MODE_UART_CONST_CFG) */
N
N#if(UART_1_UART_WAKE_ENABLE_CONST)
X#if((0u != (0u)))
S    void UART_1_UartSaveConfig(void);
S    void UART_1_UartRestoreConfig(void);
N#endif /* (UART_1_UART_WAKE_ENABLE_CONST) */
N
N/* Interrupt processing */
N#define UART_1_SpiUartEnableIntRx(intSourceMask)  UART_1_SetRxInterruptMode(intSourceMask)
N#define UART_1_SpiUartEnableIntTx(intSourceMask)  UART_1_SetTxInterruptMode(intSourceMask)
Nuint32 UART_1_SpiUartDisableIntRx(void);
Nuint32 UART_1_SpiUartDisableIntTx(void);
N
N#endif /* (CY_SCB_SPI_UART_PVT_UART_1_H) */
N
N
N/* [] END OF FILE */
L 20 ".\Generated_Source\PSoC4\UART_1_UART.c" 2
N
N
N#if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
X#if(((0xFFu) == (4u)))
S
S    /***************************************
S    *  Config Structure Initialization
S    ***************************************/
S
S    const UART_1_UART_INIT_STRUCT UART_1_configUart =
S    {
S        UART_1_UART_SUB_MODE,
S        UART_1_UART_DIRECTION,
S        UART_1_UART_DATA_BITS_NUM,
S        UART_1_UART_PARITY_TYPE,
S        UART_1_UART_STOP_BITS_NUM,
S        UART_1_UART_OVS_FACTOR,
S        UART_1_UART_IRDA_LOW_POWER,
S        UART_1_UART_MEDIAN_FILTER_ENABLE,
S        UART_1_UART_RETRY_ON_NACK,
S        UART_1_UART_IRDA_POLARITY,
S        UART_1_UART_DROP_ON_PARITY_ERR,
S        UART_1_UART_DROP_ON_FRAME_ERR,
S        UART_1_UART_WAKE_ENABLE,
S        0u,
S        NULL,
S        0u,
S        NULL,
S        UART_1_UART_MP_MODE_ENABLE,
S        UART_1_UART_MP_ACCEPT_ADDRESS,
S        UART_1_UART_MP_RX_ADDRESS,
S        UART_1_UART_MP_RX_ADDRESS_MASK,
S        UART_1_SCB_IRQ_INTERNAL,
S        UART_1_UART_INTR_RX_MASK,
S        UART_1_UART_RX_TRIGGER_LEVEL,
S        UART_1_UART_INTR_TX_MASK,
S        UART_1_UART_TX_TRIGGER_LEVEL
S    };
S
S
S    /*******************************************************************************
S    * Function Name: UART_1_UartInit
S    ********************************************************************************
S    *
S    * Summary:
S    *  Configures the SCB for SPI operation.
S    *
S    * Parameters:
S    *  config:  Pointer to a structure that contains the following ordered list of
S    *           fields. These fields match the selections available in the
S    *           customizer.
S    *
S    * Return:
S    *  None
S    *
S    *******************************************************************************/
S    void UART_1_UartInit(const UART_1_UART_INIT_STRUCT *config)
S    {
S        if(NULL == config)
S        {
S            CYASSERT(0u != 0u); /* Halt execution due bad fucntion parameter */
S        }
S        else
S        {
S            /* Configure pins */
S            UART_1_SetPins(UART_1_SCB_MODE_UART, config->mode, config->direction);
S
S            /* Store internal configuration */
S            UART_1_scbMode       = (uint8) UART_1_SCB_MODE_UART;
S            UART_1_scbEnableWake = (uint8) config->enableWake;
S            UART_1_scbEnableIntr = (uint8) config->enableInterrupt;
S
S            /* Set RX direction internal variables */
S            UART_1_rxBuffer      =         config->rxBuffer;
S            UART_1_rxDataBits    = (uint8) config->dataBits;
S            UART_1_rxBufferSize  = (uint8) config->rxBufferSize;
S
S            /* Set TX direction internal variables */
S            UART_1_txBuffer      =         config->txBuffer;
S            UART_1_txDataBits    = (uint8) config->dataBits;
S            UART_1_txBufferSize  = (uint8) config->txBufferSize;
S
S
S            /* Configure UART interface */
S            if(UART_1_UART_MODE_IRDA == config->mode)
S            {
S                /* OVS settigns: IrDA */
S                UART_1_CTRL_REG  = ((0u != config->enableIrdaLowPower) ?
S                                                (UART_1_UART_GET_CTRL_OVS_IRDA_LP(config->oversample)) :
S                                                (UART_1_CTRL_OVS_IRDA_OVS16));
S            }
S            else
S            {
S                /* OVS settigns: UART and SmartCard */
S                UART_1_CTRL_REG  = UART_1_GET_CTRL_OVS(config->oversample);
S            }
S
S            UART_1_CTRL_REG     |= UART_1_GET_CTRL_ADDR_ACCEPT(config->multiprocAcceptAddr) |
S                                             UART_1_CTRL_UART;
S
S            /* Confiuure submode: UART, SmartCard or IrDA */
S            UART_1_UART_CTRL_REG = UART_1_GET_UART_CTRL_MODE(config->mode);
S
S            /* Configure RX direction */
S            UART_1_UART_RX_CTRL_REG = UART_1_GET_UART_RX_CTRL_MODE(config->stopBits)              |
S                                        UART_1_GET_UART_RX_CTRL_POLARITY(config->enableInvertedRx)          |
S                                        UART_1_GET_UART_RX_CTRL_MP_MODE(config->enableMultiproc)            |
S                                        UART_1_GET_UART_RX_CTRL_DROP_ON_PARITY_ERR(config->dropOnParityErr) |
S                                        UART_1_GET_UART_RX_CTRL_DROP_ON_FRAME_ERR(config->dropOnFrameErr);
S
S            if(UART_1_UART_PARITY_NONE != config->parity)
S            {
S               UART_1_UART_RX_CTRL_REG |= UART_1_GET_UART_RX_CTRL_PARITY(config->parity) |
S                                                    UART_1_UART_RX_CTRL_PARITY_ENABLED;
S            }
S
S            UART_1_RX_CTRL_REG      = UART_1_GET_RX_CTRL_DATA_WIDTH(config->dataBits)       |
S                                                UART_1_GET_RX_CTRL_MEDIAN(config->enableMedianFilter) |
S                                                UART_1_GET_UART_RX_CTRL_ENABLED(config->direction);
S
S            UART_1_RX_FIFO_CTRL_REG = UART_1_GET_RX_FIFO_CTRL_TRIGGER_LEVEL(config->rxTriggerLevel);
S
S            /* Configure MP address */
S            UART_1_RX_MATCH_REG     = UART_1_GET_RX_MATCH_ADDR(config->multiprocAddr) |
S                                                UART_1_GET_RX_MATCH_MASK(config->multiprocAddrMask);
S
S            /* Configure RX direction */
S            UART_1_UART_TX_CTRL_REG = UART_1_GET_UART_TX_CTRL_MODE(config->stopBits) |
S                                                UART_1_GET_UART_TX_CTRL_RETRY_NACK(config->enableRetryNack);
S
S            if(UART_1_UART_PARITY_NONE != config->parity)
S            {
S               UART_1_UART_TX_CTRL_REG |= UART_1_GET_UART_TX_CTRL_PARITY(config->parity) |
S                                                    UART_1_UART_TX_CTRL_PARITY_ENABLED;
S            }
S
S            UART_1_TX_CTRL_REG      = UART_1_GET_TX_CTRL_DATA_WIDTH(config->dataBits)    |
S                                                UART_1_GET_UART_TX_CTRL_ENABLED(config->direction);
S
S            UART_1_TX_FIFO_CTRL_REG = UART_1_GET_TX_FIFO_CTRL_TRIGGER_LEVEL(config->txTriggerLevel);
S
S
S            /* Configure WAKE interrupt */
S            #if(UART_1_UART_RX_WAKEUP_IRQ)
S                UART_1_RX_WAKEUP_IRQ_StartEx(&UART_1_UART_WAKEUP_ISR);
S                UART_1_RX_WAKEUP_IRQ_Disable();
S            #endif /* (UART_1_UART_RX_WAKEUP_IRQ) */
S
S            /* Configure interrupt with UART handler */
S            UART_1_SCB_IRQ_Disable();
S            UART_1_SCB_IRQ_SetVector(&UART_1_SPI_UART_ISR);
S            UART_1_SCB_IRQ_SetPriority((uint8)UART_1_SCB_IRQ_INTC_PRIOR_NUMBER);
S
S            /* Configure interrupt sources */
S            UART_1_INTR_I2C_EC_MASK_REG = UART_1_NO_INTR_SOURCES;
S            UART_1_INTR_SPI_EC_MASK_REG = UART_1_NO_INTR_SOURCES;
S            UART_1_INTR_SLAVE_MASK_REG  = UART_1_NO_INTR_SOURCES;
S            UART_1_INTR_MASTER_MASK_REG = UART_1_NO_INTR_SOURCES;
S            UART_1_INTR_RX_MASK_REG     = config->rxInterruptMask;
S            UART_1_INTR_TX_MASK_REG     = config->txInterruptMask;
S
S            /* Clear RX buffer indexes */
S            UART_1_rxBufferHead     = 0u;
S            UART_1_rxBufferTail     = 0u;
S            UART_1_rxBufferOverflow = 0u;
S
S            /* Clrea TX buffer indexes */
S            UART_1_txBufferHead = 0u;
S            UART_1_txBufferTail = 0u;
S        }
S    }
S
N#else
N
N    /*******************************************************************************
N    * Function Name: UART_1_UartInit
N    ********************************************************************************
N    *
N    * Summary:
N    *  Configures the SCB for SPI operation.
N    *
N    * Parameters:
N    *  None
N    *
N    * Return:
N    *  None
N    *
N    *******************************************************************************/
N    void UART_1_UartInit(void)
N    {
N        /* Configure UART interface */
N        UART_1_CTRL_REG = UART_1_UART_DEFAULT_CTRL;
X        (*(reg32 *) 0x40060000u) = (((0u != ((0u))) ? (((uint32) ((uint32) 0x01u << (16u)))) : (0u)) | ((((uint32) ((12u))) - 1u) & ((uint32) 0x0Fu)) | (((uint32) ((uint32) 0x02u << (24u)))));
N
N        /* Confiuure submode: UART, SmartCard or IrDA */
N        UART_1_UART_CTRL_REG = UART_1_UART_DEFAULT_UART_CTRL;
X        (*(reg32 *) 0x40060040u) = ((((uint32) ((uint32) ((0u)) << (24u))) & ((uint32) ((uint32) 0x03u << (24u)))));
N
N        /* Configure RX direction */
N        UART_1_UART_RX_CTRL_REG = UART_1_UART_DEFAULT_UART_RX_CTRL;
X        (*(reg32 *) 0x40060048u) = ((((uint32) ((2u)) - 1u) & ((uint32) 0x07u)) | ((0u != ((0u))) ? (((uint32) ((uint32) 0x01u << (6u)))) : (0u)) | ((0u != ((0u))) ? (((uint32) ((uint32) 0x01u << (10u)))) : (0u)) | ((0u != ((0u))) ? (((uint32) ((uint32) 0x01u << (8u)))) : (0u)) | ((0u != ((0u))) ? (((uint32) ((uint32) 0x01u << (9u)))) : (0u)) | (((2u) != (2u)) ? (((0u != ((2u))) ? (((uint32) ((uint32) 0x01u << (4u)))) : (0u)) | ((uint32) ((uint32) 0x01u << (5u)))) : (0u)));
N        UART_1_RX_CTRL_REG      = UART_1_UART_DEFAULT_RX_CTRL;
X        (*(reg32 *) 0x40060300u)      = ((((uint32) ((8u)) - 1u) & ((uint32) 0x0Fu)) | ((0u != ((0u))) ? (((uint32) ((uint32) 0x01u << (9u)))) : (0u)) | ((0u != ((1u) & ((3u)))) ? (((uint32) ((uint32) 0x01u << (31u)))) : (0u)));
N        UART_1_RX_FIFO_CTRL_REG = UART_1_UART_DEFAULT_RX_FIFO_CTRL;
X        (*(reg32 *) 0x40060304u) = ((uint32) ((7u)) & ((uint32) 0x07u));
N        UART_1_RX_MATCH_REG     = UART_1_UART_DEFAULT_RX_MATCH_REG;
X        (*(reg32 *) 0x40060310u)     = ((0u != (0u)) ? (((uint32) ((2u)) & ((uint32) 0xFFu)) | (((uint32) ((uint32) ((255u)) << (16u))) & ((uint32) ((uint32) 0xFFu << (16u))))) : (0u));
N
N        /* Configure TX direction */
N        UART_1_UART_TX_CTRL_REG = UART_1_UART_DEFAULT_UART_TX_CTRL;
X        (*(reg32 *) 0x40060044u) = ((((uint32) ((2u)) - 1u) & ((uint32) 0x07u)) | ((0u != ((0u))) ? (((uint32) ((uint32) 0x01u << (8u)))) : (0u)) | ((((2u) != (2u)) ? (((0u != ((2u))) ? (((uint32) ((uint32) 0x01u << (4u)))) : (0u)) | ((uint32) ((uint32) 0x01u << (5u)))) : (0u))));
N        UART_1_TX_CTRL_REG      = UART_1_UART_DEFAULT_TX_CTRL;
X        (*(reg32 *) 0x40060200u)      = ((((uint32) ((8u)) - 1u) & ((uint32) 0x0Fu)) | ((0u != ((2u) & ((3u)))) ? (((uint32) ((uint32) 0x01u << (31u)))) : (0u)));
N        UART_1_TX_FIFO_CTRL_REG = UART_1_UART_DEFAULT_TX_FIFO_CTRL;
X        (*(reg32 *) 0x40060204u) = ((uint32) ((0u)) & ((uint32) 0x07u));
N
N        /* Configure interrupt with UART handler */
N        #if(UART_1_SCB_IRQ_INTERNAL)
X        #if((0u == (1u)))
S            UART_1_SCB_IRQ_Disable();
S            UART_1_SCB_IRQ_SetVector(&UART_1_SPI_UART_ISR);
S            UART_1_SCB_IRQ_SetPriority((uint8)UART_1_SCB_IRQ_INTC_PRIOR_NUMBER);
N        #endif /* (UART_1_SCB_IRQ_INTERNAL) */
N
N        /* Configure WAKE interrupt */
N        #if(UART_1_UART_RX_WAKEUP_IRQ)
X        #if((0u == (1u)))
S            UART_1_RX_WAKEUP_IRQ_StartEx(&UART_1_UART_WAKEUP_ISR);
S            UART_1_RX_WAKEUP_IRQ_Disable();
N        #endif /* (UART_1_UART_RX_WAKEUP_IRQ) */
N        
N        /* Configure interrupt sources */
N        UART_1_INTR_I2C_EC_MASK_REG = UART_1_UART_DEFAULT_INTR_I2C_EC_MASK;
X        (*(reg32 *) 0x40060e88u) = (((uint32) (0u)));
N        UART_1_INTR_SPI_EC_MASK_REG = UART_1_UART_DEFAULT_INTR_SPI_EC_MASK;
X        (*(reg32 *) 0x40060ec8u) = (((uint32) (0u)));
N        UART_1_INTR_SLAVE_MASK_REG  = UART_1_UART_DEFAULT_INTR_SLAVE_MASK;
X        (*(reg32 *) 0x40060f48u)  = (((uint32) (0u)));
N        UART_1_INTR_MASTER_MASK_REG = UART_1_UART_DEFAULT_INTR_MASTER_MASK;
X        (*(reg32 *) 0x40060f08u) = (((uint32) (0u)));
N        UART_1_INTR_RX_MASK_REG     = UART_1_UART_DEFAULT_INTR_RX_MASK;
X        (*(reg32 *) 0x40060fc8u)     = ((0u));
N        UART_1_INTR_TX_MASK_REG     = UART_1_UART_DEFAULT_INTR_TX_MASK;
X        (*(reg32 *) 0x40060f88u)     = ((0u));
N
N        #if(UART_1_INTERNAL_RX_SW_BUFFER_CONST)
X        #if(((((8u) > (8u)))))
S            UART_1_rxBufferHead     = 0u;
S            UART_1_rxBufferTail     = 0u;
S            UART_1_rxBufferOverflow = 0u;
N        #endif /* (UART_1_INTERNAL_RX_SW_BUFFER_CONST) */
N
N        #if(UART_1_INTERNAL_TX_SW_BUFFER_CONST)
X        #if(((((8u) > (8u)))))
S            UART_1_txBufferHead = 0u;
S            UART_1_txBufferTail = 0u;
N        #endif /* (UART_1_INTERNAL_TX_SW_BUFFER_CONST) */
N    }
N
N#endif /* (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
N
N
N/*******************************************************************************
N* Function Name: UART_1_UartSetRxAddress
N********************************************************************************
N*
N* Summary:
N*  Sets the hardware detectable receiver address for the UART in Multiprocessor
N*  mode.
N*
N* Parameters:
N*  address: Address for hardware address detection.
N*
N* Return:
N*  None
N*
N*******************************************************************************/
Nvoid UART_1_UartSetRxAddress(uint32 address)
N{
N     uint32 matchReg;
N
N    matchReg = UART_1_RX_MATCH_REG;
X    matchReg = (*(reg32 *) 0x40060310u);
N
N    matchReg &= ((uint32) ~UART_1_RX_MATCH_ADDR_MASK); /* Clear address bits */
X    matchReg &= ((uint32) ~((uint32) 0xFFu));  
N    matchReg |= ((uint32)  (address & UART_1_RX_MATCH_ADDR_MASK)); /* Set address  */
X    matchReg |= ((uint32)  (address & ((uint32) 0xFFu)));  
N
N    UART_1_RX_MATCH_REG = matchReg;
X    (*(reg32 *) 0x40060310u) = matchReg;
N}
N
N
N/*******************************************************************************
N* Function Name: UART_1_UartSetRxAddressMask
N********************************************************************************
N*
N* Summary:
N*  Sets the hardware address mask for the UART in Multiprocessor mode.
N*
N* Parameters:
N*  addressMask: Address mask.
N*   0 - address bit does not care while comparison.
N*   1 - address bit is significant while comparison.
N*
N* Return:
N*  None
N*
N*******************************************************************************/
Nvoid UART_1_UartSetRxAddressMask(uint32 addressMask)
N{
N    uint32 matchReg;
N
N    matchReg = UART_1_RX_MATCH_REG;
X    matchReg = (*(reg32 *) 0x40060310u);
N
N    matchReg &= ((uint32) ~UART_1_RX_MATCH_MASK_MASK); /* Clear address mask bits */
X    matchReg &= ((uint32) ~((uint32) ((uint32) 0xFFu << (16u))));  
N    matchReg |= ((uint32) (addressMask << UART_1_RX_MATCH_MASK_POS));
X    matchReg |= ((uint32) (addressMask << (16u)));
N
N    UART_1_RX_MATCH_REG = matchReg;
X    (*(reg32 *) 0x40060310u) = matchReg;
N}
N
N
N#if(UART_1_UART_RX_DIRECTION)
X#if((0u != ((3u) & (1u))))
N    /*******************************************************************************
N    * Function Name: UART_1_UartGetChar
N    ********************************************************************************
N    *
N    * Summary:
N    *  Retrieves next data element from receive buffer.
N    *  This function is designed for ASCII characters and returns a char
N    *  where 1 to 255 is valid characters and 0 indicates an error occurred or
N    *  no data is present.
N    *  RX software buffer disabled: returns data element retrieved from RX FIFO.
N    *  Undefined data will be returned if the RX FIFO is empty.
N    *  RX software buffer enabled: Returns data element from the software receive
N    *  buffer.
N    *
N    * Parameters:
N    *  None
N    *
N    * Return:
N    *  Next data element from the receive buffer.
N    *  ASCII character values from 1 to 255 are valid.
N    *  A returned zero signifies an error condition or no data available.
N    *
N    *******************************************************************************/
N    uint32 UART_1_UartGetChar(void)
N    {
N        uint32 rxData = 0u;
N
N        /* Read data only if there is data to read */
N        if(0u != UART_1_SpiUartGetRxBufferSize())
N        {
N            rxData = UART_1_SpiUartReadRxData();
N        }
N
N        if(UART_1_CHECK_INTR_RX(UART_1_INTR_RX_ERR))
X        if((0u != ((*(reg32 *) 0x40060fc0u) & ((((uint32) ((uint32) 0x01u << (5u))) | ((uint32) ((uint32) 0x01u << (6u))) | ((uint32) ((uint32) 0x01u << (8u))) | ((uint32) ((uint32) 0x01u << (9u))))))))
N        {
N            rxData = 0u; /* Error occured: return zero */
N            UART_1_ClearRxInterruptSource(UART_1_INTR_RX_ERR);
X            do{ (*(reg32 *) 0x40060fc0u) = (uint32) ((((uint32) ((uint32) 0x01u << (5u))) | ((uint32) ((uint32) 0x01u << (6u))) | ((uint32) ((uint32) 0x01u << (8u))) | ((uint32) ((uint32) 0x01u << (9u))))); }while(0);
N        }
N
N        return(rxData);
N    }
N
N
N    /*******************************************************************************
N    * Function Name: UART_1_UartGetByte
N    ********************************************************************************
N    *
N    * Summary:
N    *  Retrieves next data element from the receive buffer, returns received byte
N    *  and error condition.
N    *  RX software buffer disabled: Returns data element retrieved from RX FIFO.
N    *  Undefined data will be returned if the RX FIFO is empty.
N    *  RX software buffer enabled: Returns data element from the software receive
N    *  buffer.
N    *
N    * Parameters:
N    *  None
N    *
N    * Return:
N    *  Bits 15-8 contains status and bits 7-0 contains the next data element from
N    *  receive buffer. If the bits 15-8 are nonzero, an error has occurred.
N    *
N    *******************************************************************************/
N    uint32 UART_1_UartGetByte(void)
N    {
N        uint32 rxData;
N        uint32 tmpStatus;
N        uint32 intSourceMask;
N
N        intSourceMask = UART_1_SpiUartDisableIntRx();
N
N        if(0u != UART_1_SpiUartGetRxBufferSize())
N        {
N             /*
N             * Enable interrupt to receive more bytes: at least one byte is in
N             * buffer.
N             */
N            UART_1_SpiUartEnableIntRx(intSourceMask);
X            do{ (*(reg32 *) 0x40060fc8u) = (uint32) (intSourceMask); }while(0);
N
N            /* Get received byte */
N            rxData = UART_1_SpiUartReadRxData();
N        }
N        else
N        {
N            /*
N            * Read byte directly from RX FIFO: the underflow is raised in case
N            * of empty. In other case the first received byte will be read.
N            */
N            rxData = UART_1_RX_FIFO_RD_REG;
X            rxData = (*(reg32 *) 0x40060340u);
N
N            /*
N            * Enable interrupt to receive more bytes.
N            * The RX_NOT_EMPTY interrupt is cleared by interrupt routine in case
N            * byte was received and read above.
N            */
N            UART_1_SpiUartEnableIntRx(intSourceMask);
X            do{ (*(reg32 *) 0x40060fc8u) = (uint32) (intSourceMask); }while(0);
N        }
N
N        /* Get and clear RX error mask */
N        tmpStatus = (UART_1_GetRxInterruptSource() & UART_1_INTR_RX_ERR);
X        tmpStatus = (((*(reg32 *) 0x40060fc0u)) & (((uint32) ((uint32) 0x01u << (5u))) | ((uint32) ((uint32) 0x01u << (6u))) | ((uint32) ((uint32) 0x01u << (8u))) | ((uint32) ((uint32) 0x01u << (9u)))));
N        UART_1_ClearRxInterruptSource(UART_1_INTR_RX_ERR);
X        do{ (*(reg32 *) 0x40060fc0u) = (uint32) ((((uint32) ((uint32) 0x01u << (5u))) | ((uint32) ((uint32) 0x01u << (6u))) | ((uint32) ((uint32) 0x01u << (8u))) | ((uint32) ((uint32) 0x01u << (9u))))); }while(0);
N
N        /*
N        * Put together data and error status:
N        * MP mode and accept address: the 9th bit is set to notify mark.
N        */
N        rxData |= ((uint32) (tmpStatus << 8u));
N
N        return(rxData);
N    }
N
N#endif /* (UART_1_UART_RX_DIRECTION) */
N
N
N#if(UART_1_UART_TX_DIRECTION)
X#if((0u != ((3u) & (2u))))
N    /*******************************************************************************
N    * Function Name: UART_1_UartPutString
N    ********************************************************************************
N    *
N    * Summary:
N    *  Places a NULL terminated string in the transmit buffer to be sent at the
N    *  next available bus time.
N    *  This function is blocking and waits until there is a space available to put
N    *  all requested data in transmit buffer.
N    *
N    * Parameters:
N    *  string: pointer to the null terminated string array to be placed in the
N    *          transmit buffer.
N    *
N    * Return:
N    *  None
N    *
N    *******************************************************************************/
N    void UART_1_UartPutString(const char8 string[])
N    {
N        uint32 bufIndex;
N
N        bufIndex = 0u;
N
N        /* Blocks the control flow until all data will be sent */
N        while(string[bufIndex] != ((char8) 0))
N        {
N            UART_1_UartPutChar((uint32) string[bufIndex]);
X            UART_1_SpiUartWriteTxData((uint32)((uint32) string[bufIndex]));
N            bufIndex++;
N        }
N    }
N
N
N    /*******************************************************************************
N    * Function Name: UART_1_UartPutCRLF
N    ********************************************************************************
N    *
N    * Summary:
N    *  Places byte of data followed by a carriage return (0x0D) and line feed (0x0A)
N    *  to the transmit buffer.
N    *  This function is blocking and waits until there is a space available to put
N    *  all requested data in transmit buffer.
N    *
N    * Parameters:
N    *  txDataByte : the data to be transmitted.
N    *
N    * Return:
N    *  None
N    *
N    *******************************************************************************/
N    void UART_1_UartPutCRLF(uint32 txDataByte)
N    {
N        UART_1_UartPutChar(txDataByte);  /* Blocks the control flow until all data will be sent */
X        UART_1_SpiUartWriteTxData((uint32)(txDataByte));   
N        UART_1_UartPutChar(0x0Du);       /* Blocks the control flow until all data will be sent */
X        UART_1_SpiUartWriteTxData((uint32)(0x0Du));        
N        UART_1_UartPutChar(0x0Au);       /* Blocks the control flow until all data will be sent */
X        UART_1_SpiUartWriteTxData((uint32)(0x0Au));        
N    }
N#endif /* (UART_1_UART_TX_DIRECTION) */
N
N
N#if(UART_1_UART_WAKE_ENABLE_CONST)
X#if((0u != (0u)))
S    /*******************************************************************************
S    * Function Name: UART_1_UartSaveConfig
S    ********************************************************************************
S    *
S    * Summary:
S    *  Wakeup disabled: does nothing.
S    *  Wakeup enabled: clears SCB_backup.enableStateto keep component enabled while
S    *  DeepSleep. Clears and enables interrupt on falling edge of rx input. The GPIO
S    *  event wakes up the device and SKIP_START feature allows UART continue
S    *  receiving data bytes properly. The GPIO interrupt does not track in active mode
S    *  therefore requires to be cleared by this API. It makes uart wakeup single
S    *  triggered event.
S    *
S    * Parameters:
S    *  None
S    *
S    * Return:
S    *  None
S    *
S    *******************************************************************************/
S    void UART_1_UartSaveConfig(void)
S    {
S        /* Clear interrupt activy:
S        *  - set skip start and disable RX. On GPIO wakeup the RX will be enabled.
S        *  - clear rx_wake interrupt source as it triggers while normal operations.
S        *  - clear wake interrupt pending state as it becomes pending in active mode.
S        */
S
S        UART_1_UART_RX_CTRL_REG |= UART_1_UART_RX_CTRL_SKIP_START;
S
S        #if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
S            #if(UART_1_MOSI_SCL_RX_WAKE_PIN)
S                (void) UART_1_spi_mosi_i2c_scl_uart_rx_wake_ClearInterrupt();
S            #endif /* (UART_1_MOSI_SCL_RX_WAKE_PIN) */
S        #else
S            #if(UART_1_UART_RX_WAKE_PIN)
S                (void) UART_1_rx_wake_ClearInterrupt();
S            #endif /* (UART_1_UART_RX_WAKE_PIN) */
S        #endif /* (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
S
S        #if(UART_1_UART_RX_WAKEUP_IRQ)
S            UART_1_RX_WAKEUP_IRQ_ClearPending();
S            UART_1_RX_WAKEUP_IRQ_Enable();
S        #endif /* (UART_1_UART_RX_WAKEUP_IRQ) */
S    }
S
S
S    /*******************************************************************************
S    * Function Name: UART_1_UartRestoreConfig
S    ********************************************************************************
S    *
S    * Summary:
S    *  Does nothing.
S    *
S    * Parameters:
S    *  None
S    *
S    * Return:
S    *  None
S    *
S    *******************************************************************************/
S    void UART_1_UartRestoreConfig(void)
S    {
S        /* Disable RX GPIO interrupt: no more triggers in active mode */
S        #if(UART_1_UART_RX_WAKEUP_IRQ)
S            UART_1_RX_WAKEUP_IRQ_Disable();
S        #endif /* (UART_1_UART_RX_WAKEUP_IRQ) */
S    }
N#endif /* (UART_1_UART_WAKE_ENABLE_CONST) */
N
N
N#if(UART_1_UART_RX_WAKEUP_IRQ)
X#if((0u == (1u)))
S    /*******************************************************************************
S    * Function Name: UART_1_UART_WAKEUP_ISR
S    ********************************************************************************
S    *
S    * Summary:
S    *  Handles Interrupt Service Routine for SCB UART mode GPIO wakeup event.
S    *
S    * Parameters:
S    *  None
S    *
S    * Return:
S    *  None
S    *
S    *******************************************************************************/
S    CY_ISR(UART_1_UART_WAKEUP_ISR)
S    {
S        /* Clear interrupt source: the event becomes multi triggerred and only disabled
S        * by UART_1_UartRestoreConfig() call.
S        */
S        #if(UART_1_SCB_MODE_UNCONFIG_CONST_CFG)
S            #if(UART_1_MOSI_SCL_RX_WAKE_PIN)
S                (void) UART_1_spi_mosi_i2c_scl_uart_rx_wake_ClearInterrupt();
S            #endif /* (UART_1_MOSI_SCL_RX_WAKE_PIN) */
S        #else
S            #if(UART_1_UART_RX_WAKE_PIN)
S                (void) UART_1_rx_wake_ClearInterrupt();
S            #endif /* (UART_1_UART_RX_WAKE_PIN) */
S        #endif /* (UART_1_SCB_MODE_UNCONFIG_CONST_CFG) */
S    }
N#endif /* (UART_1_UART_RX_WAKEUP_IRQ) */
N
N
N/* [] END OF FILE */
